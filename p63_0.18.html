<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Project 63 - Slot Blackjack</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Fira+Code:wght@400;500&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0e17;
      --bg-secondary: #121a2a;
      --bg-card: #1a2436;
      --bg-hover: #243044;
      --text-primary: #e8edf5;
      --text-secondary: #8b9cb8;
      --text-muted: #5a6a84;
      --accent-gold: #f0c040;
      --accent-gold-dim: #9a7a20;
      --accent-red: #e84545;
      --accent-green: #3dd68c;
      --accent-blue: #4da6ff;
      --accent-purple: #a855f7;
      --border-color: #2a3a54;
      --card-red: #dc3545;
      --card-black: #1a1a2e;
    }

    .dark {
      --bg-primary: #0a0e17;
      --bg-secondary: #121a2a;
      --bg-card: #1a2436;
      --bg-hover: #243044;
      --text-primary: #e8edf5;
      --text-secondary: #8b9cb8;
      --text-muted: #5a6a84;
      --border-color: #2a3a54;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* HUD Styles */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(18, 26, 42, 0.95) 100%);
      border-bottom: 1px solid var(--border-color);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      backdrop-filter: blur(10px);
    }

    .hud-left, .hud-right {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .hud-center{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .hud-icon-btn{
      width: 38px;
      height: 38px;
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor:pointer;
      transition: all 0.18s;
      border-radius: 10px;
      font-size: 18px;
      user-select: none;
    }
    .hud-icon-btn:hover{
      background: var(--bg-hover);
      border-color: var(--accent-gold);
      transform: translateY(-1px);
    }

    .hud-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
    }

    .hud-stat-label {
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 1px;
    }

    .hud-stat-value {
      color: var(--accent-gold);
      font-weight: 600;
      font-size: 16px;
    }

    .hud-stat-value.chips { color: var(--accent-green); }
    .hud-stat-value.debt { color: var(--accent-red); }
    .hud-stat-value.tokens { color: var(--accent-purple); }
    .hud-stat-value.karma { color: var(--accent-blue); }

    .hud-btn {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      padding: 8px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .hud-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .hud-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .hud-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .hud-btn.danger:hover:not(:disabled) { background: rgba(232, 69, 69, 0.2); }

    .hud-btn.success { border-color: var(--accent-green); color: var(--accent-green); }
    .hud-btn.success:hover:not(:disabled) { background: rgba(61, 214, 140, 0.2); }

    /* Main App Container */
    #app { padding-top: 70px; min-height: 100vh; }
    .hidden { display: none !important; }

    /* Board View */
    #boardView { display: flex; flex-direction: column; align-items: center; padding: 20px; }
    #boardSvg { max-width: 100%; height: auto; }

    .hex-tile { cursor: pointer; transition: all 0.2s; }
    .hex-tile.visited { opacity: 0.5; }

    .hex-tile.current .hex-bg {
      stroke: var(--accent-blue);
      stroke-width: 4;
      filter: drop-shadow(0 0 10px var(--accent-blue));
    }

    .hex-tile.available .hex-bg {
      stroke: var(--accent-gold);
      stroke-width: 3;
      animation: pulse-glow 1.5s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 5px var(--accent-gold-dim)); }
      50% { filter: drop-shadow(0 0 15px var(--accent-gold)); }
    }

    .hex-label {
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      fill: var(--text-primary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      font-weight: 600;
    }
    .hex-sub {
      font-family: 'Fira Code', monospace;
      font-size: 9px;
      fill: var(--text-secondary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .path-line {
      stroke: var(--accent-blue);
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.7;
    }

    /* Modal Overlay */
    #modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 20px;
      backdrop-filter: blur(5px);
    }

    #modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      max-width: 560px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
      font-family: 'Cinzel', serif;
      font-size: 20px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .modal-body { padding: 24px; }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .modal-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .modal-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .modal-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .modal-btn.primary {
      background: var(--accent-gold);
      color: var(--bg-primary);
      border-color: var(--accent-gold);
    }
    .modal-btn.primary:hover:not(:disabled) { background: #ffda70; }

    .modal-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .modal-btn.danger:hover:not(:disabled) { background: rgba(232,69,69,0.18); }

    .modal-text {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 16px;
    }

    .modal-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      outline: none;
    }

    .modal-input:focus {
      border-color: var(--accent-gold);
      box-shadow: 0 0 0 2px rgba(234, 179, 8, 0.25);
    }

    .modal-reward {
      font-family: 'Fira Code', monospace;
      font-size: 24px;
      color: var(--accent-green);
      text-align: center;
      padding: 20px;
      background: rgba(61, 214, 140, 0.1);
      border-radius: 10px;
      margin-bottom: 16px;
      border: 1px solid rgba(61,214,140,0.2);
    }

    /* Merchant Styles */
    .merchant-section { margin-bottom: 18px; }
    .merchant-section-title {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }
    .merchant-cards { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

    .merchant-card-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      min-width: 110px;
    }

    .merchant-card-slot .playing-card { font-size: 18px; }

    .rarity-pip {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .rarity-common { background: #94a3b8; }
    .rarity-uncommon { background: #22c55e; }
    .rarity-rare { background: #f59e0b; }

    /* Blackjack View */
    #blackjackView {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .bj-header { text-align: center; font-family: 'Cinzel', serif; }
    .bj-title {
      font-size: 24px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 8px;
    }
    .bj-status {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .bj-board { display: flex; flex-direction: column; gap: 34px; }
    .bj-side { display: flex; flex-direction: column; gap: 12px; }
    .bj-side-label {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-positions {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }

    @media (max-width: 768px) {
      .bj-positions { grid-template-columns: repeat(5, 1fr); gap: 6px; }
    }

    .bj-position {
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 14px;
      padding: 12px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-height: 160px;
      transition: all 0.2s;
    }

    .bj-position.closed { opacity: 0.4; background: var(--bg-secondary); }
    .bj-position.open { border-color: var(--accent-blue); }
    .bj-position.bust { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }
    .bj-position.stand { border-color: var(--accent-green); }
    .bj-position.winner { border-color: var(--accent-gold); box-shadow: 0 0 20px rgba(240, 192, 64, 0.22); }

    .bj-position-num { font-family: 'Fira Code', monospace; font-size: 10px; color: var(--text-muted); }

    .bj-cards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 4px;
      min-height: 50px;
    }

    .bj-total {
      font-family: 'Fira Code', monospace;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .bj-total.bust { color: var(--accent-red); }

    .bj-state {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 800;
    }

    .bj-state.open { background: var(--accent-blue); color: white; }
    .bj-state.stand { background: var(--accent-green); color: white; }
    .bj-state.bust { background: var(--accent-red); color: white; }
    .bj-state.closed { background: var(--text-muted); color: var(--bg-primary); }

    /* Playing Cards */
    .playing-card {
      width: 36px;
      height: 50px;
      background: white;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-family: 'Fira Code', monospace;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid #ddd;
    }

    .playing-card.large {
      width: 86px;
      height: 120px;
      font-size: 20px;
      border-radius: 14px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
    }

    .playing-card.red { color: var(--card-red); }
    .playing-card.black { color: var(--card-black); }

    /* Modifier cards: shaded blue (per spec) */
    .playing-card.mod {
      background: rgba(77, 166, 255, 0.18);
      border-color: rgba(77, 166, 255, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-blue {
      background: rgba(77, 166, 255, 0.18);
      border-color: rgba(77, 166, 255, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-crystal {
      box-shadow: 0 2px 6px rgba(148, 163, 184, 0.8);
      background: linear-gradient(135deg, rgba(226,232,240,0.7), rgba(255,255,255,0.9));
    }

    .playing-card.sleeve-steel {
      border-color: rgba(148, 163, 184, 0.9);
      box-shadow: 0 2px 6px rgba(100, 116, 139, 0.6);
    }

    .playing-card.sleeve-gold {
      border-color: rgba(234, 179, 8, 0.9);
      box-shadow: 0 2px 6px rgba(234, 179, 8, 0.6);
      background: linear-gradient(135deg, rgba(254, 243, 199, 0.9), rgba(255,255,255,0.9));
    }

    .playing-card.fused {
      background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(77,166,255,0.22));
      border-color: rgba(168,85,247,0.65);
      color: #1f2937;
      font-size: 11px;
    }

    .stamp-icon {
      position: absolute;
      top: -6px;
      right: -6px;
      background: var(--accent-gold);
      color: #1b1f2a;
      font-size: 9px;
      font-weight: 800;
      border-radius: 999px;
      padding: 2px 5px;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      pointer-events: none;
    }

    .card-tooltip {
      position: fixed;
      z-index: 9999;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-primary);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      max-width: 220px;
      pointer-events: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .card-tooltip.hidden { display: none; }
    .card-tooltip .tooltip-title { font-weight: 800; margin-bottom: 4px; }
    .card-tooltip .tooltip-line { color: var(--text-secondary); line-height: 1.35; }

    /* Bench styling (subtle blue “bench” tint) */
    .playing-card.bench {
      background: rgba(77, 166, 255, 0.10);
      border-color: rgba(77, 166, 255, 0.55);
    }

    .playing-card.face-down {
      background: linear-gradient(135deg, #1a237e 0%, #0d47a1 50%, #1a237e 100%);
      color: transparent;
    }
    .playing-card.face-down::after {
      content: '?';
      color: rgba(255,255,255,0.3);
      font-size: 20px;
    }

    /* Blackjack Controls */
    .bj-controls {
      display: flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-turn-info {
      font-family: 'Cinzel', serif;
      font-size: 16px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-drawn-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: rgba(77, 166, 255, 0.1);
      border: 1px solid var(--accent-blue);
      border-radius: 12px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 560px;
    }

    .bj-drawn-label { font-size: 14px; color: var(--text-secondary); }

    .bj-action-btns {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .bj-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 12px;
    }

    .bj-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .bj-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .bj-btn.place {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 11px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.stand-pos {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: white;
      font-size: 11px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.apply-mod {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 11px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.place-bench {
      background: rgba(77, 166, 255, 0.2);
      border-color: var(--accent-blue);
      color: white;
      font-size: 11px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    /* Action bar */
    .action-bar {
      width: 100%;
      max-width: 560px;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 14px;
      background: rgba(26, 36, 54, 0.55);
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .action-bar-title {
      width: 100%;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .action-tokens {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .token-icon {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--accent-gold);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
      font-family: 'Fira Code', monospace;
      font-weight: 800;
    }

    .token-icon:hover { border-color: var(--accent-gold); transform: translateY(-1px); }
    .token-icon.spent { opacity: 0.25; cursor: not-allowed; transform: none; }
    .token-icon.disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

    .action-hint {
      color: var(--text-secondary);
      font-size: 12px;
      text-align: center;
      line-height: 1.4;
    }

    /* ACTIONS BOX (owned cocktails surfaced on-board) */
    .action-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding-top: 6px;
    }

    .action-chip {
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .action-chip.ready:hover { border-color: var(--accent-gold); transform: translateY(-1px); }
    .action-chip.locked { opacity: 0.45; cursor: not-allowed; transform: none; }
    .action-chip.used { opacity: 0.3; cursor: not-allowed; text-decoration: line-through; }

    .action-chip .pill {
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--accent-gold);
      opacity: 0.9;
    }

    /* Bench block next to Actions */
    .controls-row {
      width: 100%;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: stretch;
    }

    .bench-bar {
      max-width: 380px;
      min-width: 260px;
      flex: 1;
    }

    .bench-cards {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding-top: 6px;
    }

    .bench-card-btn {
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      border-radius: 10px;
    }

    .bench-card-btn:disabled { cursor: not-allowed; opacity: 0.5; }

    /* Karma sequence */
    .karma-seq {
      width: 100%;
      max-width: 560px;
      margin: 12px auto 0;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      background: rgba(26, 36, 54, 0.55);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .karma-seq-title {
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--text-muted);
      text-align: center;
    }

    .karma-seq-total {
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: var(--accent-gold);
      text-align: center;
      font-weight: 800;
    }

    .karma-seq-steps {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }

    .karma-step {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-secondary);
    }

    .karma-step.active {
      color: var(--text-primary);
      border: 1px solid rgba(234, 179, 8, 0.5);
      box-shadow: 0 0 12px rgba(234, 179, 8, 0.25);
    }

    .karma-step.completed {
      color: var(--text-primary);
      opacity: 0.85;
    }

    .karma-step .karma-amount {
      font-family: 'Fira Code', monospace;
      font-weight: 800;
      color: var(--accent-gold);
    }

    .karma-pulse {
      animation: karmaPulse 0.6s ease-in-out;
      box-shadow: 0 0 18px rgba(234, 179, 8, 0.35);
    }

    @keyframes karmaPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.03); }
      100% { transform: scale(1); }
    }

    .bench-armed-ring {
      outline: 2px solid rgba(77, 166, 255, 0.85);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* Action picker list */
    .action-list { display: flex; flex-direction: column; gap: 10px; }
    .action-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
    }
    .action-row.disabled { opacity: 0.45; }
    .action-row-title {
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 14px;
      margin-bottom: 4px;
    }
    .action-row-desc { color: var(--text-secondary); font-size: 12px; line-height: 1.4; }
    .action-row-left { flex: 1; }
    .action-row-right { display: flex; flex-direction: column; gap: 8px; }

    /* Match Result */
    .bj-result {
      text-align: center;
      padding: 24px;
      background: var(--bg-card);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-result-title {
      font-family: 'Cinzel', serif;
      font-size: 28px;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .bj-result-title.win { color: var(--accent-green); }
    .bj-result-title.lose { color: var(--accent-red); }
    .bj-result-title.tie { color: var(--accent-gold); }

    .bj-result-score {
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      line-height: 1.5;
    }

    .bj-result-chips {
      font-family: 'Fira Code', monospace;
      font-size: 22px;
      margin-bottom: 20px;
    }

    .bj-result-chips.positive { color: var(--accent-green); }
    .bj-result-chips.negative { color: var(--accent-red); }
    .bj-result-chips.neutral { color: var(--text-muted); }

    /* Game Over / Victory Screens */
    .end-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 70px);
      padding: 40px 20px;
      text-align: center;
    }

    .end-title {
      font-family: 'Cinzel', serif;
      font-size: 48px;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 4px;
    }

    .end-title.victory {
      color: var(--accent-gold);
      text-shadow: 0 0 40px rgba(240, 192, 64, 0.5);
    }

    .end-title.gameover {
      color: var(--accent-red);
      text-shadow: 0 0 40px rgba(232, 69, 69, 0.5);
    }

    .end-message {
      font-size: 18px;
      color: var(--text-secondary);
      margin-bottom: 30px;
      max-width: 520px;
      line-height: 1.6;
    }

    .run-end-card {
      width: min(920px, 95vw);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      background: rgba(26, 36, 54, 0.7);
      padding: 18px;
      text-align: left;
      margin-bottom: 24px;
    }

    .run-end-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .run-end-title {
      font-family: 'Cinzel', serif;
      font-size: 18px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--accent-gold);
    }

    .run-end-sub {
      color: var(--text-muted);
      font-size: 12px;
    }

    .run-end-lore {
      font-weight: 700;
      margin-bottom: 6px;
      color: var(--text-primary);
      font-size: 15px;
    }

    .run-end-meta {
      display: grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: 10px;
      margin: 10px 0;
    }

    .run-end-meta > div {
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 10px;
      font-size: 12px;
      line-height: 1.5;
      color: var(--text-secondary);
    }

    .run-end-meta b { color: var(--text-primary); }
    .run-end-tiny { font-size: 12px; color: var(--text-secondary); }
    .run-end-muted { color: var(--text-muted); }

    #chartEndSummary {
      width: 100%;
      height: 240px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.35);
      display: block;
    }

    @media (max-width: 760px) {
      .run-end-meta { grid-template-columns: 1fr; }
    }

    .end-stats { display: flex; gap: 26px; margin-bottom: 30px; flex-wrap: wrap; justify-content: center; }
    .end-stat { text-align: center; min-width: 120px; }

    .end-stat-value {
      font-family: 'Fira Code', monospace;
      font-size: 28px;
      color: var(--accent-gold);
      font-weight: 800;
    }

    .end-stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* Toast */
    #toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 300;
      animation: toast-in 0.3s ease-out;
      box-shadow: 0 18px 50px rgba(0,0,0,0.5);
      max-width: min(640px, 92vw);
      text-align: center;
    }

    @keyframes toast-in {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Confirm Dialog */
    .confirm-dialog {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 300;
      padding: 20px;
      backdrop-filter: blur(5px);
    }

    .confirm-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 24px;
      max-width: 420px;
      width: 100%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .confirm-message { color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6; }
    .confirm-btns { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    /* Removal / selection picker */
    .removal-picker { display: flex; flex-direction: column; gap: 16px; }
    .removal-cards { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    .removal-card-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 72px;
    }

    .removal-card-option:hover { border-color: var(--accent-red); }
    .removal-card-option.selected { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }

    /* Board instructions */
    .board-instructions {
      text-align: center;
      padding: 16px;
      color: var(--text-secondary);
      font-size: 14px;
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 20px;
      max-width: 520px;
      border: 1px solid var(--border-color);
    }

    /* =============================================
       LOG PANEL (slide-in)
       ============================================= */
    #logPanel{
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: min(420px, 92vw);
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      z-index: 150; /* below modal overlay */
      transform: translateX(110%);
      transition: transform 0.24s ease;
      display: flex;
      flex-direction: column;
      box-shadow: -20px 0 60px rgba(0,0,0,0.45);
    }
    #logPanel.open{ transform: translateX(0); }

    .log-panel-header{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(26,36,54,0.55), rgba(18,26,42,0.15));
    }
    .log-panel-title{
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 14px;
      line-height: 1.2;
    }
    .log-panel-sub{
      margin-top: 2px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }
    .log-panel-actions{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .log-mini-btn{
      font-family: 'Cinzel', serif;
      font-size: 11px;
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      user-select:none;
    }
    .log-mini-btn:hover{ background: var(--bg-hover); border-color: var(--accent-gold); }
    .log-mini-btn.danger{ border-color: var(--accent-red); color: var(--accent-red); }
    .log-mini-btn.danger:hover{ background: rgba(232,69,69,0.18); }

    .log-tabs{
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      gap: 8px;
    }
    .log-tab{
      flex: 1;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor:pointer;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      font-family: 'Cinzel', serif;
    }
    .log-tab:hover{ background: var(--bg-hover); border-color: var(--accent-gold); color: var(--text-primary); }
    .log-tab.active{
      border-color: var(--accent-gold);
      color: var(--text-primary);
      box-shadow: 0 0 18px rgba(240,192,64,0.15);
    }

    .log-panel-body{
      padding: 14px 16px;
      overflow-y: auto;
      flex: 1;
    }
    .log-card{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .log-card-head{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 8px;
      align-items: baseline;
    }
    .log-type{
      color: var(--accent-blue);
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .log-card-body{
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.45;
      word-break: break-word;
    }
    .log-kv{
      margin-top: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      background: rgba(10,14,23,0.35);
      border: 1px solid rgba(42,58,84,0.85);
      border-radius: 12px;
      padding: 10px;
      white-space: pre-wrap;
    }
    .stats-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .log-section-title{
      margin: 18px 0 8px;
      font-weight: 800;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 12px;
    }
    .log-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      overflow: hidden;
    }
    .log-table th,
    .log-table td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      text-align: left;
    }
    .log-table th{
      color: var(--text-secondary);
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 0.8px;
      background: rgba(18, 26, 42, 0.6);
    }
    .log-table tr:last-child td{ border-bottom: none; }
    .stat-box{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
    }
    .stat-label{
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .stat-value{
      font-family: 'Fira Code', monospace;
      font-size: 18px;
      color: var(--text-primary);
      font-weight: 800;
    }
    .stat-value.good{ color: var(--accent-green); }
    .stat-value.bad{ color: var(--accent-red); }
    .stat-value.gold{ color: var(--accent-gold); }
  </style>
</head>

<body>
  <header id="hud"></header>

  <main id="app">
    <section id="boardView"></section>
    <section id="blackjackView" class="hidden"></section>
    <section id="endScreen" class="hidden"></section>
  </main>

  <div id="modalOverlay" class="hidden">
    <div id="modal"></div>
  </div>

  <div id="toast" class="hidden"></div>
  <div id="cardTooltip" class="card-tooltip hidden"></div>

  <!-- Log Panel -->
  <aside id="logPanel" aria-label="Run Log"></aside>

  <script>
    // =============================================
    // CONSTANTS
    // =============================================
    const STARTING_CHIPS = 500;
    const REST_REWARD = 50;
    const BARTENDER_REWARD = 50;
    const MINIGAME_REWARD = 50;

    const MERCHANT_BUY_BASE_STANDARD = 50;
    const MERCHANT_BUY_BASE_MOD = 100;
    const MERCHANT_BUY_INCREMENT = 25;
    const MERCHANT_REMOVE_COST = 50;
    const REMOVAL_REROLL_COST = 25;      // also used as inventory reroll cost
    const MERCHANT_INVENTORY_REROLL_COST = 25;
    const COLLECTOR_ITEM_COST = 150;

// Economy tuning
const MERCHANT_REMOVE_INCREMENT = 25; // removal cost increases by this amount each time you start a paid removal
const MOD_PURCHASE_LIMIT_PER_DELTA = 2; // only this many of each modifier (-4..+4) can be purchased per run
const BENCH_BASE_CAPACITY = 2; // bench slots at start of run
const BENCH_CAPACITY_BONUS_PER_BOSS_WIN = 1; // +1 bench slot after each boss victory
const HOUSE_RAKE_RATES = { 1: 0.10, 2: 0.20, 3: 0.30 }; // applied to positive (payout + transfer) only
const CALLING_PROC_CHANCE = 0.50;
const DIAMOND_BONUS_CHIPS = 10;
const CALLING_RANK_THRESHOLDS = [
  { rank: '2', karma: 0 },
  { rank: '3', karma: 200 },
  { rank: '4', karma: 500 },
  { rank: '5', karma: 900 },
  { rank: '6', karma: 1400 },
  { rank: '7', karma: 2000 },
  { rank: '8', karma: 2700 },
  { rank: '9', karma: 3500 },
  { rank: '10', karma: 4400 },
  { rank: 'J', karma: 5400 },
  { rank: 'Q', karma: 6500 },
  { rank: 'K', karma: 7700 },
  { rank: 'A', karma: 9000 }
];


    const LOAN_AMOUNT = 500;
    const LOAN_REPAY = 750;

    const BUYIN_STANDARD = 100;
    const BUYIN_HIGH = 200;
    const BUYIN_BOSS = 300;

    // Action tokens + cocktails
    const COCKTAIL_COST = 150;
    const ACTION_TOKEN_MAX_BANKED = 3;

    // Rewards / mechanics
    const BLACKJACK_21_REWARD = 21;
    const ALL_FIVE_21_BONUS = 210;

    // Modifiers (merchant + deck)
    const MODIFIER_DELTAS = [-4,-3,-2,-1, +1,+2,+3,+4];
    const MOD_OFFER_CHANCE = 0.22;

    const FLOOR_COUNTS = {
      1: { standard: 11, high: 2 },
      2: { standard: 7, high: 6 },
      3: { standard: 3, high: 10 }
    };

    const NODES = [
      [0, 200, 50, []],
      [1, 140, 95, [0]], [2, 260, 95, [0]],
      [3, 80, 140, [1]], [4, 200, 140, [0, 1, 2]], [5, 320, 140, [2]],
      [6, 140, 185, [1, 3, 4]], [7, 260, 185, [2, 4, 5]],
      [8, 80, 230, [3, 6]], [9, 200, 230, [4, 6, 7]], [10, 320, 230, [5, 7]],
      [11, 140, 275, [6, 8, 9]], [12, 260, 275, [7, 9, 10]],
      [13, 80, 320, [8, 11]], [14, 200, 320, [9, 11, 12]], [15, 320, 320, [10, 12]],
      [16, 140, 365, [11, 13, 14]], [17, 260, 365, [12, 14, 15]],
      [18, 80, 410, [13, 16]], [19, 200, 410, [14, 16, 17]], [20, 320, 410, [15, 17]]
    ];

    const HEX_SIZE = 30;
    const SUITS = ['♠', '♥', '♦', '♣'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    const TILE_COLORS = {
      'BOSS': '#FFD700',
      'STANDARD': '#4a6fa5',
      'HIGH_STAKES': '#9b59b6',
      'MERCHANT': '#27ae60',
      'MODIFY': '#16a085',
      'COLLECTOR': '#f39c12',
      'LOAN_SHARK': '#e67e22',
      'REST_STOP': '#3498db',
      'BARTENDER': '#e74c3c',
      'MINIGAME': '#1abc9c'
    };

    const TILE_LABELS = {
      'BOSS': 'BOSS',
      'STANDARD': 'STD',
      'HIGH_STAKES': 'HIGH',
      'MERCHANT': 'MER',
      'MODIFY': 'MOD',
      'COLLECTOR': 'COL',
      'LOAN_SHARK': 'LOAN',
      'REST_STOP': 'REST',
      'BARTENDER': 'BAR',
      'MINIGAME': 'MINI'
    };

    // =============================================
    // COCKTAIL ACTION REGISTRY
    // =============================================
    const ACTIONS = {
      splitDecision: {
        name: "Split Decision",
        desc: "Draw 2 playable cards. Choose 1 to play; the other is immediately played by the Dealer.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSplitDecision()
      },
      secondOpinion: {
        name: "Second Opinion",
        desc: "Draw 2 playable cards. Choose 1 to play; discard the other.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSecondOpinion()
      },
      benched: {
        name: "Benched",
        desc: "Draw a playable card and send it to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateBenched()
      },
      spyGlass: {
        name: "Spy Glass",
        desc: "Reveal the current total of a Dealer open lane for the rest of the match.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateSpyGlass()
      },
      forcedPlay: {
        name: "Forced Play",
        desc: "Choose a Dealer open lane. The Dealer's next placed card must go there (if still valid).",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateForcedPlay()
      },
      revival: {
        name: "Revival",
        desc: "Reopen any of your closed lanes (stood or busted).",
        isUsable: (m) => isPlayerActionContextOK(m) && getEligibleRevivalLanes(m).length > 0,
        activate: () => activateRevival()
      },
      findMyCard: {
        name: "Find My Card",
        desc: "Search the top 10 of your draw pile for a modifier; move the first found to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateFindMyCard()
      },
      closer: {
        name: "Closer",
        desc: "Choose a Dealer open lane and close it immediately.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateCloser()
      }
    };

    // =============================================
    // GAME STATE
    // =============================================
    let run = null;
    let blackjackMatch = null;

    // Merchant state
    let merchantOffers = [];
    let removalMode = false;
    let removalCandidates = [];
    let selectedRemovalIdx = null;
    let removalPaidCost = 0;

    // Dealer timers (bug-proof reset)
    let dealerTimerA = null;
    let dealerTimerB = null;
    let karmaSeqTimer = null;
    function clearDealerTimers() {
      if (dealerTimerA) clearTimeout(dealerTimerA);
      if (dealerTimerB) clearTimeout(dealerTimerB);
      if (karmaSeqTimer) clearTimeout(karmaSeqTimer);
      dealerTimerA = null;
      dealerTimerB = null;
      karmaSeqTimer = null;
    }

    // =============================================
    // UI SETTINGS + LOGGING (Option B)
    // =============================================
    const LOG_STORAGE_KEY = 'p63_runlog_latest';
    let uiSettings = {
      autoOpenLogOnEnd: true,

      // if false, dealer totals + hole cards reveal only at match resolution (unless Spy Glass)
      revealTotalsOnClose: false,

      // NEW: opponent AI difficulty
      opponentDifficulty: 'hard', // 'easy' | 'medium' | 'hard'

      // (kept) house rake mode (this used to be uiSettings.difficulty)
      rakeMode: 'hard', // 'easy' (none) | 'medium' (10% flat) | 'hard' (10/20/30)

      // hard cap for bench capacity (0 = no cap)
      benchHardCap: 3 // 2 or 3 (or 0 for “no cap”)
    };

    // Back-compat: if you had older saves/edits that set uiSettings.difficulty
    if (uiSettings.difficulty && !uiSettings.opponentDifficulty) uiSettings.opponentDifficulty = uiSettings.difficulty;
    if (uiSettings.difficulty && !uiSettings.rakeMode) uiSettings.rakeMode = uiSettings.difficulty;


    let gameLog = null;
    let logPanelOpen = false;
    let logPanelTab = 'stats'; // 'events' | 'stats'

    let persistTimer = null;
    function persistLogSoon() {
      if (!gameLog) return;
      if (persistTimer) return;
      persistTimer = setTimeout(() => {
        persistTimer = null;
        try { localStorage.setItem(LOG_STORAGE_KEY, JSON.stringify(gameLog)); } catch (e) {}
      }, 120);
    }

    function generateSessionId() {
      return 'S' + Math.random().toString(16).slice(2, 8).toUpperCase() + '-' + Date.now().toString(16).toUpperCase().slice(-6);
    }

    function getSettingsSnapshot() {
      return {
        revealTotalsOnClose: (uiSettings && uiSettings.revealTotalsOnClose) !== false,
        opponentDifficulty: (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard',
        rakeMode: (uiSettings && uiSettings.rakeMode) || 'hard',
        benchHardCap: safeNumber(uiSettings && uiSettings.benchHardCap, 3),
        autoOpenLogOnEnd: !!(uiSettings && uiSettings.autoOpenLogOnEnd),
        rulesContext: {
          benchBaseCapacity: BENCH_BASE_CAPACITY,
          benchBonusPerBossWin: BENCH_CAPACITY_BONUS_PER_BOSS_WIN,
          modifierPurchaseLimitPerDelta: MOD_PURCHASE_LIMIT_PER_DELTA,
          startingChips: STARTING_CHIPS,
          buyins: {
            standard: BUYIN_STANDARD,
            highStakes: BUYIN_HIGH,
            boss: BUYIN_BOSS
          },
          blackjack21Reward: BLACKJACK_21_REWARD,
          allFive21Bonus: ALL_FIVE_21_BONUS
        }
      };
    }

    function buildDeckSummary() {
      const deck = run ? (run.playerDeck || []) : [];
      const bySuit = { '♠': 0, '♥': 0, '♦': 0, '♣': 0 };
      const byRank = Object.fromEntries(RANKS.map(r => [r, 0]));
      let modCount = 0;
      let fusedCount = 0;
      let sleevedCount = 0;

      for (const c of deck) {
        if (isModifier(c)) {
          modCount += 1;
          continue;
        }
        if (isFused(c)) {
          fusedCount += 1;
          continue;
        }
        if (isStandardCard(c)) {
          if (bySuit[c.suit] !== undefined) bySuit[c.suit] += 1;
          if (byRank[c.rank] !== undefined) byRank[c.rank] += 1;
          if (c.sleeveId) sleevedCount += 1;
        }
      }

      return {
        deckSize: deck.length,
        modCount,
        fusedCount,
        sleevedCount,
        stampsByRank: { ...(run && run.stampsByRank ? run.stampsByRank : {}) },
        bySuit,
        byRank
      };
    }

    function serializeCard(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isFused(card)) {
        return {
          uid: card.uid || null,
          kind: 'FUSE',
          a: serializeCard(card.a),
          b: serializeCard(card.b)
        };
      }
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function serializeDeck() {
      const deck = run ? (run.playerDeck || []) : [];
      return {
        cards: deck.map(serializeCard),
        stampsByRank: { ...(run && run.stampsByRank ? run.stampsByRank : {}) }
      };
    }

    function deckSnapshot() {
      const summary = buildDeckSummary();
      return {
        deckId: gameLog ? gameLog.currentDeckId : null,
        deckSize: summary.deckSize,
        modCount: summary.modCount,
        fusedCount: summary.fusedCount,
        sleevedCount: summary.sleevedCount,
        stampsByRank: summary.stampsByRank,
        bySuit: summary.bySuit,
        byRank: summary.byRank
      };
    }

    function recordDeckSnapshot(reason, extraData = {}) {
      if (!gameLog || !run) return null;
      const nextId = safeNumber(gameLog.currentDeckId, 0) + 1;
      gameLog.currentDeckId = nextId;
      const entry = {
        deckId: nextId,
        ts: new Date().toISOString(),
        reason,
        ctx: getEventCtx(),
        deck: serializeDeck(),
        summary: buildDeckSummary(),
        ...extraData
      };
      gameLog.deckHistory.push(entry);
      if (gameLog.stats) gameLog.stats.deckSnapshots = safeNumber(gameLog.stats.deckSnapshots, 0) + 1;
      persistLogSoon();
      return nextId;
    }

    function resetLog() {
      const snap = deckSnapshot();
      const chipsNow = run ? safeNumber(run.chips, 0) : 0;
      const sessionId = generateSessionId();
      const rulesContext = {
        collector: {
          itemCost: COLLECTOR_ITEM_COST,
          rarityRates: { common: 0.70, uncommon: 0.25, rare: 0.05 }
        },
        modify: {
          services: Object.values(MODIFY_SERVICES).map(s => ({ id: s.id, tier: s.tier, kind: s.kind })),
          pricing: { coreBase: 100, coreInc: 25, premiumBase: 200, premiumInc: 50 }
        },
        stamps: Object.values(STAMP_DEFS).map(s => ({ id: s.id, rarity: s.rarity })),
        sleeves: Object.values(SLEEVE_DEFS).map(s => ({ id: s.id, rarity: s.rarity }))
      };

      gameLog = {
        logVersion: "C",
        sessionId,
        runId: sessionId,
        startedAt: new Date().toISOString(),
        endedAt: null,
        exportedAt: null,
        app: {
          name: "Project 63",
          build: "0.18",
          variant: "p63_0.18.html",
          userAgent: navigator.userAgent
        },
        settingsAtStart: getSettingsSnapshot(),
        settingsLatest: getSettingsSnapshot(),
        rulesContext,
        initialState: null,
        finalState: null,
        runOutcome: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        deckHistory: [],
        currentDeckId: null,
        events: [],
        stats: {
          floorsReached: 1,
          tilesEntered: 0,
          tilesByType: {},
          matches: 0,
          wins: 0,
          losses: 0,
          ties: 0,
          buyinSpent: 0,
          payoutReceived: 0,
          transferNet: 0,
          bonusChips: 0,
          merchantBuys: 0,
          merchantRemoves: 0,
          merchantRerolls: 0,
          cocktailsBought: 0,
          loansTaken: 0,
          loansRepaid: 0,
          tokensGained: 0,
          tokensSpent: 0,
          actionsUsed: 0,
          collectorOffersShown: 0,
          collectorPurchases: 0,
          modifyCandidateSetsShown: 0,
          modifyApplies: 0,
          deckSnapshots: 0,
          feedbackUpdates: 0,

          chipsPeak: chipsNow,
          chipsLow: chipsNow,

          deckSizeMin: snap.deckSize,
          deckSizeMax: snap.deckSize,
          modCountMin: snap.modCount,
          modCountMax: snap.modCount,

          matchDurationMsTotal: 0,
          rakePaidTotal: 0,
          bossClears: 0
        }
      };
      persistLogSoon();
    }

    function updateLogStats(evt) {
      if (!gameLog || !gameLog.stats) return;
      const s = gameLog.stats;

      if (evt && typeof evt.chips === 'number') {
        s.chipsPeak = Math.max(s.chipsPeak, evt.chips);
        s.chipsLow = Math.min(s.chipsLow, evt.chips);
      }

      if (evt && evt.data && evt.data.deckSnapshot) {
        const ds = evt.data.deckSnapshot;
        if (typeof ds.deckSize === 'number') {
          s.deckSizeMin = Math.min(s.deckSizeMin, ds.deckSize);
          s.deckSizeMax = Math.max(s.deckSizeMax, ds.deckSize);
        }
        if (typeof ds.modCount === 'number') {
          s.modCountMin = Math.min(s.modCountMin, ds.modCount);
          s.modCountMax = Math.max(s.modCountMax, ds.modCount);
        }
      }

      switch (evt.type) {
        case 'FLOOR_START':
          s.floorsReached = Math.max(s.floorsReached, evt.floor || 1);
          break;
        case 'TILE_ENTER':
          s.tilesEntered += 1;
          s.tilesByType[evt.data.tileType] = (s.tilesByType[evt.data.tileType] || 0) + 1;
          break;
        case 'MATCH_START':
          s.matches += 1;
          s.buyinSpent += safeNumber(evt.data.buyIn, 0);
          break;
        case 'MATCH_END':
          if (evt.data.outcome === 'WIN') s.wins += 1;
          else if (evt.data.outcome === 'LOSS') s.losses += 1;
          else s.ties += 1;
          s.payoutReceived += safeNumber(evt.data.payout, 0);
          s.transferNet += safeNumber(evt.data.transferNet, 0);
          s.bonusChips += safeNumber(evt.data.bonusChips, 0);
          s.rakePaidTotal += safeNumber(evt.data.rake, 0);
          s.matchDurationMsTotal += safeNumber(evt.data.durationMs, 0);
          break;
        case 'BOSS_CLEARED':
          s.bossClears += 1;
          break;
        case 'TOKEN_GAIN':
          s.tokensGained += safeNumber(evt.data.amount, 0);
          break;
        case 'TOKEN_SPENT':
          s.tokensSpent += safeNumber(evt.data.amount, 0);
          break;
        case 'ACTION_USED':
          s.actionsUsed += 1;
          break;
        case 'MERCHANT_BUY':
          s.merchantBuys += 1;
          break;
        case 'MERCHANT_REMOVE_CONFIRM':
          s.merchantRemoves += 1;
          break;
        case 'MERCHANT_REROLL':
          s.merchantRerolls += 1;
          break;
        case 'COCKTAIL_BOUGHT':
          s.cocktailsBought += 1;
          break;
        case 'LOAN_TAKEN':
          s.loansTaken += 1;
          break;
        case 'LOAN_REPAID':
          s.loansRepaid += 1;
          break;
        case 'COLLECTOR_SHOP_GENERATED':
          s.collectorOffersShown += 1;
          break;
        case 'COLLECTOR_BUY':
          s.collectorPurchases += 1;
          break;
        case 'MODIFY_CANDIDATES_SHOWN':
          s.modifyCandidateSetsShown += 1;
          break;
        case 'MODIFY_APPLY':
          s.modifyApplies += 1;
          break;
        case 'FEEDBACK_UPDATED':
          s.feedbackUpdates += 1;
          break;
        case 'DECK_SNAPSHOT':
          s.deckSnapshots += 1;
          break;
      }
    }

    function getEventCtx() {
      const currentTile = run && run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      return {
        floor: run ? run.floor : null,
        chips: run ? safeNumber(run.chips, null) : null,
        karma: run ? safeNumber(run.karma, null) : null,
        callingCard: run && run.callingCard ? { ...run.callingCard } : null,
        callingRankValue: run && run.callingCard ? rankToValue(run.callingCard.rank) : null,
        tileId: run && run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        encounterSeq: run && run.activeEncounter ? run.activeEncounter.seq : null,
        encounterType: run && run.activeEncounter ? run.activeEncounter.type : null,
        matchSeq: blackjackMatch ? blackjackMatch.matchSeq : null,
        matchType: blackjackMatch ? blackjackMatch.type : null,
        matchPhase: blackjackMatch ? blackjackMatch.phase : null,
        turn: blackjackMatch ? blackjackMatch.turn : null,
        visibility: {
          revealOnClose: (uiSettings && uiSettings.revealTotalsOnClose) !== false,
          difficulty: getOpponentDifficulty()
        }
      };
    }

    function logEvent(type, data = {}) {
      if (!gameLog) return;
      const evt = {
        id: gameLog.events.length + 1,
        ts: new Date().toISOString(),
        type,
        floor: run ? run.floor : null,
        chips: run ? safeNumber(run.chips, null) : null,
        ctx: getEventCtx(),
        data
      };
      gameLog.events.push(evt);
      updateLogStats(evt);
      persistLogSoon();

      if (logPanelOpen) renderLogPanel();
    }

    function finalizeRunLog(outcomeObj = {}) {
      if (!gameLog || !run) return;
      if (!gameLog.endedAt) gameLog.endedAt = new Date().toISOString();

      const currentTile = run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      const baseOutcome = {
        outcome: outcomeObj.outcome || null,
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        matchSeq: blackjackMatch ? blackjackMatch.matchSeq : null,
        chips: safeNumber(run.chips, 0),
        message: outcomeObj.message || null
      };

      gameLog.runOutcome = { ...baseOutcome };
      gameLog.finalState = {
        chips: safeNumber(run.chips, 0),
        karma: safeNumber(run.karma, 0),
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        callingCard: run.callingCard ? { ...run.callingCard } : null,
        deckSnapshot: deckSnapshot(),
        deckSummary: buildDeckSummary()
      };
      if (run.feedback) gameLog.feedback = { ...run.feedback };
      persistLogSoon();
    }

    function formatTime(tsIso) {
      const d = new Date(tsIso);
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      return `${hh}:${mm}:${ss}`;
    }

    function eventSummary(evt) {
      const t = evt.type;
      const d = evt.data || {};
      if (t === 'GAME_START') return `Run started. Chips=${d.startingChips}, Deck=${d.deckSize}`;
      if (t === 'FLOOR_START') return `Entered Floor ${d.floor}`;
      if (t === 'TILE_ENTER') return `Entered tile #${d.tileId} (${d.tileType})`;
      if (t === 'REST_CHOICE') return `Rest: ${d.choice}${d.freeRemoval ? ' (free removal)' : ''}`;
      if (t === 'MINIGAME') return `Minigame reward +${d.chips} chips, +${d.tokens} token`;
      if (t === 'BARTENDER_TAKE') return `Bartender: took +${d.chips} chips`;
      if (t === 'COCKTAIL_BOUGHT') return `Bought cocktail: ${d.actionName} (-${d.cost})`;
      if (t === 'LOAN_TAKEN') return `Loan taken +${d.amount}, owe ${d.repay}`;
      if (t === 'LOAN_REPAID') return `Loan repaid -${d.amount}`;
      if (t === 'MERCHANT_ENTER') return `Merchant opened`;
      if (t === 'MODIFY_ENTER') return `Modify opened`;
      if (t === 'MODIFY_SERVICE_SELECT') return `Modify service: ${d.serviceId} (-${d.cost})`;
      if (t === 'MODIFY_CANDIDATES_SHOWN') return `Modify candidates shown (${d.countShown || 0})`;
      if (t === 'MODIFY_SELECTION') return `Modify selection: ${d.serviceId}`;
      if (t === 'MODIFY_APPLY') return `Modify applied: ${d.serviceId} (${d.count || 0} cards)`;
      if (t === 'MODIFY_LEAVE') return `Modify closed`;
      if (t === 'COLLECTOR_SHOP_GENERATED') return `Collector shop generated`;
      if (t === 'COLLECTOR_ENTER') return `Collector opened`;
      if (t === 'COLLECTOR_BUY') return `Collector buy: ${d.name} (-${d.cost})`;
      if (t === 'STAMP_OPTIONS_SHOWN') return `Stamp options shown (${d.options ? d.options.join(',') : ''})`;
      if (t === 'SLEEVE_CANDIDATES_SHOWN') return `Sleeve candidates shown`;
      if (t === 'STAMP_APPLY') return `Stamp applied: ${d.stampId} on ${d.rank}`;
      if (t === 'SLEEVE_APPLY') return `Sleeve applied: ${d.sleeveId} on ${d.card}`;
      if (t === 'COLLECTOR_LEAVE') return `Collector closed`;
      if (t === 'MERCHANT_BUY') return `Bought ${d.card} (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_START') return `Removal started (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_CONFIRM') return `Removed ${d.card}`;
      if (t === 'MERCHANT_REROLL') return `Merchant reroll (${d.which}) (-${d.cost})`;
      if (t === 'MODIFIER_SOLD_OUT') return `Modifier sold out: ${d.card} (limit ${d.limit})`;
      if (t === 'MATCH_START') return `Match start: ${d.type}, buy-in ${d.buyIn}, tokens ${d.tokensTotal}`;
      if (t === 'PLAYER_DRAW') return `Player drew ${d.card}`;
      if (t === 'PLAYER_DRAW_BENCH') return `Player drew modifier ${d.card} (benched)`;
      if (t === 'PLAYER_PLACE') return `Player placed ${d.card} to lane #${d.lane}`;
      if (t === 'PLAYER_STAND') return `Player stood lane #${d.lane} (total ${d.total})`;
      if (t === 'BENCH_APPLY') return `Bench applied ${d.card} to ${d.side} lane #${d.lane}`;
      if (t === 'BENCH_PLACE') return `Bench placed ${d.card} to player lane #${d.lane}`;
      if (t === 'BENCH_OVERFLOW') return `Bench overflow: discarded ${d.removed}`;
      if (t === 'TRANSFER_BET') return `Transfer bet: player x${d.playerMultiplier} (${d.dealerAction}${d.offer ? ` to x${d.offer}` : ''})`;
      if (t === 'TRANSFER_BET_RESPONSE') return `Transfer bet response: ${d.response} (x${d.finalMultiplier})`;
      if (t === 'ACTION_USED') return `Action used: ${d.actionName}`;
      if (t === 'BONUS_21') return `Bonus: lane #${d.lane} hit 21 (+${d.amount})`;
      if (t === 'BONUS_ALL_FIVE') return `Bonus: all five hit 21 (+${d.amount})`;
      if (t === 'SETTINGS_CHANGED') return `Settings updated`;
      if (t === 'CALLING_CARD_SET') return `Calling card set: ${d.callingCard ? cardToString(d.callingCard) : '—'}`;
      if (t === 'CALLING_PROC_DIAMOND') return `Calling (♦): +${d.amount} chips`;
      if (t === 'CALLING_PROC_CLUBS') return `Calling (♣): dealer lane #${d.laneIdx} ${d.delta}`;
      if (t === 'CALLING_PROC_SPADES') return `Calling (♠): revealed dealer lane #${d.laneIdx}`;
      if (t === 'CALLING_PROC_HEARTS_TRIAGE') return `Calling (♥): triage lane #${d.laneIdx}`;
      if (t === 'CALLING_CARD_LEVEL_UP') return `Calling card leveled: ${d.fromRank} → ${d.toRank}`;
      if (t === 'NPC_ASSIGNED') return `NPC: ${d.npcName} (${d.tileType})`;
      if (t === 'CRYSTAL_SLEEVE_SAVE') return `Crystal sleeve saved lane #${d.laneIdx}`;
      if (t === 'GOLD_SLEEVE_BONUS') return `Gold sleeve bonus +${d.amount} (lane #${d.laneIdx})`;
      if (t === 'BURN_AFTER_READING') return `Burned ${d.count} stamped card(s)`;
      if (t === 'MERCHANT_ENTER') return `Merchant: ${d.npcName} (prices x${d.priceMult})`;
      if (t === 'WINNER_REWARD_FUSE') return `Fused ${d.cards ? d.cards.join(' + ') : 'cards'}`;
      if (t === 'DECK_EXHAUSTION') return `Deck exhaustion: ${d.side} (${d.reason})`;
      if (t === 'MATCH_END') return `Match end: ${d.outcome} (payout ${d.payout}, transfer ${d.transferNet >= 0 ? '+' : ''}${d.transferNet})`;
      if (t === 'BOSS_CLEARED') return `Boss cleared on floor ${d.floor}`;
      if (t === 'KARMA_GAIN') return `Karma +${d.amount} (total ${d.total})`;
      if (t === 'FEEDBACK_UPDATED') return `Feedback updated`;
      if (t === 'DECK_SNAPSHOT') return `Deck snapshot saved`;
      if (t === 'GAME_END') return `Run ended: ${d.result}`;
      return t;
    }

    function openLogPanel(tab = 'stats') {
      logPanelTab = tab;
      logPanelOpen = true;
      const el = document.getElementById('logPanel');
      el.classList.add('open');
      renderLogPanel();
    }

    function closeLogPanel() {
      logPanelOpen = false;
      const el = document.getElementById('logPanel');
      el.classList.remove('open');
    }

    function switchLogTab(tab) {
      logPanelTab = tab;
      renderLogPanel();
    }

    function exportLog() {
      if (!gameLog) return;
      if (!gameLog.exportedAt) gameLog.exportedAt = new Date().toISOString();
      if (!gameLog.endedAt && run && (run.ui.mode === 'GAMEOVER' || run.ui.mode === 'VICTORY')) {
        const outcome = run.ui.mode === 'VICTORY' ? 'win' : 'loss';
        finalizeRunLog({ outcome, message: run.ui.message || null });
      }
      const payload = JSON.stringify(gameLog, null, 2);
      const blob = new Blob([payload], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `project63_runlog_${gameLog.sessionId}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast('Log exported');
    }

    function clearSavedLog() {
      try { localStorage.removeItem(LOG_STORAGE_KEY); } catch (e) {}
      showToast('Saved log cleared');
    }

    function renderLogEvents() {
      const events = (gameLog && gameLog.events) ? gameLog.events.slice().reverse() : [];
      if (!events.length) return `<div class="log-card"><div class="log-card-body">No events yet.</div></div>`;

      return events.map(evt => {
        const time = formatTime(evt.ts);
        const summary = eventSummary(evt);
        const details = JSON.stringify(evt.data || {}, null, 2);
        return `
          <div class="log-card">
            <div class="log-card-head">
              <div><span class="log-type">${evt.type}</span> <span style="opacity:.85;">· F${evt.floor ?? '-'}</span></div>
              <div>${time}</div>
            </div>
            <div class="log-card-body">${summary}</div>
            ${details && details !== "{}" ? `<div class="log-kv">${details}</div>` : ``}
          </div>
        `;
      }).join('');
    }

    function formatRate(numerator, denominator) {
      if (!denominator) return '—';
      return `${Math.round((numerator / denominator) * 100)}%`;
    }

    function initPerfBucket() {
      return {
        matches: 0,
        lanesPlayed: 0,
        playerTotalSum: 0,
        playerNonBustSum: 0,
        playerNonBustCount: 0,
        playerBustLanes: 0,
        dealerBustLanes: 0,
        player21Lanes: 0,
        dealer21Lanes: 0,
        laneW: 0,
        laneL: 0,
        laneT: 0,
        matchW: 0,
        matchL: 0,
        matchT: 0
      };
    }

    function computeDerivedPerf(events) {
      const perf = {
        overall: initPerfBucket(),
        byFloor: {},
        byType: {},
        recentMatches: []
      };

      (events || []).forEach(evt => {
        if (!evt || evt.type !== 'MATCH_END') return;
        const lanes = evt.data && evt.data.lanes;
        if (!lanes) return;

        const playerTotals = lanes.playerTotals || [];
        const dealerTotals = lanes.dealerTotals || [];
        const playerBusts = lanes.playerBusts || [];
        const dealerBusts = lanes.dealerBusts || [];
        const laneWinners = lanes.laneWinners || [];

        const bucket = perf.overall;
        const floorKey = String(evt.floor || '—');
        const typeKey = evt.data.type || 'UNKNOWN';

        if (!perf.byFloor[floorKey]) perf.byFloor[floorKey] = initPerfBucket();
        if (!perf.byType[typeKey]) perf.byType[typeKey] = initPerfBucket();

        const floorBucket = perf.byFloor[floorKey];
        const typeBucket = perf.byType[typeKey];
        const buckets = [bucket, floorBucket, typeBucket];

        buckets.forEach(b => { b.matches += 1; });
        if (evt.data.outcome === 'WIN') buckets.forEach(b => { b.matchW += 1; });
        else if (evt.data.outcome === 'LOSS') buckets.forEach(b => { b.matchL += 1; });
        else buckets.forEach(b => { b.matchT += 1; });

        let matchPlayerTotalSum = 0;
        let matchPlayerNonBustSum = 0;
        let matchPlayerNonBustCount = 0;
        let matchPlayerBusts = 0;
        let matchPlayer21s = 0;
        let matchLaneW = 0;
        let matchLaneL = 0;
        let matchLaneT = 0;

        for (let i = 0; i < 5; i++) {
          const pTotal = safeNumber(playerTotals[i], 0);
          const dTotal = safeNumber(dealerTotals[i], 0);
          const pBust = !!playerBusts[i];
          const dBust = !!dealerBusts[i];
          const winner = laneWinners[i];

          matchPlayerTotalSum += pTotal;
          if (!pBust) {
            matchPlayerNonBustSum += pTotal;
            matchPlayerNonBustCount += 1;
          } else {
            matchPlayerBusts += 1;
          }
          if (pTotal === 21 && !pBust) matchPlayer21s += 1;

          buckets.forEach(b => {
            b.lanesPlayed += 1;
            b.playerTotalSum += pTotal;
            if (!pBust) {
              b.playerNonBustSum += pTotal;
              b.playerNonBustCount += 1;
            }
            if (pBust) b.playerBustLanes += 1;
            if (dBust) b.dealerBustLanes += 1;
            if (pTotal === 21 && !pBust) b.player21Lanes += 1;
            if (dTotal === 21 && !dBust) b.dealer21Lanes += 1;
          });

          if (winner === 'player') {
            buckets.forEach(b => { b.laneW += 1; });
            matchLaneW += 1;
          } else if (winner === 'dealer') {
            buckets.forEach(b => { b.laneL += 1; });
            matchLaneL += 1;
          } else {
            buckets.forEach(b => { b.laneT += 1; });
            matchLaneT += 1;
          }
        }

        const matchAvgIncl = matchPlayerTotalSum / 5;
        const matchAvgExcl = matchPlayerNonBustCount ? (matchPlayerNonBustSum / matchPlayerNonBustCount) : null;
        perf.recentMatches.push({
          floor: evt.floor,
          type: evt.data.type,
          outcome: evt.data.outcome,
          avgIncl: matchAvgIncl,
          avgExcl: matchAvgExcl,
          playerBusts: matchPlayerBusts,
          player21s: matchPlayer21s,
          laneW: matchLaneW,
          laneL: matchLaneL,
          laneT: matchLaneT
        });
      });

      return perf;
    }

    function renderLogStats() {
      const s = (gameLog && gameLog.stats) ? gameLog.stats : null;
      if (!s) return `<div class="log-card"><div class="log-card-body">No stats yet.</div></div>`;

      const derived = computeDerivedPerf(gameLog.events || []);
      const overall = derived.overall;
      const avgLaneIncl = overall.lanesPlayed ? (overall.playerTotalSum / overall.lanesPlayed) : 0;
      const avgLaneExcl = overall.playerNonBustCount ? (overall.playerNonBustSum / overall.playerNonBustCount) : null;

      const net = safeNumber(run ? run.chips : 0) - STARTING_CHIPS;

      const tileLines = Object.entries(s.tilesByType || {})
        .sort((a,b) => b[1]-a[1])
        .map(([k,v]) => `${k}: ${v}`)
        .join('\n');

      const avgMatchMs = s.matches ? Math.round(s.matchDurationMsTotal / s.matches) : 0;

      const recentMatches = derived.recentMatches.slice(-10).reverse();

      const floorRows = Object.entries(derived.byFloor).map(([floor, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>Floor ${floor}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? '—' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const typeRows = Object.entries(derived.byType).map(([type, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>${type}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? '—' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const recentRows = recentMatches.map(m => `
        <tr>
          <td>F${m.floor}</td>
          <td>${m.type}</td>
          <td>${m.outcome}</td>
          <td>${m.avgIncl.toFixed(1)}</td>
          <td>${m.avgExcl === null ? '—' : m.avgExcl.toFixed(1)}</td>
          <td>${m.playerBusts}</td>
          <td>${m.player21s}</td>
          <td>${m.laneW}/${m.laneL}/${m.laneT}</td>
        </tr>
      `).join('') || `<tr><td colspan="8">No recent matches.</td></tr>`;

      return `
        <div class="log-section-title">Run Overview</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Session</div>
            <div class="stat-value gold" style="font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${gameLog.sessionId}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Floors Reached</div>
            <div class="stat-value">${s.floorsReached}/3</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Chips Peak</div>
            <div class="stat-value good">${s.chipsPeak}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Chips Low</div>
            <div class="stat-value bad">${s.chipsLow}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Net vs Start</div>
            <div class="stat-value ${net >= 0 ? 'good' : 'bad'}">${net >= 0 ? '+' : ''}${net}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Matches</div>
            <div class="stat-value">${s.matches}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">W / L / T</div>
            <div class="stat-value">${s.wins} / ${s.losses} / ${s.ties}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Match Time</div>
            <div class="stat-value">${avgMatchMs}ms</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Buy-ins Spent</div>
            <div class="stat-value">${s.buyinSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Payouts</div>
            <div class="stat-value">${s.payoutReceived}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Transfers Net</div>
            <div class="stat-value ${s.transferNet >= 0 ? 'good' : 'bad'}">${s.transferNet >= 0 ? '+' : ''}${s.transferNet}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Bonus Chips</div>
            <div class="stat-value gold">${s.bonusChips}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Rake Paid</div>
            <div class="stat-value bad">${s.rakePaidTotal}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Tokens Gained / Spent</div>
            <div class="stat-value">${s.tokensGained} / ${s.tokensSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Actions Used</div>
            <div class="stat-value">${s.actionsUsed}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Deck Size Min / Max</div>
            <div class="stat-value">${s.deckSizeMin} / ${s.deckSizeMax}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Mods Min / Max</div>
            <div class="stat-value">${s.modCountMin} / ${s.modCountMax}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Merchant Buys</div>
            <div class="stat-value">${s.merchantBuys}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Removals</div>
            <div class="stat-value">${s.merchantRemoves}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Boss Clears</div>
            <div class="stat-value">${s.bossClears}</div>
          </div>

          <div class="stat-box" style="grid-column: 1 / -1;">
            <div class="stat-label">Tiles Entered</div>
            <div class="stat-value">${s.tilesEntered}</div>
            <div class="log-kv" style="margin-top:10px;">${tileLines || '(none yet)'}</div>
          </div>
        </div>

        <div class="log-section-title">Performance</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Match W/L/T</div>
            <div class="stat-value">${overall.matchW} / ${overall.matchL} / ${overall.matchT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Match Win Rate</div>
            <div class="stat-value">${formatRate(overall.matchW, overall.matches)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane W/L/T</div>
            <div class="stat-value">${overall.laneW} / ${overall.laneL} / ${overall.laneT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane Win Rate</div>
            <div class="stat-value">${formatRate(overall.laneW, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player Bust Rate</div>
            <div class="stat-value">${formatRate(overall.playerBustLanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player 21 Rate</div>
            <div class="stat-value">${formatRate(overall.player21Lanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Incl Bust)</div>
            <div class="stat-value">${avgLaneIncl.toFixed(1)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Excl Bust)</div>
            <div class="stat-value">${avgLaneExcl === null ? '—' : avgLaneExcl.toFixed(1)}</div>
          </div>
        </div>

        <div class="log-section-title">Breakdown by Floor</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${floorRows}
          </tbody>
        </table>

        <div class="log-section-title">Breakdown by Match Type</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Type</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${typeRows}
          </tbody>
        </table>

        <div class="log-section-title">Recent Matches</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Type</th>
              <th>Outcome</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust Lanes</th>
              <th>21 Lanes</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${recentRows}
          </tbody>
        </table>
      `;
    }

    function renderLogPanel() {
      const el = document.getElementById('logPanel');
      if (!el) return;

      const sid = gameLog ? gameLog.sessionId : '—';
      const started = gameLog ? gameLog.startedAt : '';
      const sub = started ? `Started ${started.slice(0,19).replace('T',' ')}` : '';

      el.innerHTML = `
        <div class="log-panel-header">
          <div>
            <div class="log-panel-title">Run Log</div>
            <div class="log-panel-sub">${sid} · ${sub}</div>
          </div>
          <div class="log-panel-actions">
            <button class="log-mini-btn" onclick="exportLog()">Export</button>
            <button class="log-mini-btn" onclick="clearSavedLog()">Clear</button>
            <button class="log-mini-btn danger" onclick="closeLogPanel()">Close</button>
          </div>
        </div>

        <div class="log-tabs">
          <button class="log-tab ${logPanelTab === 'events' ? 'active' : ''}" onclick="switchLogTab('events')">Events</button>
          <button class="log-tab ${logPanelTab === 'stats' ? 'active' : ''}" onclick="switchLogTab('stats')">Stats</button>
        </div>

        <div class="log-panel-body">
          ${logPanelTab === 'events' ? renderLogEvents() : renderLogStats()}
        </div>
      `;
    }

    function openSettingsPanel() {
      const checked = !!uiSettings.autoOpenLogOnEnd;
      const revealOnClose = (uiSettings.revealTotalsOnClose !== false);

      const oppDiff = getOpponentDifficulty();
      const rakeMode = (uiSettings.rakeMode || 'hard');

      const benchCap = String(safeNumber(uiSettings.benchHardCap, 3));

      const body = `
        <p class="modal-text">Lightweight runtime options for testing.</p>

        <div style="display:flex; flex-direction:column; gap:12px;">

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer;">
              <input id="setting_autoOpenLog" type="checkbox" ${checked ? 'checked' : ''} style="margin-top:3px;"/>
              <div>
                <div style="font-weight:800; color:var(--text-primary);">Auto-open Run Log on Game Over / Victory</div>
                <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">
                  Helpful for rapid playtesting and immediate review.
                </div>
              </div>
            </label>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer;">
              <input id="setting_revealTotalsOnClose" type="checkbox" ${revealOnClose ? 'checked' : ''} style="margin-top:3px;"/>
              <div>
                <div style="font-weight:800; color:var(--text-primary);">Reveal Dealer totals + hole card when a lane closes</div>
                <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">
                  If off, Dealer totals + hole card reveal only at match resolution (Spy Glass still works).
                </div>
              </div>
            </label>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Opponent Difficulty</div>
            <select id="setting_opponentDifficulty" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="easy" ${oppDiff === 'easy' ? 'selected' : ''}>Easy — safer play, rarely uses bench mods</option>
              <option value="medium" ${oppDiff === 'medium' ? 'selected' : ''}>Medium — situational bench use, normal standing</option>
              <option value="hard" ${oppDiff === 'hard' ? 'selected' : ''}>Hard — counterplay-focused, proactive bench use</option>
            </select>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">House Rake</div>
            <select id="setting_rakeMode" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="easy" ${rakeMode === 'easy' ? 'selected' : ''}>Off — 0%</option>
              <option value="medium" ${rakeMode === 'medium' ? 'selected' : ''}>Flat — 10% all floors</option>
              <option value="hard" ${rakeMode === 'hard' ? 'selected' : ''}>Scaled — 10% / 20% / 30%</option>
            </select>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Bench hard cap</div>
            <select id="setting_benchHardCap" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="2" ${benchCap === '2' ? 'selected' : ''}>2 slots</option>
              <option value="3" ${benchCap === '3' ? 'selected' : ''}>3 slots</option>
              <option value="0" ${benchCap === '0' ? 'selected' : ''}>No cap (dev)</option>
            </select>
            <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:8px;">
              Capacity still starts at ${BENCH_BASE_CAPACITY} and grows by boss wins, but won’t exceed the cap.
            </div>
          </div>

        </div>
      `;

      showModal('Settings', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const prevSettings = getSettingsSnapshot();
            const cbLog = document.getElementById('setting_autoOpenLog');
            const cbReveal = document.getElementById('setting_revealTotalsOnClose');
            const selOpp = document.getElementById('setting_opponentDifficulty');
            const selRake = document.getElementById('setting_rakeMode');
            const selCap = document.getElementById('setting_benchHardCap');

            uiSettings.autoOpenLogOnEnd = !!(cbLog && cbLog.checked);
            uiSettings.revealTotalsOnClose = !!(cbReveal && cbReveal.checked);

            uiSettings.opponentDifficulty = (selOpp && selOpp.value) ? selOpp.value : 'hard';
            uiSettings.rakeMode = (selRake && selRake.value) ? selRake.value : 'hard';

            uiSettings.benchHardCap = safeNumber(selCap && selCap.value, 3);

            const nextSettings = getSettingsSnapshot();
            logEvent('SETTINGS_CHANGED', { prev: prevSettings, next: nextSettings });
            if (gameLog) gameLog.settingsLatest = nextSettings;

            closeModal();
            renderAll();
            showToast('Settings saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);
    }



    function openRulesPanel() {
      const body = `
        <p class="modal-text">
          Welcome to <strong>Project 63<strong> where you battle opponents in a unique multi-hand blackjack game while progressing through the casino.
          You move tile-to-tile on a <strong>3-floor</strong> board. Most tables trigger <strong>Blackjack</strong>:
          you and your opponent play <strong>5 hands (lanes)</strong>, with <strong>3 lanes open</strong> at a time. Once you close one lane, the net available lane opens.
        </p>

        <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px; margin-bottom:14px;">
          <div style="font-family:'Cinzel',serif; color:var(--accent-gold); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px;">Blackjack</div>
          <ul style="color:var(--text-secondary); line-height:1.6; padding-left:18px;">
            <li><strong>Draw</strong> a playable card, then <strong>Place</strong> it into any open player lane.</li>
            <li><strong>Stand</strong> closes a lane immediately (total reveals; can bust if over 21).</li>
            <li><strong>Busts finalize at end of turn</strong> (unless you close the lane).</li>
            <li><strong>Calling Suit</strong>: playing a standard card matching your Calling Suit may trigger an effect (chance varies by opponent).</li>
            <li><strong>Modifiers</strong> (±1..±4) auto-go to your <strong>Bench</strong>. Apply them to any open lane. Bench overflow discards the oldest.</li>
            <li><strong>No reshuffle</strong>: if you can’t draw when required, you lose the match (dealer exhaustion = win).</li>
            <li><strong>21 Bonus</strong>: any player lane that hits 21 grants <strong>+${BLACKJACK_21_REWARD}</strong>. All five lanes hitting 21 grants <strong>+${ALL_FIVE_21_BONUS}</strong>.</li>
          </ul>
        </div>

        <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px; margin-bottom:14px;">
          <div style="font-family:'Cinzel',serif; color:var(--accent-gold); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px;">Stakes, Transfers, Rake</div>
          <ul style="color:var(--text-secondary); line-height:1.6; padding-left:18px;">
            <li><strong>Buy-ins</strong>: Standard <strong>${BUYIN_STANDARD}</strong>, High Stakes <strong>${BUYIN_HIGH}</strong>, Boss <strong>${BUYIN_BOSS}</strong>.</li>
            <li>Before play, choose a <strong>Transfer Multiplier</strong>: Standard <strong>${stdLim.min}–${stdLim.max}</strong>, High <strong>${highLim.min}–${highLim.max}</strong>, Boss <strong>${bossLim.min}–${bossLim.max}</strong>. Dealer may raise +1.</li>
            <li><strong>Payout</strong>: win = 2× buy-in, tie = buy-in back (<strong>Boss ties count as a loss</strong>).</li>
            <li><strong>House rake</strong> applies to positive net match gains (current: F1 ${rake1}%, F2 ${rake2}%, F3 ${rake3}%).</li>
          </ul>
        </div>

        <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px; margin-bottom:14px;">
          <div style="font-family:'Cinzel',serif; color:var(--accent-gold); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px;">Actions</div>
          <ul style="color:var(--text-secondary); line-height:1.6; padding-left:18px;">
            <li>Buy cocktails at the Bartender for <strong>${COCKTAIL_COST}</strong> to unlock match actions.</li>
            <li>Each match: <strong>tokens = floor</strong> + up to <strong>${ACTION_TOKEN_MAX_BANKED}</strong> banked tokens (earned from Rest/Minigame).</li>
            <li>Spend 1 token to use 1 action (<strong>one action per turn</strong>, each action usable <strong>once per match</strong>).</li>
          </ul>
        </div>

        <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
          <div style="font-family:'Cinzel',serif; color:var(--accent-gold); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px;">Board Tiles</div>
          <ul style="color:var(--text-secondary); line-height:1.6; padding-left:18px;">
            <li><strong>Rest</strong>: choose free removal or +${REST_REWARD} chips, and always gain <strong>+1 banked token</strong>.</li>
            <li><strong>Minigame</strong>: +${MINIGAME_REWARD} chips and <strong>+1 banked token</strong>.</li>
            <li><strong>Bartender</strong>: take +${BARTENDER_REWARD} chips <em>or</em> buy 1 cocktail (${COCKTAIL_COST}).</li>
            <li><strong>Merchant</strong>: buy cards (Standard ${MERCHANT_BUY_BASE_STANDARD}+ / Mod ${MERCHANT_BUY_BASE_MOD}+ / +${MERCHANT_BUY_INCREMENT} per buy). Paid removals start at ${MERCHANT_REMOVE_COST} and increase by +${MERCHANT_REMOVE_INCREMENT}. Rerolls cost ${MERCHANT_INVENTORY_REROLL_COST}/${REMOVAL_REROLL_COST}.</li>
            <li><strong>MOD (Modify)</strong>: change base cards only (no modifiers/fused). Offers 2 random services; choose 1. Core (1 card) costs ${modCoreF1}/${modCoreF2}/${modCoreF3}. Premium (5 cards) costs ${modPremF1}/${modPremF2}/${modPremF3}.</li>
            <li><strong>Loan Shark</strong>: borrow ${LOAN_AMOUNT}, repay ${LOAN_REPAY} before final boss.</li>
          </ul>
        </div>
      `;
      showModal('Rules', body, [
        { text: 'Close', primary: true, action: () => closeModal() }
      ]);
    }

    function openFeedbackModal() {
      const comments = run && run.feedback ? run.feedback.comments : '';
      const bugs = run && run.feedback ? run.feedback.bugs : '';
      const body = `
        <p class="modal-text">Share any feedback or bugs you noticed during the run.</p>
        <div style="display:flex; flex-direction:column; gap:12px;">
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Comments</div>
            <textarea id="feedback_comments" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${comments}</textarea>
          </div>
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Bugs</div>
            <textarea id="feedback_bugs" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${bugs}</textarea>
          </div>
        </div>
      `;
      showModal('Feedback', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const commentsEl = document.getElementById('feedback_comments');
            const bugsEl = document.getElementById('feedback_bugs');
            const next = {
              comments: commentsEl ? commentsEl.value : '',
              bugs: bugsEl ? bugsEl.value : '',
              updatedAt: new Date().toISOString()
            };
            if (run) run.feedback = next;
            if (gameLog) gameLog.feedback = { ...next };
            logEvent('FEEDBACK_UPDATED', { commentsLen: next.comments.length, bugsLen: next.bugs.length });
            closeModal();
            showToast('Feedback saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);
    }

    function openDeckViewer() {
      if (!run) return;
      const summary = buildDeckSummary();
      const stamps = summary.stampsByRank || {};
      const stampLines = Object.keys(stamps).length
        ? Object.entries(stamps).map(([rank, stampId]) => `${rank}: ${getStampDef(stampId)?.name || stampId}`).join(', ')
        : 'None';

      const bySuitLine = Object.entries(summary.bySuit)
        .map(([suit, count]) => `${suit} ${count}`)
        .join(' · ');

      const byRankLine = RANKS.map(rank => `${rank}:${summary.byRank[rank] || 0}`).join(' ');

      const standards = [];
      const modifiers = [];
      const fused = [];
      run.playerDeck.forEach(card => {
        if (isModifier(card)) modifiers.push(card);
        else if (isFused(card)) fused.push(card);
        else standards.push(card);
      });
      const rankIndex = Object.fromEntries(RANKS.map((r, i) => [r, i]));
      standards.sort((a, b) => {
        const suitDiff = SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
        if (suitDiff !== 0) return suitDiff;
        return (rankIndex[a.rank] || 0) - (rankIndex[b.rank] || 0);
      });

      const list = [...standards, ...fused, ...modifiers];
      const listHtml = list.map(card => renderCard(card, false)).join('');

      const body = `
        <div class="log-kv" style="margin-bottom:10px;">
          <div><strong>Deck size:</strong> ${summary.deckSize}</div>
          <div><strong>Standard:</strong> ${summary.deckSize - summary.modCount - summary.fusedCount} · <strong>Mods:</strong> ${summary.modCount} · <strong>Fused:</strong> ${summary.fusedCount}</div>
          <div><strong>Sleeved:</strong> ${summary.sleevedCount}</div>
          <div><strong>Stamps:</strong> ${stampLines}</div>
        </div>
        <div style="margin-bottom:10px;"><strong>By suit:</strong> ${bySuitLine}</div>
        <div style="margin-bottom:10px;"><strong>By rank:</strong> ${byRankLine}</div>
        <div class="merchant-cards">${listHtml}</div>
      `;

      showModal('Deck Viewer', body, [
        { text: 'Close', primary: true, action: () => closeModal() }
      ]);
    }

    // =============================================
    // UI: MODALS, TOAST, CONFIRM
    // =============================================
    let __modalButtons = [];
    window.__modalAction = function(i) {
      const b = __modalButtons[i];
      if (!b || b.disabled) return;
      if (typeof b.action === 'function') b.action();
    };

    function showModal(title, bodyHtml, buttons = []) {
      __modalButtons = buttons.map(b => ({ ...b }));
      const overlay = document.getElementById('modalOverlay');
      const modal = document.getElementById('modal');
      const footer = buttons.length ? `
        <div class="modal-footer">
          ${buttons.map((b, i) => {
            const cls = [
              'modal-btn',
              b.primary ? 'primary' : '',
              b.danger ? 'danger' : ''
            ].filter(Boolean).join(' ');
            const dis = b.disabled ? 'disabled' : '';
            return `<button class="${cls}" ${dis} onclick="__modalAction(${i})">${b.text}</button>`;
          }).join('')}
        </div>
      ` : '';

      modal.innerHTML = `
        <div class="modal-header">${title}</div>
        <div class="modal-body">${bodyHtml}</div>
        ${footer}
      `;
      overlay.classList.remove('hidden');
    }

    function closeModal() {
      document.getElementById('modalOverlay').classList.add('hidden');
      document.getElementById('modal').innerHTML = '';
      __modalButtons = [];
    }

    let toastTimer = null;
    function showToast(text, ms = 1600) {
      const el = document.getElementById('toast');
      el.textContent = text;
      el.classList.remove('hidden');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.classList.add('hidden');
      }, ms);
    }

    function showConfirmDialog(message, onConfirm) {
      const dialog = document.createElement('div');
      dialog.className = 'confirm-dialog';
      dialog.innerHTML = `
        <div class="confirm-content">
          <div class="confirm-message">${message}</div>
          <div class="confirm-btns">
            <button class="modal-btn danger" id="confirmYes">Yes</button>
            <button class="modal-btn" id="confirmNo">No</button>
          </div>
        </div>
      `;
      document.body.appendChild(dialog);

      dialog.querySelector('#confirmYes').onclick = () => {
        dialog.remove();
        if (onConfirm) onConfirm();
      };
      dialog.querySelector('#confirmNo').onclick = () => dialog.remove();
    }

    // ESC closes modal or log panel
    window.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      const overlay = document.getElementById('modalOverlay');
      if (overlay && !overlay.classList.contains('hidden')) closeModal();
      else if (logPanelOpen) closeLogPanel();
    });

    // =============================================
    // UTILITY FUNCTIONS
    // =============================================
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeStandardDeck52() {
      const deck = [];
      for (const s of SUITS) {
        for (const r of RANKS) deck.push({ uid: null, rank: r, suit: s, sleeveId: null, laminationId: null });
      }
      return deck;
    }

    function isModifier(c) {
      return c && c.type === 'MOD';
    }

    function isFused(c) {
      return c && c.type === 'FUSE';
    }

    function isStandardCard(c) {
      return c && !c.type && c.rank && c.suit;
    }

    const STAMP_DEFS = {
      PLUS_FIVE: { id: 'PLUS_FIVE', name: 'Plus Five', rarity: 'uncommon', desc: '+5 karma per stamped card in a winning lane.', icon: '+5' },
      PLUS_TEN: { id: 'PLUS_TEN', name: 'Plus Ten', rarity: 'rare', desc: '+10 karma per stamped card in a winning lane.', icon: '+10' },
      DOUBLE_DIP: { id: 'DOUBLE_DIP', name: 'Double Dip', rarity: 'uncommon', desc: 'x2 karma contribution per stamped card in a winning lane.', icon: 'x2' },
      TRIPLE_PLAY: { id: 'TRIPLE_PLAY', name: 'Triple Play', rarity: 'rare', desc: 'x3 karma contribution per stamped card in a winning lane.', icon: 'x3' },
      LANE_COUNT_MULT: { id: 'LANE_COUNT_MULT', name: 'Lane Count Mult', rarity: 'rare', desc: 'Multiply stamped-card karma by lane card count.', icon: 'N×' },
      PROXY_SUIT: { id: 'PROXY_SUIT', name: 'Proxy Suit', rarity: 'common', desc: 'Counts as calling suit for proc checks.', icon: 'PS' },
      DEJA_VU: { id: 'DEJA_VU', name: 'Deja Vu', rarity: 'rare', desc: 'Doubles card actions and karma contribution.', icon: 'DV' },
      BURN_AFTER_READING: { id: 'BURN_AFTER_READING', name: 'Burn After Reading', rarity: 'uncommon', desc: 'Remove stamped cards from deck after match.', icon: 'BR' }
    };

    const SLEEVE_DEFS = {
      CRYSTAL: { id: 'CRYSTAL', name: 'Crystal Sleeve', rarity: 'rare', desc: 'Prevent bust once by burning this card.', className: 'sleeve-crystal' },
      STEEL: { id: 'STEEL', name: 'Steel Sleeve', rarity: 'uncommon', desc: 'Lane cannot be targeted by opponent effects.', className: 'sleeve-steel' },
      GOLD: { id: 'GOLD', name: 'Gold Sleeve', rarity: 'rare', desc: 'Gain chips equal to lane total at close.', className: 'sleeve-gold' },
      BLUE: { id: 'BLUE', name: 'Blue Sleeve', rarity: 'common', desc: 'Drawn card goes to bench instead of forced play.', className: 'sleeve-blue' }
    };

    function getStampDef(id) {
      return id ? STAMP_DEFS[id] : null;
    }

    function getSleeveDef(id) {
      return id ? SLEEVE_DEFS[id] : null;
    }

    function getCardStampId(card) {
      if (!run || !run.stampsByRank) return null;
      if (!isStandardCard(card)) return null;
      return run.stampsByRank[card.rank] || null;
    }

    function assignUid(card) {
      if (!card) return null;
      if (card.uid) return card.uid;
      if (!run) return null;
      run.nextCardUid = safeNumber(run.nextCardUid, 1);
      card.uid = run.nextCardUid;
      run.nextCardUid += 1;
      return card.uid;
    }

    function cloneCardWithNewUid(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: null, type: 'MOD', delta: card.delta };
      if (isFused(card)) return { uid: null, type: 'FUSE', a: card.a, b: card.b };
      return {
        uid: null,
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function cardRef(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isFused(card)) return { uid: card.uid || null, kind: 'FUSE', aUid: card.a?.uid || null, bUid: card.b?.uid || null };
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function getStampKarmaContribution(stampId, baseValue, laneSize) {
      switch (stampId) {
        case 'PLUS_FIVE':
          return 5;
        case 'PLUS_TEN':
          return 10;
        case 'DOUBLE_DIP':
          return baseValue;
        case 'TRIPLE_PLAY':
          return baseValue * 2;
        case 'LANE_COUNT_MULT':
          return baseValue * laneSize;
        case 'DEJA_VU':
          return baseValue;
        default:
          return 0;
      }
    }

    function cardToString(c) {
      if (!c) return '';
      if (isModifier(c)) return c.delta > 0 ? `+${c.delta}` : `${c.delta}`;
      if (isFused(c)) return `${cardToString(c.a)}/${cardToString(c.b)}`;
      return `${c.rank}${c.suit}`;
    }

    function isRedSuit(suit) {
      return suit === '♥' || suit === '♦';
    }

    function cardCssClass(card) {
      if (isModifier(card)) return 'mod';
      if (isFused(card)) return 'fused';
      const classes = [isRedSuit(card.suit) ? 'red' : 'black'];
      if (card && card.sleeveId) {
        const sleeve = getSleeveDef(card.sleeveId);
        if (sleeve && sleeve.className) classes.push(sleeve.className);
      }
      return classes.join(' ');
    }

    function rankToValue(rank) {
      if (rank === 'A') return 14;
      if (rank === 'K') return 13;
      if (rank === 'Q') return 12;
      if (rank === 'J') return 11;
      const n = Number(rank);
      return Number.isFinite(n) ? n : 0;
    }

    function valueToRank(value) {
      if (value === 14) return 'A';
      if (value === 13) return 'K';
      if (value === 12) return 'Q';
      if (value === 11) return 'J';
      return String(value);
    }

    function suitColor(suit) {
      return (suit === '♥' || suit === '♦') ? 'red' : 'black';
    }

    function getAffinity(playerSuit, npcSuit) {
      if (!playerSuit || !npcSuit) return 'neutral';
      if (playerSuit === npcSuit) return 'resonant';
      if (suitColor(playerSuit) === suitColor(npcSuit)) return 'dissonant';
      return 'neutral';
    }

    function affinityIcon(affinity) {
      if (affinity === 'resonant') return '+';
      if (affinity === 'dissonant') return '-';
      return '•';
    }

    function maybeLevelUpCallingCardFromKarma() {
      if (!run || !run.callingCard) return;
      const currentRank = run.callingCard.rank || '2';
      const currentIndex = CALLING_RANK_THRESHOLDS.findIndex(t => t.rank === currentRank);
      const nextIndex = currentIndex + 1;
      if (nextIndex <= 0 || nextIndex >= CALLING_RANK_THRESHOLDS.length) return;
      const next = CALLING_RANK_THRESHOLDS[nextIndex];
      if (safeNumber(run.karma, 0) < next.karma) return;
      run.callingCard.rank = next.rank;
      logEvent('CALLING_CARD_LEVEL_UP', {
        fromRank: currentRank,
        toRank: next.rank,
        totalKarma: run.karma,
        thresholdMet: next.karma
      });
      showToast(`Calling Card leveled up: ${currentRank} → ${next.rank}`);
      renderHUD();
    }

    function getCardValueOptions(card) {
      if (!card || isModifier(card)) return [];
      if (isFused(card)) {
        const options = [
          ...getCardValueOptions(card.a),
          ...getCardValueOptions(card.b)
        ];
        return Array.from(new Set(options));
      }
      if (card.rank === 'A') return [1, 11];
      if (['J', 'Q', 'K'].includes(card.rank)) return [10];
      const n = Number(card.rank);
      return Number.isFinite(n) ? [n] : [];
    }

    // Harden total calc to never produce NaN (supports fused + aces)
    function calcBestTotal(cards, modSum = 0) {
      let totals = [0];
      for (const c of cards || []) {
        const options = getCardValueOptions(c);
        if (!options.length) continue;
        const nextTotals = [];
        for (const t of totals) {
          for (const v of options) nextTotals.push(t + v);
        }
        totals = nextTotals;
      }
      totals = totals.map(t => t + modSum);
      const under = totals.filter(t => t <= 21);
      if (under.length) return Math.max(...under);
      return totals.length ? Math.min(...totals) : 0;
    }

    function hexPath(x, y) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i);
        pts.push([x + HEX_SIZE * Math.cos(angle), y + HEX_SIZE * Math.sin(angle)]);
      }
      return `M ${pts.map(p => p.join(',')).join(' L ')} Z`;
    }

    function removeOne(arr, item) {
      const idx = arr.indexOf(item);
      if (idx !== -1) arr.splice(idx, 1);
    }

    function clampAddBankedToken(n = 1) {
      run.bankedTokens = Math.min(ACTION_TOKEN_MAX_BANKED, (run.bankedTokens || 0) + n);
    }

    function distinctRandomIndices(n, length) {
      const idxs = Array.from({ length }, (_, i) => i);
      const s = shuffle(idxs);
      return s.slice(0, Math.min(n, s.length));
    }

    // Merchant random offer: standard card OR modifier (intermixed)
    function randomCard() {
      if (Math.random() < MOD_OFFER_CHANCE) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        return { uid: null, type: 'MOD', delta };
      }
      return {
        uid: null,
        rank: RANKS[Math.floor(Math.random() * RANKS.length)],
        suit: SUITS[Math.floor(Math.random() * SUITS.length)],
        sleeveId: null,
        laminationId: null
      };
    }

    function safeNumber(x, fallback = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : fallback;
    }

    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function fmt(n) {
      if (n === null || n === undefined || Number.isNaN(Number(n))) return '—';
      return String(Math.round(Number(n)));
    }

    function formatCompact(n) {
      const x = safeNumber(n, 0);
      const abs = Math.abs(x);
      if (abs >= 1000000) return `${(x / 1000000).toFixed(1)}m`;
      if (abs >= 1000) return `${(x / 1000).toFixed(1)}k`;
      return `${Math.round(x)}`;
    }

    function num(v, fallback = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    }

    function numOrNull(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function avg(arr) {
      const vals = (arr || []).filter(v => v !== null && v !== undefined && Number.isFinite(Number(v))).map(Number);
      if (!vals.length) return null;
      return vals.reduce((a, b) => a + b, 0) / vals.length;
    }

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function normRange(v, lo, hi){
      if(v===null || v===undefined || Number.isNaN(v)) return 0;
      if(hi===lo) return 0;
      return clamp01((v - lo) / (hi - lo));
    }
    function countEvents(events, matcher){
      if(!events || !events.length) return 0;
      if(typeof matcher === 'function') return events.filter(matcher).length;
      const m = String(matcher||'');
      return events.filter(e=>String(e.type||'').toUpperCase().includes(m)).length;
    }
    function herfindahl(obj){
      if(!obj || typeof obj!=='object') return null;
      const values = Object.values(obj).map(v=>Number(v)).filter(v=>!Number.isNaN(v));
      const total = values.reduce((a,b)=>a+b,0);
      if(!total) return null;
      return values.reduce((a,v)=> a + Math.pow(v/total,2), 0);
    }

    const PIT_MESSAGES = {
      WIN:  'You escaped this time, but the Pit remembers.',
      LOSS: 'You fell short. The only way out is back through.',
      UNKNOWN: 'The Pit watches. The ledger remains open.'
    };

    const ARCHETYPE_EXEMPLARS = {
      'The Surgeon': { name: 'Maria', epithet: 'The Surgeon' },
      'The Saboteur': { name: 'Rook', epithet: 'The Saboteur' },
      'The High Roller': { name: 'Vance', epithet: 'The High Roller' },
      'The Engine Builder': { name: 'Inez', epithet: 'The Engine Builder' },
      'The Karma Chaser': { name: 'Sol', epithet: 'The Karma Chaser' },
      'The Banker': { name: 'Edwin', epithet: 'The Banker' }
    };

    function formatArchetypeAttribution(primaryName){
      const ex = ARCHETYPE_EXEMPLARS[primaryName];
      if(!ex) return 'The play pattern most closely matches that of an Unknown hand.';
      return `The play pattern most closely matches that of ${ex.name}, ${ex.epithet}.`;
    }

    function computePlaystyle(summary, derived){
      const matches = derived.matches || [];
      const events = derived.events || [];
      const lanes = derived.lanes || [];
      const deckTimeline = derived.deckTimeline || [];

      const matchesN = Math.max(1, summary.matches || matches.length || 1);
      const highTables = matches.filter(m=>String(m.tableType||'').toUpperCase()==='HIGH_STAKES').length;
      const bossTables = matches.filter(m=>String(m.tableType||'').toUpperCase()==='BOSS').length;
      const tableIntensity = (0.65*highTables + 1.0*bossTables) / matchesN;
      const avgTransferMult = avg(matches.map(m=>numOrNull(m.transferMultiplier)));

      const tempoApplied = countEvents(events, 'TEMPO_STRIKE_APPLIED');
      const tempoBlocked = countEvents(events, 'TEMPO_STRIKE_BLOCKED');
      const tempoApplyRate = (tempoApplied + tempoBlocked) ? tempoApplied / (tempoApplied + tempoBlocked) : 0;

      const tokensSpent = countEvents(events, 'TOKEN_SPENT');
      const actionsUsed = countEvents(events, 'ACTION_USED');
      const tokensPerMatch = tokensSpent / matchesN;
      const actionsPerMatch = actionsUsed / matchesN;

      const callingProcs = events.filter(e=>String(e.type||'').startsWith('CALLING_PROC_')).length;
      const karmaGainEvents = countEvents(events, 'KARMA_GAIN');
      const callingPerMatch = callingProcs / matchesN;

      const deckEdits = deckTimeline.length ? Math.max(0, deckTimeline.length-1) : 0;
      const deckEditsPerMatch = deckEdits / matchesN;
      const editReasons = deckTimeline.map(d=>String(d.reason||'').toUpperCase());
      const stampCount = editReasons.filter(r=>r==='STAMP_APPLY').length;
      const sleeveCount = editReasons.filter(r=>r==='SLEEVE_APPLY').length;
      const fuseCount = editReasons.filter(r=>r==='REWARD_FUSE').length;
      const duplicateCount = editReasons.filter(r=>r==='REWARD_DUPLICATE').length;

      const sinkAgg = summary.sinkAgg || {};
      const totalSpend = summary.totalSpend || 0;
      const merchantSpend = Math.abs((sinkAgg['Merchant removals']||0) + (sinkAgg['Merchant buys']||0) + (sinkAgg['Merchant rerolls']||0));
      const collectorSpend = Math.abs(sinkAgg['Collector']||0);
      const modifySpend = Math.abs(sinkAgg['Modify']||0);
      const surgerySpendShare = totalSpend ? (merchantSpend + collectorSpend + modifySpend) / totalSpend : 0;

      const bustRate = summary.playerBustRate ?? (lanes.length ? lanes.filter(l=>l.playerBust).length / lanes.length : 0);
      const controlTotals = summary.avgPlayerTotalNoBust ?? summary.avgPlayerTotal ?? null;
      const deckEnd = deckTimeline.length ? deckTimeline[deckTimeline.length-1] : null;
      herfindahl(deckEnd?.bySuit ?? deckEnd?.summary?.bySuit);
      const modDensity = summary.modDensityEnd ?? null;

      const risk = 100 * (0.45*clamp01(tableIntensity) + 0.35*normRange(avgTransferMult, 1, 5) + 0.20*normRange(summary.profitStdDev, 0, 200));
      const pressure = 100 * (0.55*normRange(tempoApplied / matchesN, 0, 6) + 0.25*normRange(actionsPerMatch, 0, 2) + 0.20*normRange(tempoApplyRate, 0.2, 0.6));
      const control = 100 * (0.5*(1 - normRange(bustRate, 0, 0.35)) + 0.25*normRange(controlTotals, 17, 20) + 0.25*normRange(modDensity, 0, 0.25));
      const surgery = 100 * (0.5*normRange(deckEditsPerMatch, 0, 1.5) + 0.25*normRange(surgerySpendShare, 0, 0.6) + 0.25*normRange(merchantSpend / Math.max(1, totalSpend), 0, 0.6));
      const engine = 100 * (0.45*normRange(stampCount + sleeveCount, 0, 6) + 0.35*normRange(fuseCount + duplicateCount, 0, 6) + 0.20*normRange(summary.player21Rate, 0.15, 0.65));
      const karma = 100 * (0.6*normRange(callingPerMatch, 0, 3) + 0.4*normRange(karmaGainEvents / matchesN, 0, 4));
      const actions = 100 * (0.55*normRange(tokensPerMatch, 0, 2) + 0.45*normRange(actionsPerMatch, 0, 1.5));
      const economy = 100 * (0.6*normRange((summary.chipsLow||0) / Math.max(1, summary.startChips||1), 0.2, 0.8) + 0.4*(1 - normRange(totalSpend / Math.max(1, Math.abs(summary.matchProfitTotal)||1), 0.5, 2)));

      const axes = { risk, pressure, control, surgery, engine, karma, actions, economy };
      const axes01 = Object.fromEntries(Object.entries(axes).map(([k,v])=>[k, clamp01(v/100)]));
      const archetypes = [
        {name:'The Surgeon', vec:{surgery:0.85, control:0.65, engine:0.4, economy:0.4}},
        {name:'The Saboteur', vec:{pressure:0.85, actions:0.7, risk:0.5}},
        {name:'The High Roller', vec:{risk:0.9, economy:0.2, control:0.2}},
        {name:'The Engine Builder', vec:{engine:0.9, control:0.45, surgery:0.35}},
        {name:'The Karma Chaser', vec:{karma:0.9, engine:0.5, control:0.35}},
        {name:'The Banker', vec:{economy:0.9, control:0.7, risk:0.1}}
      ];

      function cosineScore(vec){
        const keys = Object.keys(axes01);
        const a = keys.map(k=>axes01[k] ?? 0);
        const b = keys.map(k=>vec[k] ?? 0);
        const dot = a.reduce((s,v,i)=>s + v*b[i], 0);
        const magA = Math.sqrt(a.reduce((s,v)=>s+v*v, 0)) || 1;
        const magB = Math.sqrt(b.reduce((s,v)=>s+v*v, 0)) || 1;
        return dot / (magA * magB);
      }

      const scored = archetypes.map(a=>({name:a.name, score: cosineScore(a.vec)})).sort((a,b)=>b.score-a.score);
      const primary = scored[0] || {name:'Unknown', score:0};
      const secondary = scored[1] || {name:'None', score:0};
      const confidence = clamp01((primary.score - secondary.score) / 0.2);
      return { axes, primary, secondary, confidence, archetypeScores: scored };
    }

    function buildRunEndAnalysis() {
      const events = (gameLog && gameLog.events) ? gameLog.events : [];
      const deckTimeline = (gameLog && gameLog.deckHistory) ? gameLog.deckHistory : [];
      const matches = events.filter(e => e.type === 'MATCH_END').map(e => ({
        floor: safeNumber(e.floor, null),
        tableType: e.data ? (e.data.type || null) : null,
        chipsAfter: safeNumber(e.chips, 0),
        karmaGained: safeNumber(e.data && e.data.karmaGained, 0),
        transferMultiplier: safeNumber(e.data && e.data.transferMultiplier, 1)
      }));

      const startDeck = (gameLog && gameLog.initialState && gameLog.initialState.deckSnapshot) || null;
      const endDeck = (gameLog && gameLog.finalState && gameLog.finalState.deckSnapshot) || startDeck;
      const deckSizeStart = startDeck ? safeNumber(startDeck.deckSize, null) : null;
      const deckSizeEnd = endDeck ? safeNumber(endDeck.deckSize, null) : null;
      const modCountEnd = endDeck ? safeNumber(endDeck.modCount, null) : null;
      const modDensityEnd = (deckSizeEnd && modCountEnd !== null) ? (modCountEnd / Math.max(1, deckSizeEnd)) : null;

      const summary = {
        matches: matches.length,
        runOutcome: { result: ((gameLog && gameLog.runOutcome && gameLog.runOutcome.outcome) || 'unknown').toUpperCase() },
        appBuild: gameLog && gameLog.app ? gameLog.app.build : null,
        appVersion: gameLog && gameLog.app ? gameLog.app.version : null,
        sessionId: gameLog ? gameLog.sessionId : null,
        startedAtISO: gameLog ? gameLog.startedAt : null,
        deckSizeStart,
        deckSizeEnd,
        modCountEnd,
        modDensityEnd,
        startChips: gameLog && gameLog.initialState ? safeNumber(gameLog.initialState.chips, 0) : 0,
        endChips: gameLog && gameLog.finalState ? safeNumber(gameLog.finalState.chips, 0) : safeNumber(run && run.chips, 0),
        startKarma: gameLog && gameLog.initialState ? safeNumber(gameLog.initialState.karma, 0) : 0,
        endKarma: gameLog && gameLog.finalState ? safeNumber(gameLog.finalState.karma, 0) : safeNumber(run && run.karma, 0),
        chipsLow: gameLog && gameLog.stats ? safeNumber(gameLog.stats.chipsLow, 0) : 0,
        matchProfitTotal: gameLog && gameLog.stats ? safeNumber(gameLog.stats.payoutReceived, 0) + safeNumber(gameLog.stats.transferNet, 0) : 0,
        totalSpend: gameLog && gameLog.stats ? safeNumber(gameLog.stats.buyinSpent, 0) : 0,
        sinkAgg: {
          'Merchant removals': gameLog && gameLog.stats ? -safeNumber(gameLog.stats.merchantRemoves, 0) * MERCHANT_REMOVE_COST : 0,
          'Merchant buys': gameLog && gameLog.stats ? -safeNumber(gameLog.stats.merchantBuys, 0) * MERCHANT_BUY_BASE_STANDARD : 0,
          'Merchant rerolls': gameLog && gameLog.stats ? -safeNumber(gameLog.stats.merchantRerolls, 0) * MERCHANT_REROLL_COST : 0,
          'Collector': 0,
          'Modify': 0
        },
        playerBustRate: null,
        avgPlayerTotalNoBust: null,
        avgPlayerTotal: null,
        player21Rate: null,
        profitStdDev: null
      };

      const derived = { matches, events, lanes: [], deckTimeline };
      summary.playstyle = computePlaystyle(summary, derived);
      return { summary, derived };
    }

// =============================================
// ECONOMY / LIMIT HELPERS
// =============================================
function getHouseRakeRate(floor) {
  const mode = (uiSettings && uiSettings.rakeMode) || 'hard';

  if (mode === 'easy') return 0;
  if (mode === 'medium') return 0.10;

  // hard = 10/20/30 by floor (default behavior)
  const hardRates = { 1: 0.10, 2: 0.20, 3: 0.30 };
  const r = hardRates[String(floor)] ?? hardRates[floor] ?? 0;
  return Math.max(0, Math.min(0.95, safeNumber(r, 0)));
}

function getOpponentDifficulty() {
  const d = (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard';
  return (d === 'easy' || d === 'medium' || d === 'hard') ? d : 'hard';
}

function getMerchantPriceMult() {
  const ctx = run && run.ui && run.ui.merchantContext;
  const mult = ctx && typeof ctx.priceMult === 'number' ? ctx.priceMult : 1;
  return Math.max(0.75, Math.min(1.25, mult));
}

function getMerchantRemovalCost() {
  const n = safeNumber(run && run.paidRemovalCount, 0);
  const base = MERCHANT_REMOVE_COST + (n * MERCHANT_REMOVE_INCREMENT);
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantCost(base) {
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantBuyCost(card) {
  const isMod = isModifier(card);
  const base = isMod ? MERCHANT_BUY_BASE_MOD : MERCHANT_BUY_BASE_STANDARD;
  const count = isMod
    ? safeNumber(run && run.merchantModifierBuys, 0)
    : safeNumber(run && run.merchantStandardBuys, 0);
  const scaled = base + (MERCHANT_BUY_INCREMENT * count);
  return Math.ceil(scaled * getMerchantPriceMult());
}

function getModifyServiceCost(serviceId, floor) {
  const baseFloor = Math.max(1, safeNumber(floor, 1));
  const isPremium = serviceId === 'CALLING_SUIT_SWEEP' || serviceId === 'UNIFORM_RANK_PRESS';
  const base = isPremium ? 200 : 100;
  const step = isPremium ? 50 : 25;
  return base + ((baseFloor - 1) * step);
}

function getModKey(delta) { return String(delta); }

function getModifierPurchased(delta) {
  const key = getModKey(delta);
  return safeNumber(run && run.modPurchaseCounts && run.modPurchaseCounts[key], 0);
}

function getModifierRemaining(delta) {
  return Math.max(0, MOD_PURCHASE_LIMIT_PER_DELTA - getModifierPurchased(delta));
}

function recordModifierPurchase(delta) {
  const key = getModKey(delta);
  if (!run.modPurchaseCounts) run.modPurchaseCounts = {};
  run.modPurchaseCounts[key] = getModifierPurchased(delta) + 1;
}

function getBenchCapacity() {
  const wins = safeNumber(run && run.bossWins, 0);
  const uncapped = BENCH_BASE_CAPACITY + (wins * BENCH_CAPACITY_BONUS_PER_BOSS_WIN);

  const cap = safeNumber(uiSettings && uiSettings.benchHardCap, 0);
  if (cap > 0) return Math.max(1, Math.min(cap, uncapped));
  return uncapped;
}


// Push to bench with FIFO overflow (oldest discarded if full)
function benchPush(card, source = '') {
  if (!blackjackMatch) return;
  const cap = getBenchCapacity();
  blackjackMatch.bench = blackjackMatch.bench || [];
  let removed = null;

  if (blackjackMatch.bench.length >= cap) {
    removed = blackjackMatch.bench.shift();

    // keep armed index stable
    if (blackjackMatch.armedBenchIdx !== null && blackjackMatch.armedBenchIdx !== undefined) {
      if (blackjackMatch.armedBenchIdx === 0) blackjackMatch.armedBenchIdx = null;
      else blackjackMatch.armedBenchIdx = Math.max(0, blackjackMatch.armedBenchIdx - 1);
    }

    logEvent('BENCH_OVERFLOW', { removed: cardToString(removed), added: cardToString(card), cap, source });
    showToast(`Bench full (${cap}). Discarded ${cardToString(removed)}.`);
  }

  blackjackMatch.bench.push(card);
  return removed;
}


    // =============================================
    // BOARD GENERATION
    // =============================================
    const NPC_NAMES = ['Rowan', 'Maris', 'Calder', 'June', 'Sable', 'Nico', 'Arden', 'Vale', 'Tamsin', 'Quinn', 'Otto', 'Liora'];

    function randomChoice(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function rollNpcRankValue(floor, type) {
      const roll = Math.random();
      if (type === 'STANDARD') {
        if (floor === 1) {
          if (roll < 0.02) return randInt(12, 14);
          if (roll < 0.12) return randInt(9, 11);
          return randInt(2, 8);
        }
        if (floor === 2) {
          if (roll < 0.02) return 14;
          if (roll < 0.12) return randInt(11, 13);
          return randInt(4, 10);
        }
        if (roll < 0.10) return randInt(13, 14);
        return randInt(6, 12);
      }
      if (type === 'HIGH_STAKES') {
        if (floor === 1) {
          if (roll < 0.10) return randInt(12, 14);
          return randInt(6, 11);
        }
        if (floor === 2) {
          if (roll < 0.10) return 14;
          return randInt(8, 13);
        }
        return randInt(10, 14);
      }
      if (type === 'BOSS') {
        if (floor === 1) {
          if (roll < 0.20) return 14;
          return randInt(10, 13);
        }
        if (floor === 2) return randInt(12, 14);
        return 14;
      }
      return randInt(4, 12);
    }

    function makeNpcName(type) {
      const base = randomChoice(NPC_NAMES);
      if (type === 'HIGH_STAKES') return `High Roller ${base}`;
      if (type === 'BOSS') return `Floor Boss: ${base}`;
      return base;
    }

    function createNpcForTile(floor, type) {
      const tableTypes = ['STANDARD', 'HIGH_STAKES', 'BOSS'];
      const roleSuits = {
        BARTENDER: '♥',
        MERCHANT: '♦',
        LOAN_SHARK: '♣'
      };

      if (!tableTypes.includes(type) && !roleSuits[type]) return null;

      const suit = roleSuits[type] || randomChoice(['♥', '♠', '♦', '♣']);
      const rankValue = rollNpcRankValue(floor, type);
      const rank = valueToRank(rankValue);
      const name = makeNpcName(type);
      return { name, callingCard: { rank, suit } };
    }

    function buildTilePoolForFloor(floor) {
      const pool = [];
      const counts = FLOOR_COUNTS[floor];

      let standardCount = counts.standard;
      let highCount = counts.high;
      if (standardCount > 0) standardCount -= 1;
      else if (highCount > 0) highCount -= 1;

      for (let i = 0; i < standardCount; i++) pool.push('STANDARD');
      for (let i = 0; i < highCount; i++) pool.push('HIGH_STAKES');
      pool.push('COLLECTOR');

      pool.push('BARTENDER');
      pool.push('MINIGAME');
      pool.push('REST_STOP', 'REST_STOP');
      pool.push('MERCHANT', 'MODIFY');
      pool.push('LOAN_SHARK');

      return pool;
    }

    function assignTilesToNodes(floor) {
      const pool = shuffle(buildTilePoolForFloor(floor));
      const tiles = new Array(21).fill(null);

      // Boss at 0
      tiles[0] = 'BOSS';

      // Starting row: one must be bartender
      const startIds = [18, 19, 20];
      const bartenderId = startIds[Math.floor(Math.random() * startIds.length)];
      tiles[bartenderId] = 'BARTENDER';
      removeOne(pool, 'BARTENDER');

      // Fill other two starts
      for (const id of startIds) {
        if (!tiles[id]) tiles[id] = pool.pop();
      }

      // Fill 1-17
      for (let id = 1; id <= 17; id++) tiles[id] = pool.pop();
      return tiles;
    }

    function generateBoard(floor) {
      const tileTypes = assignTilesToNodes(floor);
      const tiles = [];

      for (const [id, x, y, connections] of NODES) {
        const tileType = tileTypes[id];
        const npc = createNpcForTile(floor, tileType);
        tiles.push({
          id,
          type: tileType,
          label: TILE_LABELS[tileType],
          color: TILE_COLORS[tileType],
          center: [x, y],
          svgPath: hexPath(x, y),
          connections,
          isStartRow: id >= 18,
          npc
        });
      }

      return tiles;
    }

    // =============================================
    // RUN INITIALIZATION
    // =============================================
    function initRun() {
      clearDealerTimers();

      run = {
        floor: 1,
        chips: STARTING_CHIPS,
        karma: 0,
        playerName: '',
        callingCard: null,
        callingCardChosenSuit: null,
        playerDeck: makeStandardDeck52(),
        stampsByRank: {},
        collectorShop: null,
        ownedActions: [],
        nextCardUid: 1,
        matchSeq: 0,
        encounterSeq: 0,
        activeEncounter: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        bankedTokens: 0,
        bossWins: 0,
        paidRemovalCount: 0,
        merchantStandardBuys: 0,
        merchantModifierBuys: 0,
        modPurchaseCounts: Object.fromEntries(MODIFIER_DELTAS.map(d => [String(d), 0])),
        loan: { active: false, repaid: false },
        board: {
          tiles: [],
          currentTileId: null,
          visited: new Set(),
          path: []
        },
        ui: {
          mode: 'BOARD',
          message: ''
        }
      };

      resetLog();
      run.playerDeck.forEach(card => assignUid(card));

      const randomNames = [
        'Aria', 'Milo', 'Nova', 'Jax', 'Sable', 'Riven', 'Zara', 'Quinn',
        'Luna', 'Cass', 'Kai', 'Echo', 'Vera', 'Juno', 'Rook', 'Nyx'
      ];

      const getRandomName = () => randomNames[Math.floor(Math.random() * randomNames.length)];

      const showCallingCardReveal = (suit) => {
        showModal('Calling Card Revealed', `
          <p class="modal-text">Your Calling Card is chosen. Let it guide your fortune.</p>
          <div style="display:flex; justify-content:center; margin: 12px 0;">
            ${renderCard(run.callingCard, false, 'large')}
          </div>
          <p class="modal-text" style="text-align:center;">${suit === '♥' ? 'Hearts favor bold wagers.' :
            suit === '♠' ? 'Spades cut through uncertainty.' :
            suit === '♦' ? 'Diamonds sharpen your edge.' :
            'Clubs reward steady pressure.'}</p>
        `, [
          { text: 'Begin Run', primary: true, action: () => { closeModal(); initFloor(1); } }
        ]);
      };

      const chooseSuit = (suit) => {
        run.callingCard = { rank: '2', suit };
        run.callingCardChosenSuit = suit;
        logEvent('CALLING_CARD_SET', { callingCard: run.callingCard });
        logEvent('GAME_START', {
          startingChips: STARTING_CHIPS,
          deckSize: run.playerDeck.length,
          deckSnapshot: deckSnapshot(),
          settings: getSettingsSnapshot(),
          playerName: run.playerName || null
        });
        if (gameLog) {
          gameLog.initialState = {
            chips: run.chips,
            karma: run.karma,
            floor: run.floor,
            callingCard: { ...run.callingCard },
            deckSnapshot: deckSnapshot()
          };
        }
        recordDeckSnapshot('GAME_START');
        closeModal();
        showCallingCardReveal(suit);
      };

      const showCallingSuitModal = () => {
        showModal('Choose Calling Suit', `
          <p class="modal-text">Choose your Calling Suit for this run.</p>
          <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
            <button class="modal-btn" onclick="setCallingSuit('♥')">♥ Hearts</button>
            <button class="modal-btn" onclick="setCallingSuit('♠')">♠ Spades</button>
            <button class="modal-btn" onclick="setCallingSuit('♦')">♦ Diamonds</button>
            <button class="modal-btn" onclick="setCallingSuit('♣')">♣ Clubs</button>
          </div>
        `, []);

        window.setCallingSuit = function(suit) {
          chooseSuit(suit);
          delete window.setCallingSuit;
        };
      };

      const showIntroModal = () => {
        const defaultName = getRandomName();
        showModal('Welcome to the Pit', `
          <p class="modal-text">The tower hums with chance. Every card is a promise, every wager a dare.</p>
          <p class="modal-text">Tell us your name, cardshark.</p>
          <input id="playerNameInput" class="modal-input" value="${escapeHtml(defaultName)}" maxlength="20" />
        `, [
          {
            text: 'Random',
            action: () => {
              const input = document.getElementById('playerNameInput');
              if (input) input.value = getRandomName();
            }
          },
          {
            text: 'Continue',
            primary: true,
            action: () => {
              const input = document.getElementById('playerNameInput');
              const picked = (input && input.value) ? input.value.trim() : '';
              run.playerName = picked || getRandomName();
              closeModal();
              showCallingSuitModal();
            }
          }
        ]);
      };

      showIntroModal();
    }

    function initFloor(floor) {
      clearDealerTimers();

      run.floor = floor;
      run.board.tiles = generateBoard(floor);
      run.board.currentTileId = null;
      run.board.visited = new Set();
      run.board.path = [];
      run.ui.mode = 'BOARD';

      logEvent('FLOOR_START', { floor });
      run.board.tiles.forEach(tile => {
        if (tile.npc) {
          logEvent('NPC_ASSIGNED', {
            floor,
            tileId: tile.id,
            tileType: tile.type,
            npcName: tile.npc.name,
            npcCallingCard: tile.npc.callingCard
          });
        }
      });

      renderAll();
    }

    // =============================================
    // MOVEMENT
    // =============================================
    function getAvailableMoves() {
      const currentId = run.board.currentTileId;
      if (currentId === null) return [18, 19, 20].filter(id => !run.board.visited.has(id));
      const current = run.board.tiles[currentId];
      return current.connections.filter(id => !run.board.visited.has(id));
    }

    function enterTile(tileId) {
      run.board.currentTileId = tileId;
      run.board.visited.add(tileId);
      run.board.path.push(tileId);

      const tileType = run.board.tiles[tileId].type;
      run.encounterSeq = safeNumber(run.encounterSeq, 0) + 1;
      run.activeEncounter = { seq: run.encounterSeq, type: tileType, tileId, tileType };
      logEvent('TILE_ENTER', { tileId, tileType });

      renderBoard();
      resolveTileEncounter(tileType);
    }

    // =============================================
    // ENCOUNTERS
    // =============================================
    function resolveTileEncounter(tileType) {
      switch (tileType) {
        case 'REST_STOP': encounterRest(); break;
        case 'BARTENDER': encounterBartender(); break;
        case 'MINIGAME': encounterMinigame(); break;
        case 'LOAN_SHARK': encounterLoanShark(); break;
        case 'MERCHANT': encounterMerchant(); break;
        case 'MODIFY': encounterModify(); break;
        case 'COLLECTOR': encounterCollector(); break;
        case 'STANDARD': encounterBlackjackStandard(); break;
        case 'HIGH_STAKES': encounterBlackjackHigh(); break;
        case 'BOSS': encounterBoss(); break;
      }
    }

    // --- Rest Stop: choose FREE removal OR +50 chips, then always +1 banked token ---
    function encounterRest() {
      showModal('Rest Stop', `
        <p class="modal-text">You take a moment to rest. Choose one benefit.</p>
        <p class="modal-text" style="margin-top:-6px;"><span style="color:var(--accent-purple); font-weight:700;">Also:</span> You will gain <strong>+1 banked Action Token</strong> regardless of choice.</p>
      `, [
        {
          text: 'Free Card Removal',
          primary: true,
          action: () => {
            logEvent('REST_CHOICE', { choice: 'free_removal', freeRemoval: true });
            openFreeRemovalPicker('Rest Stop - Free Removal', () => {
              clampAddBankedToken(1);
              logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
              renderHUD();
              showToast('+1 banked token');
            });
          }
        },
        {
          text: `Take +${REST_REWARD} Chips`,
          action: () => {
            run.chips = safeNumber(run.chips) + REST_REWARD;
            clampAddBankedToken(1);
            logEvent('REST_CHOICE', { choice: 'chips', chips: REST_REWARD });
            logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
            closeModal();
            renderAll();
            showToast(`+${REST_REWARD} chips, +1 banked token`);
          }
        },
        { text: 'Leave', action: () => {
          clampAddBankedToken(1);
          logEvent('REST_CHOICE', { choice: 'leave' });
          logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
          closeModal();
          renderAll();
          showToast('+1 banked token');
        } }
      ]);
    }

    // helper: free removal picker (3 random cards, choose one or none)
    function openFreeRemovalPicker(title, onDone) {
      const candidates = distinctRandomIndices(3, run.playerDeck.length).map(i => ({ card: run.playerDeck[i] }));
      let selected = null;

      function renderPicker() {
        let body = `
          <p class="modal-text">Select a card to remove (free). You may also choose none.</p>
          <div class="removal-picker">
            <div class="removal-cards">
              ${candidates.map((d, idx) => {
                const sel = selected === idx ? 'selected' : '';
                return `
                  <div class="removal-card-option ${sel}" onclick="selectFreeRemoval(${idx})">
                    ${renderCard(d.card, false)}
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;

        showModal(title, body, [
          { text: 'Confirm', primary: true, disabled: selected === null, action: confirm },
          { text: 'Choose None', action: skip },
        ]);
      }

      window.selectFreeRemoval = function(idx) {
        selected = idx;
        renderPicker();
      };

      function confirm() {
        if (selected === null) return;
        const d = candidates[selected];
        const idx = run.playerDeck.indexOf(d.card);
        if (idx !== -1) run.playerDeck.splice(idx, 1);
        logEvent('FREE_REMOVAL', { card: cardToString(d.card), cardUid: d.card.uid || null, cardRef: cardRef(d.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('FREE_REMOVAL');
        closeModal();
        renderAll();
        showToast(`Removed ${cardToString(d.card)} (free)`);
        if (onDone) onDone();
      }

      function skip() {
        logEvent('FREE_REMOVAL_SKIP', {});
        closeModal();
        renderAll();
        if (onDone) onDone();
      }

      renderPicker();
    }

    // --- Bartender: choose +50 chips OR buy cocktail (150). Only one choice. ---
    function encounterBartender() {
      const allIds = Object.keys(ACTIONS);
      const unowned = allIds.filter(id => !run.ownedActions.includes(id));
      const offeredId = unowned.length ? unowned[Math.floor(Math.random() * unowned.length)] : null;

      const canBuy = offeredId && run.chips >= COCKTAIL_COST;
      const ownedCount = run.ownedActions.length;

      let offerHtml = '';
      if (!offeredId) {
        offerHtml = `
          <p class="modal-text">The bartender has no new cocktails to offer right now.</p>
          <p class="modal-text">You can still take <strong>+${BARTENDER_REWARD} chips</strong> if you want.</p>
        `;
      } else {
        offerHtml = `
          <p class="modal-text">The bartender offers you a choice: take chips for luck, or buy a cocktail that unlocks a match action.</p>
          <div style="padding:12px; border:1px solid var(--border-color); border-radius:12px; background: var(--bg-card); margin: 14px 0;">
            <div style="font-family:'Cinzel', serif; color: var(--accent-gold); text-transform: uppercase; letter-spacing: 1px; font-size: 14px;">
              Cocktail Offer
            </div>
            <div style="margin-top:8px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
              <div style="flex:1;">
                <div style="font-weight:800; color: var(--text-primary);">${ACTIONS[offeredId].name}</div>
                <div style="color: var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">${ACTIONS[offeredId].desc}</div>
              </div>
              <div style="font-family:'Fira Code', monospace; color: var(--accent-purple); font-weight:800;">${COCKTAIL_COST} chips</div>
            </div>
          </div>
          <p class="modal-text" style="margin-top:-6px; color: var(--text-muted);">Actions owned: ${ownedCount}</p>
        `;
      }

      showModal('Bartender', offerHtml, [
        {
          text: `Take +${BARTENDER_REWARD} Chips`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + BARTENDER_REWARD;
            logEvent('BARTENDER_TAKE', { chips: BARTENDER_REWARD });
            closeModal();
            renderAll();
            showToast(`+${BARTENDER_REWARD} chips`);
          }
        },
        {
          text: offeredId ? `Buy Cocktail (${COCKTAIL_COST})` : 'Buy Cocktail (Unavailable)',
          disabled: !canBuy,
          action: () => {
            if (!offeredId) return;
            if (run.chips < COCKTAIL_COST) return;
            run.chips -= COCKTAIL_COST;
            run.ownedActions.push(offeredId);
            logEvent('COCKTAIL_BOUGHT', { actionId: offeredId, actionName: ACTIONS[offeredId].name, cost: COCKTAIL_COST });
            closeModal();
            renderAll();
            showToast(`Unlocked: ${ACTIONS[offeredId].name}`);
          }
        },
        { text: 'Leave', action: () => { closeModal(); renderAll(); } }
      ]);
    }

    // --- Minigame: +50 chips and +1 banked token ---
    function encounterMinigame() {
      run.chips = safeNumber(run.chips) + MINIGAME_REWARD;
      clampAddBankedToken(1);
      logEvent('MINIGAME', { chips: MINIGAME_REWARD, tokens: 1 });
      logEvent('TOKEN_GAIN', { amount: 1, source: 'MINIGAME' });
      showModal('Minigame', `
        <p class="modal-text">You win a quick side game.</p>
        <div class="modal-reward">+${MINIGAME_REWARD} chips</div>
        <p class="modal-text" style="text-align:center; color: var(--accent-purple); font-weight:800;">+1 banked Action Token</p>
      `, [{ text: 'Continue', primary: true, action: () => { closeModal(); renderAll(); } }]);
    }

    function encounterLoanShark() {
      const canTakeLoan = !run.loan.active;

      let body = '<p class="modal-text">The loan shark eyes you carefully.</p>';

      if (canTakeLoan) {
        body += `<p class="modal-text">"Need some chips? I can lend you ${LOAN_AMOUNT}, but you'll owe me ${LOAN_REPAY} before you face the final boss."</p>`;
      } else if (run.loan.active && !run.loan.repaid) {
        body += `<p class="modal-text">"You already owe me ${LOAN_REPAY}. Don't forget to pay up before the final boss."</p>`;
      } else {
        body += '<p class="modal-text">"Our business is concluded. Good luck."</p>';
      }

      const buttons = [];
      if (canTakeLoan) {
        buttons.push({
          text: `Take Loan (+${LOAN_AMOUNT})`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + LOAN_AMOUNT;
            run.loan.active = true;
            run.loan.repaid = false;
            logEvent('LOAN_TAKEN', { amount: LOAN_AMOUNT, repay: LOAN_REPAY });
            closeModal();
            renderAll();
            showToast(`Borrowed ${LOAN_AMOUNT} chips. Repay ${LOAN_REPAY} before Floor 3 boss!`);
          }
        });
      }
      buttons.push({ text: 'Decline', action: () => { closeModal(); renderAll(); } });

      showModal('Loan Shark', body, buttons);
    }

    // =============================================
    // MODIFY
    // =============================================
    const MODIFY_SERVICES = {
      RESUIT: { id: 'RESUIT', name: 'Re-Suit', tier: 'core', kind: 'single' },
      RERANK: { id: 'RERANK', name: 'Re-Rank', tier: 'core', kind: 'single' },
      CALLING_SUIT_SWEEP: { id: 'CALLING_SUIT_SWEEP', name: 'Calling Suit Sweep', tier: 'premium', kind: 'bulk' },
      UNIFORM_RANK_PRESS: { id: 'UNIFORM_RANK_PRESS', name: 'Uniform Rank Press', tier: 'premium', kind: 'bulk' }
    };

    function getEligibleStandardIndices() {
      if (!run || !run.playerDeck) return [];
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (isStandardCard(card)) eligible.push(idx);
      });
      return eligible;
    }

    function buildModifyOffers() {
      const eligible = getEligibleStandardIndices();
      if (!eligible.length) return [];
      const services = [MODIFY_SERVICES.RESUIT.id, MODIFY_SERVICES.RERANK.id];
      services.push(MODIFY_SERVICES.UNIFORM_RANK_PRESS.id);
      if (run && run.callingCard) services.push(MODIFY_SERVICES.CALLING_SUIT_SWEEP.id);
      return shuffle(services).slice(0, Math.min(2, services.length));
    }

    function encounterModify() {
      const offers = buildModifyOffers();
      const eligibleCount = getEligibleStandardIndices().length;

      run.ui.modifyContext = {
        tileId: run.board.currentTileId,
        servicesOffered: offers,
        serviceUsed: false,
        selectedServiceId: null,
        previewIndices: [],
        rankChoices: null
      };

      logEvent('MODIFY_ENTER', {
        tileId: run.board.currentTileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length,
        eligibleCount,
        servicesOffered: offers
      });

      renderModifyMenu();
    }

    function renderModifyMenu() {
      const ctx = run.ui.modifyContext || {};
      const eligibleCount = getEligibleStandardIndices().length;
      const offers = ctx.servicesOffered || [];
      const inProgress = !!ctx.selectedServiceId && !ctx.serviceUsed;
      const chipsNow = safeNumber(run.chips);

      let body = `
        <p class="modal-text">Modify changes cards already in your deck (base cards only). Choose one service.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Eligible cards: <strong>${eligibleCount}</strong></p>
      `;

      if (!eligibleCount) {
        body += `<p class="modal-text" style="color:var(--text-muted);">No eligible cards to modify.</p>`;
      } else if (inProgress) {
        const meta = MODIFY_SERVICES[ctx.selectedServiceId];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Service in progress: ${meta ? meta.name : ctx.selectedServiceId}</p>`;
      } else if (ctx.serviceUsed) {
        body += `<p class="modal-text" style="color:var(--accent-green); font-weight:700;">Service completed.</p>`;
      }

      const buttons = [];
      if (eligibleCount && !ctx.serviceUsed && !inProgress) {
        offers.forEach(serviceId => {
          const meta = MODIFY_SERVICES[serviceId];
          const cost = getModifyServiceCost(serviceId, run.floor);
          buttons.push({
            text: `${meta ? meta.name : serviceId} (${cost})`,
            primary: true,
            disabled: chipsNow < cost,
            action: () => selectModifyService(serviceId)
          });
        });
      } else if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openModifyService(ctx.selectedServiceId)
        });
      }

      if (!inProgress) {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('MODIFY_LEAVE', { tileId: run.board.currentTileId });
            run.ui.modifyContext = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Modify', body, buttons);
    }

    function selectModifyService(serviceId) {
      const ctx = run.ui.modifyContext;
      if (!ctx || ctx.serviceUsed) return;
      const meta = MODIFY_SERVICES[serviceId];
      const cost = getModifyServiceCost(serviceId, run.floor);
      if (run.chips < cost) return;

      const chipsBefore = run.chips;
      run.chips -= cost;
      ctx.selectedServiceId = serviceId;
      logEvent('MODIFY_SERVICE_SELECT', {
        serviceId,
        tier: meta ? meta.tier : null,
        kind: meta ? meta.kind : null,
        cost,
        chipsBefore,
        chipsAfter: run.chips
      });
      openModifyService(serviceId);
    }

    function openModifyService(serviceId) {
      if (serviceId === MODIFY_SERVICES.RESUIT.id) {
        openModifyCorePicker('Re-Suit', serviceId);
        return;
      }
      if (serviceId === MODIFY_SERVICES.RERANK.id) {
        openModifyCorePicker('Re-Rank', serviceId);
        return;
      }
      if (serviceId === MODIFY_SERVICES.CALLING_SUIT_SWEEP.id) {
        openModifyCallingSuitSweep();
        return;
      }
      if (serviceId === MODIFY_SERVICES.UNIFORM_RANK_PRESS.id) {
        openModifyUniformRankPress();
      }
    }

    function openModifyCorePicker(title, serviceId) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;
      const meta = MODIFY_SERVICES[serviceId];
      logEvent('MODIFY_CANDIDATES_SHOWN', {
        serviceId,
        tier: meta ? meta.tier : null,
        countShown: sample.length,
        candidates: sample.map(i => cardRef(run.playerDeck[i]))
      });

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="selectModifyCoreCard(${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Modify - ${title}`, `
        <p class="modal-text">Choose a card to modify.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);

      window.selectModifyCoreCard = function(deckIdx) {
        logEvent('MODIFY_SELECTION', {
          serviceId,
          selected: cardRef(run.playerDeck[deckIdx])
        });
        if (serviceId === MODIFY_SERVICES.RESUIT.id) {
          openModifySuitPicker(deckIdx);
        } else {
          openModifyRankPicker(deckIdx);
        }
      };
    }

    function openModifySuitPicker(deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;

      showModal('Modify - Re-Suit', `
        <p class="modal-text">Choose a new suit for ${cardToString(card)}.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          ${SUITS.map(suit => `<button class="modal-btn" onclick="applyModifyResuit(${deckIdx}, '${suit}')">${suit}</button>`).join('')}
        </div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function openModifyRankPicker(deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;

      const ranksHtml = RANKS.map(rank => `<button class="modal-btn" onclick="applyModifyRerank(${deckIdx}, '${rank}')">${rank}</button>`).join('');
      showModal('Modify - Re-Rank', `
        <p class="modal-text">Choose a new rank for ${cardToString(card)}.</p>
        <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px;">${ranksHtml}</div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    window.applyModifyResuit = function(deckIdx, suit) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;
      applyModifyService('RESUIT', [deckIdx], () => { card.suit = suit; });
    };

    window.applyModifyRerank = function(deckIdx, rank) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;
      applyModifyService('RERANK', [deckIdx], () => { card.rank = rank; });
    };

    function openModifyCallingSuitSweep() {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      showModal('Modify - Calling Suit Sweep', `
        <p class="modal-text">Preview the cards that will be re-suited to ${run.callingCard ? run.callingCard.suit : ''}.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        {
          text: 'Confirm',
          primary: true,
          action: () => {
            applyModifyService('CALLING_SUIT_SWEEP', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.suit = run.callingCard.suit;
              });
            });
          }
        },
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function openModifyUniformRankPress() {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;
      const ranks = shuffle(RANKS.slice()).slice(0, 2);
      ctx.rankChoices = ranks;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      showModal('Modify - Uniform Rank Press', `
        <p class="modal-text">Choose a rank to press onto these cards.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        ...ranks.map(rank => ({
          text: `Set to ${rank}`,
          primary: true,
          action: () => {
            applyModifyService('UNIFORM_RANK_PRESS', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.rank = rank;
              });
            });
          }
        })),
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function applyModifyService(serviceId, indices, applyFn) {
      const ctx = run.ui.modifyContext;
      const before = indices.map(i => cardToString(run.playerDeck[i]));
      const affectedUids = indices.map(i => run.playerDeck[i]?.uid || null);
      applyFn();
      const after = indices.map(i => cardToString(run.playerDeck[i]));

      logEvent('MODIFY_APPLY', {
        serviceId,
        count: indices.length,
        affectedCardUids: affectedUids,
        affectedBefore: before,
        affectedAfter: after,
        deckSnapshot: deckSnapshot()
      });
      recordDeckSnapshot('MODIFY_APPLY');

      if (ctx) {
        ctx.serviceUsed = true;
        ctx.selectedServiceId = null;
        ctx.previewIndices = [];
        ctx.rankChoices = null;
      }

      renderModifyMenu();
      renderAll();
      showToast('Modify service applied');
    }

    // =============================================
    // COLLECTOR
    // =============================================
    const COLLECTOR_CATALOG = [
      ...Object.values(STAMP_DEFS).map(def => ({ ...def, type: 'STAMP' })),
      ...Object.values(SLEEVE_DEFS).map(def => ({ ...def, type: 'SLEEVE' }))
    ];

    function rollCollectorRarity() {
      const roll = Math.random();
      if (roll < 0.70) return 'common';
      if (roll < 0.95) return 'uncommon';
      return 'rare';
    }

    function randomCollectorItem() {
      const rarity = rollCollectorRarity();
      const pool = COLLECTOR_CATALOG.filter(item => item.rarity === rarity);
      const fallback = COLLECTOR_CATALOG;
      const source = pool.length ? pool : fallback;
      const pick = source[Math.floor(Math.random() * source.length)];
      return { ...pick, purchased: false };
    }

    function getEligibleStampRanks() {
      const ranks = new Set();
      for (const card of run.playerDeck) {
        if (!isStandardCard(card)) continue;
        if (run.stampsByRank && run.stampsByRank[card.rank]) continue;
        ranks.add(card.rank);
      }
      return Array.from(ranks);
    }

    function getEligibleSleeveCardIndices() {
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (!isStandardCard(card)) return;
        if (card.sleeveId) return;
        eligible.push(idx);
      });
      return eligible;
    }

    function encounterCollector() {
      const tileId = run.board.currentTileId;
      if (!run.collectorShop || run.collectorShop.tileId !== tileId) {
        const shopId = `shop-${safeNumber(run.encounterSeq, 0)}-${tileId}`;
        run.collectorShop = {
          tileId,
          shopId,
          items: Array.from({ length: 3 }, () => randomCollectorItem()),
          activeItemIdx: null
        };
        logEvent('COLLECTOR_SHOP_GENERATED', {
          shopId,
          items: run.collectorShop.items.map((item, slot) => ({
            slot,
            itemId: item.id,
            type: item.type,
            rarity: item.rarity,
            cost: COLLECTOR_ITEM_COST
          }))
        });
      }

      logEvent('COLLECTOR_ENTER', {
        tileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderCollector();
    }

    function renderCollector() {
      const shop = run.collectorShop;
      if (!shop) return;
      const chipsNow = safeNumber(run.chips);
      const activeIdx = shop.activeItemIdx;
      const inProgress = activeIdx !== null && activeIdx !== undefined;

      let body = `
        <p class="modal-text">The Collector offers stamps and sleeves to shape your deck.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong></p>
      `;

      if (inProgress) {
        const active = shop.items[activeIdx];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Selection in progress: ${active ? active.name : ''}</p>`;
      }

      const itemsHtml = shop.items.map((item, idx) => {
        const eligible = item.type === 'STAMP' ? getEligibleStampRanks().length : getEligibleSleeveCardIndices().length;
        const disabled = item.purchased || chipsNow < COLLECTOR_ITEM_COST || eligible === 0 || inProgress;
        const status = item.purchased ? 'Purchased' : (eligible === 0 ? 'No eligible cards' : '');
        const rarityClass = `rarity-${item.rarity}`;
        return `
          <div class="merchant-card-slot" style="min-width:180px;">
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <span class="rarity-pip ${rarityClass}"></span>
              <strong>${item.name}</strong>
            </div>
            <div style="font-size:12px; color:var(--text-secondary); min-height:32px;">${item.desc}</div>
            <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="buyCollectorItem(${idx})">
              ${item.purchased ? 'Purchased' : `Buy (${COLLECTOR_ITEM_COST})`}
            </button>
            ${status ? `<div style="font-size:11px; color:var(--text-muted); margin-top:6px;">${status}</div>` : ''}
          </div>
        `;
      }).join('');

      body += `<div class="merchant-cards">${itemsHtml}</div>`;

      const buttons = [];
      if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openCollectorSelection(activeIdx)
        });
      } else {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('COLLECTOR_LEAVE', { tileId: run.board.currentTileId });
            run.collectorShop = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Collector', body, buttons);
    }

    window.buyCollectorItem = function(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item || item.purchased) return;
      if (run.chips < COLLECTOR_ITEM_COST) return;

      if (item.type === 'STAMP' && getEligibleStampRanks().length === 0) return;
      if (item.type === 'SLEEVE' && getEligibleSleeveCardIndices().length === 0) return;

      const chipsBefore = run.chips;
      run.chips -= COLLECTOR_ITEM_COST;
      shop.activeItemIdx = idx;
      logEvent('COLLECTOR_BUY', {
        itemId: item.id,
        name: item.name,
        type: item.type,
        cost: COLLECTOR_ITEM_COST,
        shopId: shop.shopId,
        slot: idx,
        chipsBefore,
        chipsAfter: run.chips
      });
      openCollectorSelection(idx);
    };

    function openCollectorSelection(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item) return;
      if (item.type === 'STAMP') openStampSelection(item);
      else openSleeveSelection(item);
    }

    function openStampSelection(item) {
      const ranks = getEligibleStampRanks();
      if (!ranks.length) {
        renderCollector();
        return;
      }
      const options = shuffle(ranks).slice(0, Math.min(2, ranks.length));
      logEvent('STAMP_OPTIONS_SHOWN', {
        stampId: item.id,
        options,
        eligibleCount: ranks.length
      });
      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a rank to stamp.</p>
      `, options.map(rank => ({
        text: rank,
        primary: true,
        action: () => applyStampToRank(item, rank)
      })));
    }

    function applyStampToRank(item, rank) {
      if (!run.stampsByRank) run.stampsByRank = {};
      run.stampsByRank[rank] = item.id;

      logEvent('STAMP_APPLY', { stampId: item.id, rank, shopId: run.collectorShop?.shopId, slot: run.collectorShop?.activeItemIdx ?? null });
      recordDeckSnapshot('STAMP_APPLY');
      finalizeCollectorItem();
      showToast(`${item.name} applied to ${rank}`);
    }

    function openSleeveSelection(item) {
      const eligible = getEligibleSleeveCardIndices();
      if (!eligible.length) {
        renderCollector();
        return;
      }
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      logEvent('SLEEVE_CANDIDATES_SHOWN', {
        sleeveId: item.id,
        candidates: sample.map(idx => cardRef(run.playerDeck[idx]))
      });
      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="applySleeveToCard('${item.id}', ${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a card to sleeve.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderCollector() }
      ]);
    }

    window.applySleeveToCard = function(sleeveId, deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card) || card.sleeveId) return;
      card.sleeveId = sleeveId;
      if (card.laminationId === undefined) card.laminationId = null;
      logEvent('SLEEVE_APPLY', {
        sleeveId,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        shopId: run.collectorShop?.shopId,
        slot: run.collectorShop?.activeItemIdx ?? null
      });
      recordDeckSnapshot('SLEEVE_APPLY');
      finalizeCollectorItem();
      showToast(`${getSleeveDef(sleeveId).name} applied`);
    };

    function finalizeCollectorItem() {
      const shop = run.collectorShop;
      if (!shop) return;
      const idx = shop.activeItemIdx;
      if (idx !== null && idx !== undefined) {
        const item = shop.items[idx];
        if (item) item.purchased = true;
      }
      shop.activeItemIdx = null;
      renderCollector();
      renderAll();
    }

    // =============================================
    // MERCHANT
    // =============================================
    function encounterMerchant() {
      const tile = run.board.tiles[run.board.currentTileId];
      const npc = tile ? tile.npc : null;
      let affinity = 'neutral';
      let edgeDelta = 0;
      let priceMult = 1;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? -0.10 : (affinity === 'dissonant' ? 0.10 : 0);
        const edgeMod = Math.max(-0.10, Math.min(0.10, (rankToValue(npc.callingCard.rank) - rankToValue(run.callingCard.rank)) * 0.01));
        priceMult = Math.max(0.75, Math.min(1.25, 1 + affinityMod + edgeMod));
      }

      run.ui.merchantContext = {
        tileId: run.board.currentTileId,
        npc,
        affinity,
        edgeDelta,
        priceMult
      };

      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      removalPaidCost = 0;
      removalPaidCost = 0;
      removalPaidCost = 0;

      logEvent('MERCHANT_ENTER', {
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        priceMult: Number(priceMult.toFixed(2)),
        offers: merchantOffers.map(cardRef),
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderMerchant();
    }

    function renderMerchant() {
      const chipsNow = safeNumber(run.chips);
      const ctx = run.ui.merchantContext || {};
      const npc = ctx.npc;
      const affinity = ctx.affinity || 'neutral';
      const priceMult = getMerchantPriceMult();
      const npcLine = npc
        ? `${npc.name} · ${cardToString(npc.callingCard)} · ${affinityIcon(affinity)} · Prices x${priceMult.toFixed(2)}`
        : `Prices x${priceMult.toFixed(2)}`;
      const rerollInvCost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      let body = `
        <p class="modal-text">The merchant displays their wares.</p>
        <div class="log-kv" style="margin-bottom:10px;">${npcLine}</div>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Deck: <strong>${run.playerDeck.length}</strong></p>
      `;

      // Buy cards + inventory reroll (always visible)
      const canRerollInv = chipsNow >= rerollInvCost;
      body += `
        <div class="merchant-section">
          <div class="merchant-section-title">Buy Cards (Standard ${MERCHANT_BUY_BASE_STANDARD}+ · Mod ${MERCHANT_BUY_BASE_MOD}+ · +${MERCHANT_BUY_INCREMENT} per buy)</div>
          <div style="display:flex; justify-content:center; margin-bottom:12px;">
            <button class="modal-btn" ${canRerollInv ? '' : 'disabled'} onclick="rerollMerchantInventory()">Re-roll Inventory (${rerollInvCost})</button>
          </div>
          <div class="merchant-cards">
      `;

      merchantOffers.forEach((card, idx) => {
  const isMod = isModifier(card);
  const remaining = isMod ? getModifierRemaining(card.delta) : null;
  const soldOut = isMod && remaining <= 0;
  const slotCost = getMerchantBuyCost(card);
  const canBuy = (chipsNow >= slotCost) && !soldOut;
  const stockLine = isMod
    ? `<div style="margin-top:6px; font-size:12px; color:var(--text-muted);">${soldOut ? 'Sold out' : `Stock: ${remaining}/${MOD_PURCHASE_LIMIT_PER_DELTA}`}</div>`
    : '';

  body += `
    <div class="merchant-card-slot">
      ${renderCard(card, false)}
      ${stockLine}
      <button class="modal-btn" ${canBuy ? '' : 'disabled'} onclick="buyMerchantCard(${idx})">${soldOut ? 'Sold Out' : `Buy (${slotCost})`}</button>
    </div>
  `;
});

      body += '</div></div>';

      
// Removal section (cost paid on entry; reroll still allowed)
const removeCost = getMerchantRemovalCost();
const canEnterRemoval = chipsNow >= removeCost && run.playerDeck.length >= 3;

body += `
  <div class="merchant-section">
    <div class="merchant-section-title">Remove a Card (${removeCost})</div>
          ${removalMode ? `
            <p class="modal-text" style="margin-top:-4px; color: var(--text-muted);">
              Removal fee paid (<strong>${removalPaidCost}</strong>). No refund.
            </p>
          ` : `
            <button class="modal-btn danger" ${canEnterRemoval ? '' : 'disabled'} onclick="startRemoval()">Choose Card to Remove</button>
            <p class="modal-text" style="margin-top:10px; color: var(--text-muted);">Cost is deducted immediately when you enter removal mode.</p>
          `}
        </div>
      `;

      if (removalMode) {
        const removalRerollCost = getMerchantCost(REMOVAL_REROLL_COST);
        const canReroll = safeNumber(run.chips) >= removalRerollCost && run.playerDeck.length >= 1;

        body += `
          <div class="removal-picker">
            <p class="modal-text">Select a card to remove from your deck:</p>
            <div class="removal-cards">
        `;

        removalCandidates.forEach((data, idx) => {
          const card = data.card;
          const selected = selectedRemovalIdx === idx;
          body += `
            <div class="removal-card-option ${selected ? 'selected' : ''}" onclick="selectRemovalCard(${idx})">
              ${renderCard(card, false)}
            </div>
          `;
        });

        body += `
            </div>
            <div style="display:flex; justify-content:center; gap:12px; flex-wrap:wrap;">
              <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollRemoval()">Re-roll (${removalRerollCost})</button>
            </div>
          </div>
        `;
      }

      const buttons = [];
      if (removalMode) {
        buttons.push({
          text: 'Confirm Removal',
          primary: true,
          disabled: selectedRemovalIdx === null,
          action: confirmRemoval
        });
        buttons.push({ text: 'Exit Removal', action: cancelRemoval });
      } else {
        buttons.push({ text: 'Leave', action: () => { closeModal(); renderAll(); } });
      }

      showModal('Merchant', body, buttons);
      renderHUD();
    }

    window.rerollMerchantInventory = function() {
      const cost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;
      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      logEvent('MERCHANT_REROLL', { which: 'inventory', cost, offers: merchantOffers.map(cardRef) });
      renderMerchant();
      showToast(`Re-rolled inventory (-${cost})`);
    };

    window.buyMerchantCard = function(idx) {
  const card = merchantOffers[idx];
  assignUid(card);
  const chipsBefore = run.chips;
  const cost = getMerchantBuyCost(card);
  if (run.chips < cost) return;

  // Per-run purchase limit on modifiers (-4..+4)
    if (isModifier(card) && getModifierRemaining(card.delta) <= 0) {
      showToast(`Sold out: ${cardToString(card)}`);
      logEvent('MODIFIER_SOLD_OUT', {
        floor: run.floor,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        delta: card.delta,
        limit: MOD_PURCHASE_LIMIT_PER_DELTA,
        purchased: run.modPurchaseCounts[String(card.delta)]
      });
    renderMerchant();
    return;
  }

  run.chips -= cost;
  run.playerDeck.push(card);

  if (isModifier(card)) {
    recordModifierPurchase(card.delta);
    run.merchantModifierBuys = safeNumber(run.merchantModifierBuys, 0) + 1;
  } else {
    run.merchantStandardBuys = safeNumber(run.merchantStandardBuys, 0) + 1;
  }

  logEvent('MERCHANT_BUY', {
    card: cardToString(card),
    cardUid: card.uid || null,
    cardRef: cardRef(card),
    cost,
    chipsBefore,
    chipsAfter: run.chips,
    isModifier: isModifier(card),
    modifierRemaining: isModifier(card) ? getModifierRemaining(card.delta) : null,
    deckSnapshot: deckSnapshot()
  });
  recordDeckSnapshot('MERCHANT_BUY');

  // Refresh that inventory slot
  merchantOffers[idx] = randomCard();
  assignUid(merchantOffers[idx]);

  renderMerchant();
  showToast(`Bought ${cardToString(card)}`);
};

    window.startRemoval = function() {
  const cost = getMerchantRemovalCost();
  if (run.chips < cost || run.playerDeck.length < 3) return;

  // pay immediately on entry, no refund; cost scales with each paid removal
  run.chips -= cost;
  run.paidRemovalCount = safeNumber(run.paidRemovalCount, 0) + 1;
  removalPaidCost = cost;

  const indices = distinctRandomIndices(3, run.playerDeck.length);
  removalCandidates = indices.map(i => ({ card: run.playerDeck[i] }));
  removalMode = true;
  selectedRemovalIdx = null;

  logEvent('MERCHANT_REMOVE_START', {
    cost,
    removalCount: run.paidRemovalCount,
    candidates: removalCandidates.map(x => cardRef(x.card))
  });

  renderMerchant();
  showToast(`Removal started (-${cost})`);
};

    window.rerollRemoval = function() {
      if (!removalMode) return;
      const cost = getMerchantCost(REMOVAL_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;

      const indices = distinctRandomIndices(3, run.playerDeck.length);
      removalCandidates = indices.map(i => ({ card: run.playerDeck[i] }));
      selectedRemovalIdx = null;

      logEvent('MERCHANT_REROLL', { which: 'removal', cost, candidates: removalCandidates.map(x => cardRef(x.card)) });

      renderMerchant();
      showToast(`Re-rolled removal (-${cost})`);
    };

    window.selectRemovalCard = function(idx) {
      selectedRemovalIdx = idx;
      renderMerchant();
    };

    window.confirmRemoval = function() {
      if (selectedRemovalIdx === null) return;

      const data = removalCandidates[selectedRemovalIdx];
      const idx = run.playerDeck.indexOf(data.card);
      if (idx !== -1) {
        run.playerDeck.splice(idx, 1);
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('MERCHANT_REMOVE_CONFIRM');
        showToast(`Removed ${cardToString(data.card)} from deck`);
      } else {
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), result: 'not_found' });
        showToast(`Card no longer available to remove`);
      }

      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;

      renderMerchant();
    };

    window.cancelRemoval = function() {
      logEvent('MERCHANT_REMOVE_EXIT', {});
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      renderMerchant();
    };

    // Blackjack encounters
    function encounterBlackjackStandard() {
      if (run.chips < BUYIN_STANDARD) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('STANDARD', BUYIN_STANDARD);
    }

    function encounterBlackjackHigh() {
      if (run.chips < BUYIN_HIGH) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('HIGH_STAKES', BUYIN_HIGH);
    }

    function encounterBoss() {
      if (run.floor === 3 && run.loan.active && !run.loan.repaid) {
        gameOver("Debt unpaid. You cannot face the final boss.");
        return;
      }
      if (run.chips < BUYIN_BOSS) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('BOSS', BUYIN_BOSS);
    }

    // =============================================
    // SLOT BLACKJACK ENGINE
    // =============================================
    function getTransferMultiplierLimits(type) {
      if (type === 'BOSS') return { min: 2, max: 5 };
      if (type === 'HIGH_STAKES') return { min: 1, max: 4 };
      return { min: 1, max: 3 };
    }

    function startBlackjackMatch(type, buyIn) {
      clearDealerTimers();

      run.chips -= buyIn;
      run.matchSeq = safeNumber(run.matchSeq, 0) + 1;

      const playerDrawPile = shuffle(run.playerDeck.slice());

      // Dealer deck = standard 52 + random bench modifiers (2/4/6 by floor)
      const dealerBaseDeck = makeStandardDeck52();
      const extraMods = Math.max(0, Math.min(20, safeNumber(run.floor, 1) * 2)); // F1=2, F2=4, F3=6
      for (let i = 0; i < extraMods; i++) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        dealerBaseDeck.push({ type: 'MOD', delta });
      }
      const dealerDrawPile = shuffle(dealerBaseDeck.slice());

      // load tokens: base by floor + from bank
      const baseTokens = Math.max(1, safeNumber(run.floor, 1));
      const banked = run.bankedTokens || 0;
      const addFromBank = Math.min(banked, ACTION_TOKEN_MAX_BANKED);
      const tokensTotal = baseTokens + addFromBank;
      run.bankedTokens = Math.max(0, banked - addFromBank);

      blackjackMatch = {
        type,
        buyIn,
        matchSeq: run.matchSeq,
        npc: null,
        playerPositions: [],
        dealerPositions: [],
        playerDrawPile,
        dealerDrawPile,

        // NEW: dealer base deck + dealer bench
        dealerBaseDeck,
        dealerBench: [],

        drawnCard: null,
        turn: 'player',
        phase: 'betting',
        result: null,

        // Bench (player mods + normal cards)
        bench: [],
        armedBenchIdx: null,

        // bonuses + transfers
        bonusAll21Awarded: false,
        bonusChipsEarned: 0,
        transferChipsNet: 0,
        transferMultiplier: null,
        transferMultiplierMin: null,
        transferMultiplierMax: null,
        transferMultiplierStage: 'player',
        transferRaiseOffer: null,
        callingProcChance: CALLING_PROC_CHANCE,
        spadePeekLanes: new Set(),
        lastCallingSuitPlay: null,
        traps: {
          player: Array(5).fill(0),
          dealer: Array(5).fill(0)
        },

        // Action tokens + action usage
        tokensTotal,
        tokensSpent: 0,
        usedActions: {},
        actionUsedThisTurn: false,
        actionSelectionInProgress: false,

        // Action effects state
        spyReveals: new Set(),
        dealerForcedLane: null,
        pending: null,
        rewardPending: false,
        winnerReward: null,
        scoreSeq: null,
        exhaustion: null,
        burnedSleeveCards: [],

        metrics: {
          startedAtMs: performance.now(),
          turns: 0,
          playerDraws: 0,
          dealerDraws: 0,
          playerStands: 0,
          dealerStands: 0,
          playerBustsFinal: 0,
          dealerBustsFinal: 0,
          modifiersBenched: 0,
          benchModsToPlayer: 0,
          benchModsToDealer: 0,
          benchCardsPlaced: 0,
          actionsUsed: 0,

          // NEW: dealer bench tracking
          dealerModifiersBenched: 0,
          dealerBenchModsUsed: 0,

          initialDealComplete: false,
          laneCards: {
            playerTotal: Array(5).fill(0),
            dealerTotal: Array(5).fill(0),
            playerAfterInitial: Array(5).fill(0),
            dealerAfterInitial: Array(5).fill(0)
          }
        }
      };

      const limits = getTransferMultiplierLimits(type);
      blackjackMatch.transferMultiplier = limits.min;
      blackjackMatch.transferMultiplierMin = limits.min;
      blackjackMatch.transferMultiplierMax = limits.max;

      const currentTile = run.board.tiles[run.board.currentTileId];
      const npc = currentTile ? currentTile.npc : null;
      blackjackMatch.npc = npc;
      let affinity = 'neutral';
      let edgeDelta = 0;
      let procChance = CALLING_PROC_CHANCE;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? 0.10 : (affinity === 'dissonant' ? -0.10 : 0);
        const edgeMod = Math.max(-0.12, Math.min(0.12, edgeDelta * 0.01));
        procChance = Math.max(0.10, Math.min(0.90, CALLING_PROC_CHANCE + affinityMod + edgeMod));
      }
      blackjackMatch.callingProcChance = procChance;
      blackjackMatch.affinity = affinity;
      blackjackMatch.edgeDelta = edgeDelta;

      logEvent('MATCH_START', {
        type,
        buyIn,
        matchSeq: blackjackMatch.matchSeq,
        baseTokens,
        tokensTotal,
        bankedTokensUsed: addFromBank,
        bankedTokensRemaining: run.bankedTokens,
        dealerExtraMods: extraMods,
        transferMultiplierMin: limits.min,
        transferMultiplierMax: limits.max,
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        callingProcChance: procChance,
        deckSnapshot: deckSnapshot()
      });

      run.ui.mode = 'BLACKJACK';

      // Initialize 5 positions each
      for (let i = 0; i < 5; i++) {
        blackjackMatch.playerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false,
          bonus21Awarded: false
        });
        blackjackMatch.dealerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false
        });
      }

      // Deal initial cards (modifiers never go into lane hands)
      for (let i = 0; i < 3; i++) {
        const okP = dealToPosition(blackjackMatch.playerPositions[i], blackjackMatch.playerDrawPile, run.playerDeck, 'player', i);
        if (!okP) { triggerDeckExhaustion('player', 'initial-deal'); return; }
        maybeAward21BonusForPlayerPos(i);

        const okD = dealToPosition(blackjackMatch.dealerPositions[i], blackjackMatch.dealerDrawPile, dealerBaseDeck, 'dealer', i);
        if (!okD) { triggerDeckExhaustion('dealer', 'initial-deal'); return; }
      }

      blackjackMatch.metrics.initialDealComplete = true;
      run.ui.mode = 'BLACKJACK';
      renderAll();
    }

    window.setTransferMultiplier = function(multiplier) {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'player') return;
      const min = blackjackMatch.transferMultiplierMin || 1;
      const max = blackjackMatch.transferMultiplierMax || 1;
      if (multiplier < min || multiplier > max) return;
      blackjackMatch.transferMultiplier = multiplier;
      blackjackMatch.transferMultiplierStage = 'dealer';
      resolveDealerTransferDecision();
    };

    function resolveDealerTransferDecision() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'dealer') return;
      const current = blackjackMatch.transferMultiplier || 1;
      const max = blackjackMatch.transferMultiplierMax || current;
      const canRaise = current < max;
      const willRaise = canRaise && Math.random() < 0.5;

      if (willRaise) {
        blackjackMatch.transferRaiseOffer = current + 1;
        blackjackMatch.transferMultiplierStage = 'response';
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'raise', offer: blackjackMatch.transferRaiseOffer });
      } else {
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'call' });
        finishTransferBetting();
      }
      renderBlackjack();
    }

    window.acceptTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      blackjackMatch.transferMultiplier = blackjackMatch.transferRaiseOffer || blackjackMatch.transferMultiplier;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'accept', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    window.declineTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'decline', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    function finishTransferBetting() {
      blackjackMatch.transferRaiseOffer = null;
      blackjackMatch.transferMultiplierStage = 'done';
      blackjackMatch.phase = 'playing';
      blackjackMatch.turn = 'player';
      renderBlackjack();
      showToast(`Transfer multiplier locked at x${blackjackMatch.transferMultiplier}`);
    }


    function drawCardFromPile(pile) {
      if (!pile || pile.length === 0) return null;
      return pile.pop();
    }

    // Draw until a NON-modifier is found. Any modifiers drawn are benched (player side).
// Draw until a NON-modifier is found.
// Player: any modifiers drawn are benched.
// Dealer: any modifiers drawn go to dealerBench (not revealed), then draw continues.
    function drawNonModifierCard(pile, fallbackDeck, side) {
      let safety = 0;
      while (safety++ < 300) {
        const fb = (side === 'dealer' && blackjackMatch && blackjackMatch.dealerBaseDeck)
          ? blackjackMatch.dealerBaseDeck
          : fallbackDeck;

        const c = drawCardFromPile(pile, fb);
        if (!c) return null;
        if (isModifier(c)) {
          if (blackjackMatch) {
            if (side === 'player') {
              benchPush(c, 'auto-bench');
              blackjackMatch.metrics.modifiersBenched += 1;
            } else if (side === 'dealer') {
              blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
              blackjackMatch.dealerBench.push(c);
              blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
              logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), source: 'dealer-draw' });
            }
          }
          continue;
        }
        return c;
      }
      return null;
    }


    function dealToPosition(pos, pile, fallbackDeck, side, laneIdx) {
      const a = drawNonModifierCard(pile, fallbackDeck, side);
      const b = drawNonModifierCard(pile, fallbackDeck, side);
      if (!a || !b) return false;
      pos.cards.push(a);
      pos.cards.push(b);
      pos.lastPlay = { kind: 'card', rank: b.rank, value: getStrikeValueFromCard(b) };
      recordLaneCard(side, laneIdx, 1);
      recordLaneCard(side, laneIdx, 1);
      return true;
    }

    function getPositionTotal(pos) {
      const modSum = (pos.mods || []).reduce((a, b) => a + b, 0);
      const base = calcBestTotal(pos.cards, modSum);
      return safeNumber(base, 0);
    }

    function getStrikeValueFromCard(card) {
      if (!card || isModifier(card)) return 0;
      if (isFused(card)) {
        const options = getCardValueOptions(card);
        if (options.includes(11)) return 11;
        return options.length ? Math.min(10, Math.max(...options)) : 0;
      }
      if (card.rank === 'A') return 11;
      if (['J', 'Q', 'K'].includes(card.rank)) return 10;
      const n = Number(card.rank);
      return Number.isFinite(n) ? Math.min(10, n) : 0;
    }

    function computeStrikeDeltaFromLastPlay(lastPlay) {
      if (!lastPlay) return 0;
      if (lastPlay.kind === 'mod') return -lastPlay.delta;
      if (lastPlay.kind === 'card') return -safeNumber(lastPlay.value, 0);
      return 0;
    }

    function applyLaneMod(side, laneIdx, delta) {
      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[laneIdx];
      if (!pos) return 'invalid';
      if (pos.isComplete) return 'closed';
      if (!pos.isOpen) {
        blackjackMatch.traps[side][laneIdx] += delta;
        return 'unopened';
      }
      pos.mods = pos.mods || [];
      pos.mods.push(delta);
      return 'open';
    }

    function tryTempoStrike(attackerSide, laneIdx, reason) {
      if (!blackjackMatch) return;
      const attackerPositions = attackerSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const targetSide = attackerSide === 'dealer' ? 'player' : 'dealer';
      const targetPositions = targetSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const attackerPos = attackerPositions[laneIdx];
      const targetPos = targetPositions[laneIdx];
      if (!attackerPos || !targetPos) return;
      if (!attackerPos.isComplete || attackerPos.isBust) return;

      const delta = computeStrikeDeltaFromLastPlay(attackerPos.lastPlay);
      if (!delta) return;

      if (targetPos.isComplete) {
        logEvent('TEMPO_STRIKE_BLOCKED', {
          attacker: attackerSide,
          lane: laneIdx + 1,
          delta,
          lastPlay: attackerPos.lastPlay,
          targetState: 'closed',
          trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
          reason
        });
        return;
      }

      const targetState = applyLaneMod(targetSide, laneIdx, delta);
      const eventType = (targetState === 'unopened') ? 'TEMPO_STRIKE_TRAP_SET' : 'TEMPO_STRIKE_APPLIED';
      logEvent(eventType, {
        attacker: attackerSide,
        lane: laneIdx + 1,
        delta,
        lastPlay: attackerPos.lastPlay,
        targetState,
        trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
        reason
      });
    }

    function recordLaneCard(side, laneIdx, count = 1, afterInitial = null) {
      if (!blackjackMatch || !blackjackMatch.metrics || laneIdx === null || laneIdx === undefined) return;
      const laneCards = blackjackMatch.metrics.laneCards;
      if (!laneCards || laneIdx < 0 || laneIdx > 4) return;
      const isAfterInitial = afterInitial !== null ? afterInitial : !!blackjackMatch.metrics.initialDealComplete;
      if (side === 'dealer') {
        laneCards.dealerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.dealerAfterInitial[laneIdx] += count;
      } else {
        laneCards.playerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.playerAfterInitial[laneIdx] += count;
      }
    }

    // bust is finalized only at end-of-turn (or when explicitly closes a lane)
    function finalizeBusts(positions, side) {
      for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        if (!pos.isOpen) continue;
        if (pos.isComplete) continue;
        const total = getPositionTotal(pos);
        if (total > 21) {
          let crystalSaved = false;
          if (side === 'player') {
            const crystalIdx = (pos.cards || []).findIndex(c => c && c.sleeveId === 'CRYSTAL');
            if (crystalIdx >= 0) {
              const burned = pos.cards.splice(crystalIdx, 1)[0];
              blackjackMatch.burnedSleeveCards = blackjackMatch.burnedSleeveCards || [];
              blackjackMatch.burnedSleeveCards.push(burned);
              logEvent('CRYSTAL_SLEEVE_SAVE', { laneIdx: i + 1, card: cardToString(burned) });
              showToast(`Crystal Sleeve saved lane #${i + 1}`);
              crystalSaved = true;
              pos.isBust = false;
              pos.isComplete = false;
            }
          }

          if (!crystalSaved) {
            pos.isBust = true;
            pos.isComplete = true;
          } else if (getPositionTotal(pos) > 21) {
            pos.isBust = true;
            pos.isComplete = true;
          }
        }
      }
    }

    function countOpenPositions(positions) {
      return positions.filter(p => p.isOpen && !p.isComplete).length;
    }

    function anyOpenIncomplete(positions) {
      return positions.some(p => p.isOpen && !p.isComplete);
    }

    function openNextPosition(positions, pile, fallbackDeck, side) {
      for (let i = 0; i < 5; i++) {
        if (!positions[i].isOpen) {
          positions[i].isOpen = true;
          const ok = dealToPosition(positions[i], pile, fallbackDeck, side, i);
          if (!ok) {
            triggerDeckExhaustion(side, 'open-lane');
            return -1;
          }

          const trapDelta = blackjackMatch && blackjackMatch.traps ? blackjackMatch.traps[side][i] : 0;
          if (trapDelta) {
            positions[i].mods = positions[i].mods || [];
            positions[i].mods.push(trapDelta);
            blackjackMatch.traps[side][i] = 0;
            const attacker = side === 'dealer' ? 'player' : 'dealer';
            logEvent('TEMPO_STRIKE_TRAP_TRIGGERED', {
              attacker,
              lane: i + 1,
              delta: trapDelta,
              lastPlay: null,
              targetState: 'open',
              trapTotalAfter: blackjackMatch.traps[side][i]
            });
          }

          if (blackjackMatch && side === 'player') maybeAward21BonusForPlayerPos(i);
          return i;
        }
      }
      return -1;
    }

    function maintainOpenPositions(positions, pile, fallbackDeck, side) {
      while (countOpenPositions(positions) < 3) {
        const opened = openNextPosition(positions, pile, fallbackDeck, side);
        if (opened === -1) break;
      }
    }

    function triggerDeckExhaustion(side, reason) {
      if (!blackjackMatch || blackjackMatch.phase === 'resolved') return;
      blackjackMatch.exhaustion = { side, reason };
      logEvent('DECK_EXHAUSTION', { side, reason });
      const forcedOutcome = side === 'dealer' ? 'WIN' : 'LOSS';
      resolveMatch({ forcedOutcome, exhaustion: blackjackMatch.exhaustion });
    }

    function allPositionsComplete(positions) {
      return positions.every(p => p.isComplete);
    }

    // =============================================
    // BONUSES: +21 chips for any PLAYER position reaching total==21 (any way)
    // =============================================
    function maybeAward21BonusForPlayerPos(posIdx) {
      if (!blackjackMatch || !['playing', 'betting'].includes(blackjackMatch.phase)) return;
      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen) return;
      if (pos.bonus21Awarded) return;

      const total = getPositionTotal(pos);
      if (total === 21) {
        pos.bonus21Awarded = true;
        run.chips += BLACKJACK_21_REWARD;
        blackjackMatch.bonusChipsEarned += BLACKJACK_21_REWARD;

        logEvent('BONUS_21', { lane: posIdx + 1, amount: BLACKJACK_21_REWARD });

        renderHUD();
        showToast(`Blackjack! +${BLACKJACK_21_REWARD} chips`);

        if (!blackjackMatch.bonusAll21Awarded) {
          const all = blackjackMatch.playerPositions.every(p => p.bonus21Awarded);
          if (all) {
            blackjackMatch.bonusAll21Awarded = true;
            run.chips += ALL_FIVE_21_BONUS;
            blackjackMatch.bonusChipsEarned += ALL_FIVE_21_BONUS;

            logEvent('BONUS_ALL_FIVE', { amount: ALL_FIVE_21_BONUS });

            renderHUD();
            showToast(`All five! +${ALL_FIVE_21_BONUS} chips`);
          }
        }
      }
    }

    // =============================================
    // BENCH
    // =============================================
    window.armBench = function(i) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      blackjackMatch.armedBenchIdx = (blackjackMatch.armedBenchIdx === i) ? null : i;
      renderBlackjack();
    };

    window.applyBenchTo = function(side, posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;

      const mod = blackjackMatch.bench[bi];
      if (!mod || !isModifier(mod)) return;

      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      pos.mods = pos.mods || [];
      pos.mods.push(mod.delta);
      pos.lastPlay = { kind: 'mod', delta: mod.delta };

      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      if (side === 'player') blackjackMatch.metrics.benchModsToPlayer += 1;
      else blackjackMatch.metrics.benchModsToDealer += 1;

      logEvent('BENCH_APPLY', { card: cardToString(mod), cardUid: mod.uid || null, cardRef: cardRef(mod), side, lane: posIdx + 1, delta: mod.delta });

      if (side === 'player') maybeAward21BonusForPlayerPos(posIdx);

      renderAll();
      showToast(`Played ${cardToString(mod)} to ${side} #${posIdx + 1}`);
    };

    function handleCallingSuitOnPlayerCardPlaced(placedCard, laneIdx, onComplete) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return false;
      if (!run || !run.callingCard) return false;
      if (!isStandardCard(placedCard)) return false;

      const stampId = getCardStampId(placedCard);
      const proxySuit = stampId === 'PROXY_SUIT';
      const matchesCalling = placedCard.suit === run.callingCard.suit || proxySuit;
      const procMult = stampId === 'DEJA_VU' ? 2 : 1;
      const effectiveSuit = proxySuit ? run.callingCard.suit : placedCard.suit;

      if (!matchesCalling) {
        blackjackMatch.lastCallingSuitPlay = null;
        return false;
      }

      const procced = Math.random() < blackjackMatch.callingProcChance;
      blackjackMatch.lastCallingSuitPlay = {
        laneIdx,
        suit: effectiveSuit,
        procced,
        card: placedCard,
        procMult
      };

      if (!procced) return false;

      if (effectiveSuit === '♦') {
        const bonus = DIAMOND_BONUS_CHIPS * procMult;
        run.chips += bonus;
        blackjackMatch.bonusChipsEarned += bonus;
        logEvent('CALLING_PROC_DIAMOND', {
          laneIdx: laneIdx + 1,
          amount: bonus,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        renderHUD();
        showToast(`+${bonus} chips (Wealth)`);
        return false;
      }

      if (effectiveSuit === '♠') {
        blackjackMatch.spadePeekLanes.add(laneIdx);
        logEvent('CALLING_PROC_SPADES', {
          laneIdx: laneIdx + 1,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        showToast(`Intel: Revealed Dealer lane #${laneIdx + 1}`);
        renderBlackjack();
        return false;
      }

      if (effectiveSuit === '♣') {
        const dPos = blackjackMatch.dealerPositions[laneIdx];
        if (!dPos || !dPos.isOpen || dPos.isComplete) {
          logEvent('CALLING_PROC_CLUBS', {
            laneIdx: laneIdx + 1,
            delta: null,
            blocked: true,
            callingCard: run.callingCard,
            playedCard: placedCard,
            multiplier: procMult
          });
          return false;
        }

        showModal('Power Proc', `
          <p class="modal-text">Choose effect on Dealer lane #${laneIdx + 1}.</p>
          <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
            <button class="modal-btn" onclick="applyCallingClubs(${laneIdx}, 1)">+1</button>
            <button class="modal-btn danger" onclick="applyCallingClubs(${laneIdx}, -1)">-1</button>
          </div>
        `, []);

        window.applyCallingClubs = function(targetIdx, delta) {
          const target = blackjackMatch.dealerPositions[targetIdx];
          if (target && target.isOpen && !target.isComplete) {
            target.mods = target.mods || [];
            for (let i = 0; i < procMult; i++) target.mods.push(delta);
            logEvent('CALLING_PROC_CLUBS', {
              laneIdx: targetIdx + 1,
              delta,
              callingCard: run.callingCard,
              playedCard: placedCard,
              multiplier: procMult
            });
            showToast(`Power: Dealer lane #${targetIdx + 1} ${delta > 0 ? '+1' : '-1'}`);
          }
          closeModal();
          delete window.applyCallingClubs;
          renderAll();
          onComplete();
        };
        return true;
      }

      return false;
    }

    window.playerPlaceBenchCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;
      const c = blackjackMatch.bench[bi];
      if (!c || isModifier(c)) return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      pos.cards.push(c);
      pos.lastPlay = { kind: 'card', rank: c.rank, value: getStrikeValueFromCard(c) };
      recordLaneCard('player', posIdx);
      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      blackjackMatch.metrics.benchCardsPlaced += 1;
      logEvent('BENCH_PLACE', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      const deferred = handleCallingSuitOnPlayerCardPlaced(c, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };

    // =============================================
    // PLAYER TURN: drawing places modifiers into bench automatically
    // =============================================
    window.playerDrawCard = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;
      if (countOpenPositions(blackjackMatch.playerPositions) === 0) return;

      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'draw');
          return;
        }
        if (isModifier(c)) {
          benchPush(c, 'player-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)}`);
          continue;
        }
        if (c && c.sleeveId === 'BLUE') {
          benchPush(c, 'blue-sleeve');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'blue-sleeve' });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)} (Blue Sleeve)`);
          continue;
        }
        blackjackMatch.drawnCard = c;
        blackjackMatch.metrics.playerDraws += 1;
        logEvent('PLAYER_DRAW', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
        renderBlackjack();
        return;
      }

      triggerDeckExhaustion('player', 'draw');
    };

    window.playerPlaceCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (!blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      const placed = blackjackMatch.drawnCard;
      pos.cards.push(placed);
      pos.lastPlay = { kind: 'card', rank: placed.rank, value: getStrikeValueFromCard(placed) };
      recordLaneCard('player', posIdx);
      blackjackMatch.drawnCard = null;

      logEvent('PLAYER_PLACE', { card: cardToString(placed), cardUid: placed.uid || null, cardRef: cardRef(placed), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');

      // Apply pending splitDecision dealer gift (after player placement)
      if (blackjackMatch.pending && blackjackMatch.pending.type === 'splitDecision') {
        const gift = blackjackMatch.pending.dealerGiftCard;
        blackjackMatch.pending = null;
        dealerPlaceOneCard(gift, true);
      }

      const deferred = handleCallingSuitOnPlayerCardPlaced(placed, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };

    window.playerStand = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      pos.isComplete = true;

      // If they close while >21, it is a bust now (closure reveals score)
      const total = getPositionTotal(pos);
      pos.isBust = total > 21;

      blackjackMatch.metrics.playerStands += 1;

      logEvent('PLAYER_STAND', { lane: posIdx + 1, total, bust: pos.isBust });

      if (!pos.isBust) {
        tryTempoStrike('player', posIdx, 'stand');
      }

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');

      if (checkMatchEnd()) return;

      if (countOpenPositions(blackjackMatch.playerPositions) === 0) {
        endPlayerTurn();
        return;
      }

      renderBlackjack();
    };

    window.playerEndTurn = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      if (countOpenPositions(blackjackMatch.playerPositions) > 0) return;
      endPlayerTurn();
    };

    function endPlayerTurn() {
      blackjackMatch.metrics.turns += 1;

      // Finalize busts at end of player's turn (per spec)
      const preBust = blackjackMatch.playerPositions.map(p => !!p.isBust);
      finalizeBusts(blackjackMatch.playerPositions, 'player');

      const lastPlay = blackjackMatch.lastCallingSuitPlay;
      if (lastPlay && lastPlay.procced && lastPlay.suit === '♥') {
        const newlyBusted = blackjackMatch.playerPositions
          .map((p, idx) => ({ p, idx }))
          .filter(({ p, idx }) => !preBust[idx] && p.isBust);

        const triageCount = Math.max(1, safeNumber(lastPlay.procMult, 1));
        let remaining = triageCount;

        while (newlyBusted.length && remaining > 0) {
          let targetIdx = newlyBusted.findIndex(n => n.idx === lastPlay.laneIdx);
          if (targetIdx === -1) targetIdx = 0;
          const target = newlyBusted.splice(targetIdx, 1)[0];
          const pos = target.p;
          const discarded = pos.cards.pop();
          pos.isBust = false;
          pos.isComplete = false;
          logEvent('CALLING_PROC_HEARTS_TRIAGE', {
            laneIdx: target.idx + 1,
            discardedCard: cardToString(discarded),
            callingCard: run.callingCard,
            playedCard: lastPlay.card,
            multiplier: triageCount
          });
          showToast(`Health: Triage saved lane #${target.idx + 1}`);
          remaining -= 1;
        }
      }
      blackjackMatch.lastCallingSuitPlay = null;

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');

      if (checkMatchEnd()) return;

      blackjackMatch.turn = 'dealer';
      renderBlackjack();

      clearDealerTimers();
      dealerTimerA = setTimeout(dealerTurn, 800);
    }

    // =============================================
    // DEALER AI + placement helpers
    // =============================================
function dealerRiskPenalty(total) {
  if (total <= 11) return 0;          // explicitly prefers <=11 (e.g. 11 over 12)
  if (total === 12) return 2.2;
  if (total === 13) return 1.8;
  if (total === 14) return 1.5;
  if (total === 15) return 1.2;
  if (total === 16) return 1.0;
  if (total === 17) return 0.55;
  if (total === 18) return 0.30;
  if (total === 19) return 0.18;
  if (total === 20) return 0.10;
  return 0; // 21
}

function estimatePlayerTargetForLane(idx, diff) {
  const pPos = blackjackMatch.playerPositions[idx];
  if (!pPos) return 18;

  const pTotal = getPositionTotal(pPos);
  const pComplete = !!pPos.isComplete;
  const pBust = !!pPos.isBust || (pComplete && pTotal > 21);

  if (pBust) return 0;
  if (pComplete) return Math.min(21, pTotal);

  // Incomplete lanes: heuristic expectation
  if (diff === 'easy') return Math.min(21, pTotal);
  if (diff === 'medium') return Math.min(21, Math.max(pTotal, 17));

  // hard: assumes player pushes safely to ~17-18 when low
  if (pTotal <= 11) return 18;
  if (pTotal <= 14) return 18;
  if (pTotal <= 16) return 17;
  return Math.min(21, pTotal);
}

function dealerLaneScore(idx, total, diff) {
  if (total > 21) return -10000 - total;

  const target = estimatePlayerTargetForLane(idx, diff);

  // If player is (known or assumed) busted, just don't bust; prefer safer totals (<=11)
  if (target === 0) {
    return 120 + (total <= 11 ? (11 - Math.abs(11 - total)) : 0) - dealerRiskPenalty(total) * 12;
  }

  const winNeed = Math.min(21, target + 1);
  const winBonus = (total >= winNeed) ? 140 : 0;
  const closeBonus = (total === 21) ? 260 : (total === 20) ? 90 : (total === 19) ? 45 : 0;
  const pushPenalty = (total === target) ? 14 : 0;

  const risk = dealerRiskPenalty(total) * 12;

  return total + winBonus + closeBonus - risk - pushPenalty;
}

    function dealerPlaceOneCard(card, fromAction = false) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      const open = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (open.length === 0) return;

      // Forced lane (Forced Play action)
      let targetIdx = -1;
      const forced = blackjackMatch.dealerForcedLane;
      if (forced !== null && forced !== undefined) {
        const fp = blackjackMatch.dealerPositions[forced];
        if (fp && fp.isOpen && !fp.isComplete) targetIdx = forced;
        blackjackMatch.dealerForcedLane = null;
      }

      // If not forced, choose by marginal improvement (and some randomness on Easy)
      if (targetIdx === -1) {
        const scored = open.map(({ pos, idx }) => {
          const before = getPositionTotal(pos);
          const beforeScore = dealerLaneScore(idx, before, diff);

          const simulated = { cards: [...pos.cards, card], mods: pos.mods || [] };
          const after = getPositionTotal(simulated);
          const afterScore = dealerLaneScore(idx, after, diff);

          return { idx, before, after, delta: (afterScore - beforeScore), afterScore };
        }).sort((a, b) => b.delta - a.delta);

        if (diff === 'easy') {
          // Easy: pick among top 2 if they exist, weighted by being "not awful"
          const top = scored.slice(0, Math.min(2, scored.length));
          top.sort((a, b) => b.afterScore - a.afterScore);
          targetIdx = (top.length === 1) ? top[0].idx : (Math.random() < 0.55 ? top[0].idx : top[1].idx);
        } else {
          // Medium/Hard: best delta, but if all negative, choose least bad afterScore
          if (scored[0].delta >= 0) targetIdx = scored[0].idx;
          else targetIdx = scored.sort((a, b) => b.afterScore - a.afterScore)[0].idx;
        }
      }

      if (targetIdx >= 0) {
        blackjackMatch.dealerPositions[targetIdx].cards.push(card);
        blackjackMatch.dealerPositions[targetIdx].lastPlay = { kind: 'card', rank: card.rank, value: getStrikeValueFromCard(card) };
        recordLaneCard('dealer', targetIdx);
        if (blackjackMatch.spadePeekLanes) blackjackMatch.spadePeekLanes.delete(targetIdx);

        blackjackMatch.metrics.dealerDraws += 1;

        if (fromAction) {
          renderBlackjack();
          showToast(`Dealer played ${cardToString(card)}`);
        }
      }
    }


function dealerDrawPlayableCard() {
  // draw until non-mod; mods go to dealerBench
  let safety = 0;
  while (safety++ < 300) {
    const fb = (blackjackMatch && blackjackMatch.dealerBaseDeck) ? blackjackMatch.dealerBaseDeck : makeStandardDeck52();
    const c = drawCardFromPile(blackjackMatch.dealerDrawPile, fb);
    if (!c) return null;
    if (isModifier(c)) {
      blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
      blackjackMatch.dealerBench.push(c);
      blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
      logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'dealer-turn-draw' });
      continue;
    }
    return c;
  }
  return null;
}

function dealerApplyBenchMod(bestMove) {
  const { modIdx, laneIdx, modCard, reason } = bestMove;
  const pos = blackjackMatch.dealerPositions[laneIdx];
  if (!pos || !pos.isOpen || pos.isComplete) return false;

  pos.mods = pos.mods || [];
  pos.mods.push(modCard.delta);
  pos.lastPlay = { kind: 'mod', delta: modCard.delta };

  blackjackMatch.dealerBench.splice(modIdx, 1);
  blackjackMatch.metrics.dealerBenchModsUsed = safeNumber(blackjackMatch.metrics.dealerBenchModsUsed, 0) + 1;

  logEvent('DEALER_BENCH_APPLY', { card: cardToString(modCard), cardUid: modCard.uid || null, cardRef: cardRef(modCard), lane: laneIdx + 1, delta: modCard.delta, reason });
  return true;
}

function dealerFindBestBenchMove(diff, phase) {
  const bench = blackjackMatch.dealerBench || [];
  if (!bench.length) return null;

  const open = blackjackMatch.dealerPositions
    .map((p, i) => ({ pos: p, idx: i }))
    .filter(d => d.pos.isOpen && !d.pos.isComplete);

  if (!open.length) return null;

  let best = null;

  for (let mi = 0; mi < bench.length; mi++) {
    const m = bench[mi];
    if (!isModifier(m)) continue;

    for (const { pos, idx } of open) {
      const before = getPositionTotal(pos);
      const after = getPositionTotal({ cards: pos.cards, mods: [...(pos.mods || []), m.delta] });

      // Phase rules:
      // - salvage: prioritize fixing would-be busts (before>21 -> after<=21)
      // - strategic: only play if it *improves* lane score (no forced plays)
      const beforeScore = dealerLaneScore(idx, before, diff);
      const afterScore = dealerLaneScore(idx, after, diff);
      const gain = afterScore - beforeScore;

      if (phase === 'salvage') {
        const fixesBust = (before > 21 && after <= 21);
        if (!fixesBust && gain <= 0) continue;
      } else {
        if (gain <= 0) continue;
      }

      // Prefer “closer to 21” but still safe; risk penalty encodes 11>12 preference.
      const move = {
        modIdx: mi,
        laneIdx: idx,
        modCard: m,
        gain,
        reason: (phase === 'salvage') ? 'salvage' : 'strategic'
      };

      if (!best || move.gain > best.gain) best = move;
    }
  }

  return best;
}

function dealerShouldStandLane(idx, diff) {
  const dPos = blackjackMatch.dealerPositions[idx];
  if (!dPos || !dPos.isOpen || dPos.isComplete) return false;

  const total = getPositionTotal(dPos);
  if (total > 21) return false;

  const pPos = blackjackMatch.playerPositions[idx];
  const pTotal = pPos ? getPositionTotal(pPos) : 0;
  const pComplete = !!(pPos && pPos.isComplete);
  const pBustKnown = !!(pPos && pPos.isComplete && (pPos.isBust || pTotal > 21));

  // If player lane is definitively busted, lock it in (hard/medium); easy sometimes dithers.
  if (pBustKnown) {
    if (diff === 'easy') return (total >= 12) || (Math.random() < 0.25);
    return true;
  }

  // If player lane is complete (known target)
  if (pComplete) {
    if (total > pTotal && total >= 13) return true;
    if (diff === 'hard') return total >= 19;
    return total >= 17; // medium/easy baseline
  }

  // Player lane incomplete: estimate and choose
  const target = estimatePlayerTargetForLane(idx, diff);

  if (diff === 'easy') {
    return (total >= 16 && Math.random() < 0.70) || total >= 19;
  }
  if (diff === 'medium') {
    if (total >= 17) return true;
    if (total >= 15 && total >= target + 2) return true;
    return false;
  }

  // hard
  if (total >= 19) return true;
  if (total >= 17 && total >= target + 1) return true;
  if (total >= 15 && total >= target + 3) return true;
  return false;
}

function dealerStandPhase(diff, maxPasses = 6) {
  let passes = 0;
  let changed = true;

  while (changed && passes++ < maxPasses) {
    changed = false;

    for (let i = 0; i < 5; i++) {
      const pos = blackjackMatch.dealerPositions[i];
      if (!pos.isOpen || pos.isComplete) continue;

      if (dealerShouldStandLane(i, diff)) {
        pos.isComplete = true;
        pos.isBust = (getPositionTotal(pos) > 21);
        blackjackMatch.metrics.dealerStands += 1;
        changed = true;

        if (!pos.isBust) {
          tryTempoStrike('dealer', i, 'stand');
        }

        // Keep 3 open lanes
        const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');
      }
    }
  }
}

    function dealerTurn() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      // 1) Strategic bench use (no forced plays; only if improves)
      const benchBudget = (diff === 'hard') ? 2 : (diff === 'medium') ? 1 : (Math.random() < 0.35 ? 1 : 0);
      for (let k = 0; k < benchBudget; k++) {
        const move = dealerFindBestBenchMove(diff, 'strategic');
        if (!move) break;
        dealerApplyBenchMod(move);
      }

      // 2) Standing decisions (dynamic)
      dealerStandPhase(diff);

      renderBlackjack();
      if (checkMatchEnd()) return;

      // 3) Draw + place one card (mods drawn become dealer bench)
      const openPositions = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (openPositions.length === 0) {
        endDealerTurn();
        return;
      }

      clearDealerTimers();
      dealerTimerB = setTimeout(() => {
        const card = dealerDrawPlayableCard();
        if (!card) {
          triggerDeckExhaustion('dealer', 'draw');
          return;
        }
        dealerPlaceOneCard(card);

        // 4) Salvage: if any lanes would bust at end-of-turn, try negatives first
        const salvageBudget = (diff === 'hard') ? 2 : 1;
        for (let k = 0; k < salvageBudget; k++) {
          const move = dealerFindBestBenchMove(diff, 'salvage');
          if (!move) break;
          dealerApplyBenchMod(move);
        }

        // Optional final stand pass (locks in “already winning” lanes)
        if (diff !== 'easy') dealerStandPhase(diff, 2);

        endDealerTurn();
      }, 600);
    }

    function endDealerTurn() {
      // Finalize busts at end of dealer turn
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');

      const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
      maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');

      if (checkMatchEnd()) return;

      blackjackMatch.turn = 'player';
      blackjackMatch.actionUsedThisTurn = false;
      blackjackMatch.actionSelectionInProgress = false;
      renderBlackjack();
    }


    function checkMatchEnd() {
      const playerDone = allPositionsComplete(blackjackMatch.playerPositions);
      const dealerDone = allPositionsComplete(blackjackMatch.dealerPositions);

      if (playerDone && dealerDone) {
        resolveMatch();
        return true;
      }

      if (playerDone && !dealerDone && blackjackMatch.turn === 'player') {
        blackjackMatch.turn = 'dealer';
        renderBlackjack();
        clearDealerTimers();
        dealerTimerA = setTimeout(dealerTurn, 800);
        return true;
      }

      return false;
    }

    function resolveMatch(options = {}) {
      blackjackMatch.phase = 'resolved';
      clearDealerTimers();

      // defensive finalize
      finalizeBusts(blackjackMatch.playerPositions, 'player');
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');

      let playerWins = 0;
      let dealerWins = 0;
      const positionResults = [];
      let transferNet = 0;

      const playerTotals = [];
      const dealerTotals = [];
      const playerBusts = [];
      const dealerBusts = [];

      for (let i = 0; i < 5; i++) {
        const pPos = blackjackMatch.playerPositions[i];
        const dPos = blackjackMatch.dealerPositions[i];

        const pTotal = getPositionTotal(pPos);
        const dTotal = getPositionTotal(dPos);
        const pBust = !!pPos.isBust;
        const dBust = !!dPos.isBust;

        playerTotals.push(pTotal);
        dealerTotals.push(dTotal);
        playerBusts.push(pBust);
        dealerBusts.push(dBust);

        let result;
        if (!pBust && (dBust || pTotal > dTotal)) {
          playerWins++;
          result = 'player';
        } else if (!dBust && (pBust || dTotal > pTotal)) {
          dealerWins++;
          result = 'dealer';
        } else {
          result = 'push';
        }
        positionResults.push(result);

        // Transfers
        if ((pBust && dBust) || (!pBust && !dBust && pTotal === dTotal)) continue;

        if (!pBust && dBust) transferNet += pTotal;
        else if (pBust && !dBust) transferNet -= dTotal;
        else if (!pBust && !dBust) {
          const diff = Math.abs(pTotal - dTotal);
          transferNet += (pTotal > dTotal) ? diff : -diff;
        }
      }

      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      transferNet *= transferMultiplier;

      let outcome;
      let payout;
      if (playerWins > dealerWins) {
        outcome = 'WIN';
        payout = blackjackMatch.buyIn * 2;
      } else if (dealerWins > playerWins) {
        outcome = 'LOSS';
        payout = 0;
      } else {
        outcome = 'TIE';
        payout = blackjackMatch.buyIn;
      }

      // Boss tie = loss
      if (blackjackMatch.type === 'BOSS' && outcome === 'TIE') {
        outcome = 'LOSS';
        payout = 0;
      }

      if (options && options.forcedOutcome) {
        outcome = options.forcedOutcome;
        if (outcome === 'WIN') payout = blackjackMatch.buyIn * 2;
        else if (outcome === 'LOSS') payout = 0;
        else payout = blackjackMatch.buyIn;
      }

      blackjackMatch.transferChipsNet = transferNet;

      let goldBonusTotal = 0;
      for (let i = 0; i < 5; i++) {
        const pPos = blackjackMatch.playerPositions[i];
        const hasGold = (pPos.cards || []).some(c => c && c.sleeveId === 'GOLD');
        if (hasGold) {
          const amount = safeNumber(playerTotals[i], 0);
          goldBonusTotal += amount;
          logEvent('GOLD_SLEEVE_BONUS', { laneIdx: i + 1, amount });
        }
      }
      if (goldBonusTotal > 0) {
        run.chips = safeNumber(run.chips) + goldBonusTotal;
        blackjackMatch.bonusChipsEarned += goldBonusTotal;
      }

      const laneKarmaDetails = [];
      let karmaLaneGain = 0;
      for (let i = 0; i < 5; i++) {
        const laneCards = blackjackMatch.playerPositions[i].cards || [];
        const base = safeNumber(playerTotals[i], 0);
        const laneSize = laneCards.length || 1;
        const stamps = [];

        if (positionResults[i] === 'player') {
          laneCards.forEach(card => {
            const stampId = getCardStampId(card);
            if (!stampId) return;
            const stampDef = getStampDef(stampId);
            const amount = getStampKarmaContribution(stampId, base, laneSize);
            stamps.push({ id: stampId, name: stampDef ? stampDef.name : stampId, amount });
          });
          const stampTotal = stamps.reduce((sum, s) => sum + s.amount, 0);
          karmaLaneGain += base + stampTotal;
        }

        laneKarmaDetails.push({
          base,
          stamps,
          mods: blackjackMatch.playerPositions[i].mods || [],
          winner: positionResults[i]
        });
      }
      let karmaWinBonus = 0;
      if (outcome === 'WIN') {
        const baseBonus = blackjackMatch.type === 'STANDARD' ? 50 : 100;
        karmaWinBonus = baseBonus * transferMultiplier;
      }
      const karmaGained = karmaLaneGain + karmaWinBonus;

      blackjackMatch.result = {
        outcome,
        payout,
        playerWins,
        dealerWins,
        positionResults,
        transferMultiplier,
        exhaustion: options.exhaustion || null,
        karmaGained
      };

      // finalize bust counts for match metrics
      blackjackMatch.metrics.playerBustsFinal = blackjackMatch.playerPositions.filter(p => p.isBust).length;
      blackjackMatch.metrics.dealerBustsFinal = blackjackMatch.dealerPositions.filter(p => p.isBust).length;

      const burnCards = [];
      blackjackMatch.playerPositions.forEach(pos => {
        (pos.cards || []).forEach(card => {
          if (getCardStampId(card) === 'BURN_AFTER_READING') burnCards.push(card);
        });
      });
      const burnedSleeves = blackjackMatch.burnedSleeveCards || [];
      if (burnCards.length || burnedSleeves.length) {
        const burnSet = new Set([...burnCards, ...burnedSleeves]);
        run.playerDeck = run.playerDeck.filter(card => !burnSet.has(card));
        recordDeckSnapshot('BURN_AFTER_READING');
      }
      if (burnCards.length) {
        logEvent('BURN_AFTER_READING', {
          count: burnCards.length,
          cards: burnCards.map(cardToString),
          cardUids: burnCards.map(card => card.uid || null),
          cardRefs: burnCards.map(cardRef)
        });
      }

      // House rake applies to positive net results (payout + transfer) only
const grossWin = payout + transferNet;
const rakeRate = getHouseRakeRate(run.floor);
const rake = (grossWin > 0 && rakeRate > 0) ? Math.floor(grossWin * rakeRate) : 0;

blackjackMatch.result.rake = rake;
blackjackMatch.result.rakeRate = rakeRate;

run.chips = safeNumber(run.chips) + payout + transferNet - rake;

      const durationMs = Math.round(performance.now() - blackjackMatch.metrics.startedAtMs);

      logEvent('MATCH_END', {
        type: blackjackMatch.type,
        outcome,
        matchSeq: blackjackMatch.matchSeq,
        buyIn: blackjackMatch.buyIn,
        payout,
        playerWins,
        dealerWins,
        transferNet,
        transferMultiplier,
        rake,
        rakeRate,
        bonusChips: blackjackMatch.bonusChipsEarned || 0,
        karmaGained,
        exhaustion: options.exhaustion || null,
        durationMs,
        lanes: {
          playerTotals, dealerTotals,
          playerBusts, dealerBusts,
          laneWinners: positionResults
        },
        metrics: { ...blackjackMatch.metrics },
        laneCards: blackjackMatch.metrics.laneCards,
        deckSnapshot: deckSnapshot()
      });

      if (blackjackMatch.result.outcome === 'WIN') {
        blackjackMatch.rewardPending = true;
      }

      blackjackMatch.scoreSeq = buildKarmaSequence(laneKarmaDetails, karmaWinBonus, outcome);
      startKarmaSequence();

      renderAll();

      if (transferNet !== 0) showToast(`Hand transfers: ${transferNet > 0 ? '+' : ''}${transferNet} chips`);

      // Winner reward flow (only if WIN)
      // handled after karma sequence finishes
    }

    // =============================================
    // KARMA SEQUENCE
    // =============================================
    function buildKarmaSequence(laneDetails, winBonus, outcome) {
      const steps = [];
      for (let i = 0; i < 5; i++) {
        const lane = laneDetails[i] || {};
        steps.push({
          label: `Lane ${i + 1}`,
          amount: 0,
          target: { type: 'lane', side: 'player', idx: i }
        });

        if (lane.winner === 'player') {
          steps.push({
            label: `Lane ${i + 1} base`,
            amount: lane.base || 0,
            target: { type: 'lane', side: 'player', idx: i }
          });

          if (lane.mods && lane.mods.length) {
            steps.push({
              label: `Lane ${i + 1} mods`,
              amount: 0,
              target: { type: 'mod', side: 'player', idx: i }
            });
          }

          (lane.stamps || []).forEach(stamp => {
            steps.push({
              label: `${stamp.name} stamp`,
              amount: stamp.amount || 0,
              target: { type: 'stamp', side: 'player', idx: i }
            });
          });
        } else {
          steps.push({
            label: `Lane ${i + 1} no karma`,
            amount: 0,
            target: { type: 'lane', side: 'player', idx: i }
          });
        }
      }

      if (outcome === 'WIN' && winBonus > 0) {
        steps.push({
          label: 'Win bonus',
          amount: winBonus,
          target: { type: 'result' }
        });
      }

      return {
        steps,
        idx: 0,
        running: true,
        runningTotal: 0,
        totalGained: steps.reduce((sum, step) => sum + safeNumber(step.amount, 0), 0),
        karmaBefore: safeNumber(run.karma, 0),
        laneKarma: laneDetails.reduce((sum, lane) => sum + ((lane.winner === 'player') ? safeNumber(lane.base, 0) + (lane.stamps || []).reduce((s, st) => s + safeNumber(st.amount, 0), 0) : 0), 0),
        winBonus: winBonus,
        activeTarget: null
      };
    }

    function startKarmaSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq) return;
      const seq = blackjackMatch.scoreSeq;
      if (!seq.steps.length) {
        finalizeKarmaSequence();
        return;
      }
      runKarmaStep();
    }

    function runKarmaStep() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq) return;
      const seq = blackjackMatch.scoreSeq;
      if (!seq.running) return;

      if (seq.idx >= seq.steps.length) {
        finalizeKarmaSequence();
        return;
      }

      const step = seq.steps[seq.idx];
      seq.activeTarget = step.target || null;

      if (step.amount) {
        run.karma = Math.max(0, safeNumber(run.karma, 0) + step.amount);
        seq.runningTotal += step.amount;
      }

      seq.idx += 1;
      renderAll();
      const delay = step.amount ? 650 : 400;
      karmaSeqTimer = setTimeout(runKarmaStep, delay);
    }

    function finalizeKarmaSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq) return;
      const seq = blackjackMatch.scoreSeq;
      seq.running = false;
      seq.activeTarget = null;
      run.karma = Math.max(0, seq.karmaBefore + seq.runningTotal);
      renderAll();
      maybeLevelUpCallingCardFromKarma();

      if (seq.totalGained > 0) {
        logEvent('KARMA_GAIN', { amount: seq.totalGained, total: run.karma, laneKarma: seq.laneKarma, winBonus: seq.winBonus });
      }

      if (blackjackMatch.result && blackjackMatch.result.outcome === 'WIN' && blackjackMatch.rewardPending && !blackjackMatch.winnerReward) {
        startWinnerRewardFlow();
      }
    }

    // =============================================
    // WINNER REWARD FLOW (after a WIN)
    // =============================================
    function startWinnerRewardFlow() {
      if (blackjackMatch.type === 'BOSS') {
        startBossFusionRewardFlow();
        return;
      }
      blackjackMatch.winnerReward = { stage: 'mode', mode: null, candidates: [], selected: null };
      showWinnerRewardModeModal();
    }

    function startBossFusionRewardFlow() {
      blackjackMatch.winnerReward = { stage: 'pick', mode: 'fuse', candidates: [], selected: [] };
      const eligible = run.playerDeck
        .map((c, i) => ({ card: c, index: i }))
        .filter(d => isStandardCard(d.card));

      const picks = shuffle(eligible).slice(0, 5);
      blackjackMatch.winnerReward.candidates = picks;
      blackjackMatch.winnerReward.selected = [];

      showBossFusionModal();
    }

    function showBossFusionModal() {
      const wr = blackjackMatch.winnerReward;
      const candidates = wr.candidates || [];
      const selected = wr.selected || [];
      const canFuse = candidates.length >= 2;

      const body = `
        <p class="modal-text">Boss reward: pick two cards to fuse (or choose none).</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected.includes(idx) ? 'selected' : '';
              return `
                <div class="removal-card-option ${sel}" onclick="selectFusionCard(${idx})">
                  ${renderCard(d.card, false)}
                </div>
              `;
            }).join('')}
          </div>
        </div>
        ${canFuse ? '' : '<p class="modal-text" style="color:var(--text-muted); text-align:center;">Not enough eligible cards to fuse.</p>'}
      `;

      showModal('Fuse Cards', body, [
        { text: 'Confirm Fusion', primary: true, disabled: !canFuse || selected.length !== 2, action: confirmFusionReward },
        { text: 'Choose None', action: () => finishFusionReward(null) }
      ]);
    }

    window.selectFusionCard = function(idx) {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      const selected = wr.selected || [];
      if (selected.includes(idx)) {
        wr.selected = selected.filter(i => i !== idx);
      } else if (selected.length < 2) {
        wr.selected = [...selected, idx];
      }
      showBossFusionModal();
    };

    function confirmFusionReward() {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      if (!wr.selected || wr.selected.length !== 2) return;
      const picks = wr.selected.map(i => wr.candidates[i]).filter(Boolean);
      if (picks.length !== 2) return;
      finishFusionReward(picks);
    }

    function finishFusionReward(picks) {
      if (!blackjackMatch) return;
      if (picks && picks.length === 2) {
        const [a, b] = picks;
        const sorted = [a.index, b.index].sort((x, y) => y - x);
        const cardA = run.playerDeck[a.index];
        const cardB = run.playerDeck[b.index];
        sorted.forEach(idx => run.playerDeck.splice(idx, 1));
        const fused = { uid: null, type: 'FUSE', a: cardA, b: cardB };
        assignUid(fused);
        run.playerDeck.push(fused);
        logEvent('WINNER_REWARD_FUSE', {
          cards: [cardToString(cardA), cardToString(cardB)],
          cardUids: [cardA?.uid || null, cardB?.uid || null],
          cardRefs: [cardRef(cardA), cardRef(cardB)],
          fused: `${cardToString(cardA)}/${cardToString(cardB)}`,
          deckSnapshot: deckSnapshot()
        });
        recordDeckSnapshot('REWARD_FUSE');
        showToast(`Fused ${cardToString(cardA)} + ${cardToString(cardB)}`);
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: 'fuse' });
        showToast('Fusion skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;
      closeModal();
      renderAll();
    }

    function showWinnerRewardModeModal() {
      showModal('Winner Reward', `
        <p class="modal-text">You won the match. Choose a deck reward:</p>
        <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:12px;">
          <button class="modal-btn danger" onclick="chooseWinnerRewardMode('remove')">Remove</button>
          <button class="modal-btn" onclick="chooseWinnerRewardMode('duplicate')">Duplicate</button>
        </div>
        <p class="modal-text" style="margin-top:14px; color:var(--text-muted); text-align:center;">You will see 5 random cards and may pick one or choose none.</p>
      `, [
        { text: 'Skip', action: () => { finishWinnerReward(null, null); } }
      ]);
    }

    window.chooseWinnerRewardMode = function(mode) {
      if (!blackjackMatch || blackjackMatch.phase !== 'resolved') return;
      blackjackMatch.winnerReward.mode = mode;
      blackjackMatch.winnerReward.stage = 'pick';

      const idxs = distinctRandomIndices(5, run.playerDeck.length);
      blackjackMatch.winnerReward.candidates = idxs.map(i => ({ index: i, card: run.playerDeck[i] }));
      blackjackMatch.winnerReward.selected = null;

      logEvent('WINNER_REWARD_MODE', { mode });

      showWinnerRewardPickModal();
    };

    function showWinnerRewardPickModal() {
      const wr = blackjackMatch.winnerReward;
      const mode = wr.mode;

      const title = mode === 'remove' ? 'Remove a Card' : 'Duplicate a Card';
      const sub = mode === 'remove'
        ? 'Select a card to remove (one copy).'
        : 'Select a card to duplicate (add one copy).';

      const candidates = wr.candidates;
      const selected = wr.selected;

      const body = `
        <p class="modal-text">${sub}</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected === idx ? 'selected' : '';
            return `
              <div class="removal-card-option ${sel}" onclick="selectWinnerRewardCard(${idx})">
                  ${renderCard(d.card, false)}
              </div>
            `;
            }).join('')}
          </div>
        </div>
      `;

      showModal(title, body, [
        { text: 'Confirm', primary: true, disabled: selected === null, action: confirmWinnerReward },
        { text: 'Choose None', action: () => finishWinnerReward(mode, null) }
      ]);
    }

    window.selectWinnerRewardCard = function(idx) {
      blackjackMatch.winnerReward.selected = idx;
      showWinnerRewardPickModal();
    };

    function confirmWinnerReward() {
      const wr = blackjackMatch.winnerReward;
      if (wr.selected === null) return;
      const d = wr.candidates[wr.selected];
      finishWinnerReward(wr.mode, d);
    }

    function finishWinnerReward(mode, pickData) {
      if (!blackjackMatch) return;

      if (mode && pickData) {
        if (mode === 'remove') {
          const removed = run.playerDeck[pickData.index];
          run.playerDeck.splice(pickData.index, 1);
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(removed), cardUid: removed?.uid || null, cardRef: cardRef(removed), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_REMOVE');
          showToast(`Removed ${cardToString(removed)}`);
        } else if (mode === 'duplicate') {
          const c = run.playerDeck[pickData.index];
          if (c) {
            const clone = cloneCardWithNewUid(c);
            assignUid(clone);
            run.playerDeck.push(clone);
          }
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(c), cardUid: c?.uid || null, cardRef: cardRef(c), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_DUPLICATE');
          showToast(`Duplicated ${cardToString(c)}`);
        }
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: mode || null });
        showToast('Reward skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;

      closeModal();
      renderAll();
    }

    // =============================================
    // ACTION TOKENS + ACTION PICKER
    // =============================================
    function isPlayerActionContextOK(m) {
      return !!m && m.phase === 'playing' && m.turn === 'player';
    }

    function tokensRemaining() {
      if (!blackjackMatch) return 0;
      return Math.max(0, (blackjackMatch.tokensTotal || 0) - (blackjackMatch.tokensSpent || 0));
    }

    function canClickToken() {
      if (!blackjackMatch) return false;
      if (!isPlayerActionContextOK(blackjackMatch)) return false;
      if (blackjackMatch.actionUsedThisTurn) return false;
      if (blackjackMatch.actionSelectionInProgress) return false;
      if (tokensRemaining() <= 0) return false;
      if (!run.ownedActions || run.ownedActions.length === 0) return false;
      if (blackjackMatch.drawnCard) return false;
      return true;
    }

    window.onActionTokenClick = function() {
      if (!canClickToken()) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'ACTION_PICKER' });

      renderBlackjack();
      openActionPickerModal();
    };

    window.useActionFromBar = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (!run.ownedActions || !run.ownedActions.includes(actionId)) return;

      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.actionSelectionInProgress) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (blackjackMatch.usedActions && blackjackMatch.usedActions[actionId]) return;

      if (tokensRemaining() <= 0) { showToast('No tokens left'); return; }
      if (def.isUsable && !def.isUsable(blackjackMatch)) { showToast('Action unavailable'); return; }

      blackjackMatch.tokensSpent = safeNumber(blackjackMatch.tokensSpent, 0) + 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'COCKTAIL', actionId, via: 'ACTION_BAR' });
      renderAll();

      try { def.activate(); }
      catch (e) {
        blackjackMatch.actionSelectionInProgress = false;
        renderAll();
        console.error(e);
        showToast('Action failed');
      }
    };

    function openActionPickerModal() {
      const owned = run.ownedActions || [];
      const used = blackjackMatch.usedActions || {};

      const listHtml = owned.map(id => {
        const def = ACTIONS[id];
        const alreadyUsed = !!used[id];
        const usable = def && def.isUsable(blackjackMatch);
        const disabled = alreadyUsed || !usable;

        const statusText = alreadyUsed ? 'USED' : (!usable ? 'UNAVAILABLE' : 'READY');
        const statusColor = alreadyUsed ? 'var(--text-muted)' : (!usable ? 'var(--accent-red)' : 'var(--accent-green)');

        return `
          <div class="action-row ${disabled ? 'disabled' : ''}">
            <div class="action-row-left">
              <div class="action-row-title">${def ? def.name : id}</div>
              <div class="action-row-desc">${def ? def.desc : ''}</div>
              <div class="action-row-desc" style="margin-top:6px; color:${statusColor}; font-weight:800;">${statusText}</div>
            </div>
            <div class="action-row-right">
              <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="attemptUseAction('${id}')">Use</button>
            </div>
          </div>
        `;
      }).join('');

      const body = `
        <p class="modal-text">Choose one action to perform. This selection consumes your token even if you cancel.</p>
        <div class="action-list">${listHtml || '<p class="modal-text">No actions unlocked.</p>'}</div>
      `;

      showModal('Actions', body, [
        {
          text: 'Cancel',
          action: () => {
            blackjackMatch.actionSelectionInProgress = false;
            closeModal();
            renderAll();
          }
        }
      ]);
    }

    window.attemptUseAction = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing' || blackjackMatch.turn !== 'player') return;
      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.usedActions[actionId]) {
        showToast('Already used this match');
        return;
      }
      if (!def.isUsable(blackjackMatch)) {
        showToast('Not usable right now');
        return;
      }

      def.activate();
    };

    function markActionUsed(actionId) {
      blackjackMatch.usedActions[actionId] = true;
      blackjackMatch.actionSelectionInProgress = false;

      blackjackMatch.metrics.actionsUsed += 1;

      const def = ACTIONS[actionId];
      logEvent('ACTION_USED', {
        actionId,
        actionName: def ? def.name : actionId,
        tokensRemaining: tokensRemaining()
      });
    }

    // =============================================
    // ACTION IMPLEMENTATIONS
    // =============================================
    function drawPlayableToHandOrBench() {
      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'action-draw');
          return null;
        }
        if (isModifier(c)) {
          benchPush(c, 'action-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          continue;
        }
        return c;
      }
      return null;
    }

    function pickDealerLaneModal(title, text, onPick) {
      const options = blackjackMatch.dealerPositions
        .map((p, i) => ({ p, i }))
        .filter(x => x.p.isOpen && !x.p.isComplete);

      if (!options.length) {
        showToast('No valid lanes');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      const btns = options.map(o => ({
        text: `Lane #${o.i + 1}`,
        action: () => onPick(o.i)
      }));

      btns.push({
        text: 'Cancel',
        action: () => {
          blackjackMatch.actionSelectionInProgress = false;
          closeModal();
          renderAll();
        }
      });

      showModal(title, `<p class="modal-text">${text}</p>`, btns);
    }

    function pickPlayerRevivalLaneModal(title, text, eligible, onPick) {
      const btns = eligible.map(i => ({
        text: `Lane #${i + 1}`,
        action: () => onPick(i)
      }));
      btns.push({
        text: 'Cancel',
        action: () => {
          blackjackMatch.actionSelectionInProgress = false;
          closeModal();
          renderAll();
        }
      });

      showModal(title, `<p class="modal-text">${text}</p>`, btns);
    }

    // Eligible revival lanes: any "closed" = isOpen && isComplete (stood OR busted)
    function getEligibleRevivalLanes(m) {
      const eligible = [];
      for (let i = 0; i < 5; i++) {
        const p = m.playerPositions[i];
        if (p && p.isOpen && p.isComplete) eligible.push(i);
      }
      return eligible;
    }

    // Split Decision
    function activateSplitDecision() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      showModal('Split Decision', `
        <p class="modal-text">Choose a card to play. The other card will be played by the Dealer immediately after your placement.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSplitDecision(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSplitDecision(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        { text: 'Cancel', action: () => { blackjackMatch.actionSelectionInProgress = false; closeModal(); renderAll(); } }
      ]);

      window.chooseSplitDecision = function(choiceIdx) {
        const playerCard = choiceIdx === 0 ? a : b;
        const dealerCard = choiceIdx === 0 ? b : a;

        blackjackMatch.drawnCard = playerCard;
        blackjackMatch.pending = { type: 'splitDecision', dealerGiftCard: dealerCard };

        markActionUsed('splitDecision');
        closeModal();
        renderAll();
        showToast('Place your chosen card');
      };
    }

    // Second Opinion
    function activateSecondOpinion() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      showModal('Second Opinion', `
        <p class="modal-text">Choose a card to play. The other will be discarded.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSecondOpinion(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSecondOpinion(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        { text: 'Cancel', action: () => { blackjackMatch.actionSelectionInProgress = false; closeModal(); renderAll(); } }
      ]);

      window.chooseSecondOpinion = function(choiceIdx) {
        const chosen = choiceIdx === 0 ? a : b;
        blackjackMatch.drawnCard = chosen;

        markActionUsed('secondOpinion');
        closeModal();
        renderAll();
        showToast('Place your chosen card');
      };
    }

    // Benched (ends turn)
    function activateBenched() {
      const c = drawPlayableToHandOrBench();
      if (!c) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }
      benchPush(c, 'action-benched');

      markActionUsed('benched');
      closeModal();
      renderAll();
      showToast(`Benched ${cardToString(c)}`);
      endPlayerTurn();
    }

    // Spy Glass
    function activateSpyGlass() {
      pickDealerLaneModal('Spy Glass', 'Choose a Dealer lane to reveal.', (idx) => {
        blackjackMatch.spyReveals.add(idx);
        markActionUsed('spyGlass');
        closeModal();
        renderAll();
        showToast(`Revealed Dealer lane #${idx + 1}`);
      });
    }

    // Forced Play
    function activateForcedPlay() {
      pickDealerLaneModal('Forced Play', 'Choose a Dealer lane. The Dealer\'s next placed card must go there if still valid.', (idx) => {
        blackjackMatch.dealerForcedLane = idx;
        markActionUsed('forcedPlay');
        closeModal();
        renderAll();
        showToast(`Forced next Dealer play into lane #${idx + 1}`);
      });
    }

    // Revival
    function activateRevival() {
      const eligible = getEligibleRevivalLanes(blackjackMatch);
      pickPlayerRevivalLaneModal(
        'Revival',
        'Choose any of your closed lanes (stood or busted) to reopen.',
        eligible,
        (idx) => {
          const pos = blackjackMatch.playerPositions[idx];
          pos.isComplete = false;
          pos.isBust = false;
          markActionUsed('revival');
          closeModal();
          renderAll();
          showToast(`Reopened lane #${idx + 1}`);
        }
      );
    }

    // Find My Card (ends turn)
    function activateFindMyCard() {
      const pile = blackjackMatch.playerDrawPile;
      const scanN = Math.min(10, pile.length);
      let foundIndexFromEnd = -1;

      for (let k = 0; k < scanN; k++) {
        const idx = pile.length - 1 - k;
        const c = pile[idx];
        if (isModifier(c)) { foundIndexFromEnd = idx; break; }
      }

      if (foundIndexFromEnd >= 0) {
        const mod = pile.splice(foundIndexFromEnd, 1)[0];
        benchPush(mod, 'action-findMyCard');
        blackjackMatch.metrics.modifiersBenched += 1;
        showToast(`Found ${cardToString(mod)} (benched)`);
      } else {
        showToast('No modifier found');
      }

      markActionUsed('findMyCard');
      closeModal();
      renderAll();
      endPlayerTurn();
    }

    // Closer
    function activateCloser() {
      pickDealerLaneModal('Closer', 'Choose a Dealer lane to close immediately.', (idx) => {
        const pos = blackjackMatch.dealerPositions[idx];
        pos.isComplete = true;
        pos.isBust = getPositionTotal(pos) > 21;
        blackjackMatch.metrics.dealerStands += 1;

        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, makeStandardDeck52(), 'dealer');

        markActionUsed('closer');
        closeModal();
        renderAll();
        showToast(`Closed Dealer lane #${idx + 1}`);
      });
    }

    // =============================================
    // CONTINUE / END CONDITIONS
    // =============================================
    window.blackjackContinue = function() {
      clearDealerTimers();

      if (blackjackMatch.rewardPending) {
        showToast('Resolve winner reward first');
        return;
      }

      const result = blackjackMatch.result;

      if (blackjackMatch.type === 'BOSS') {
        if (result.outcome === 'WIN') {
          run.bossWins = safeNumber(run.bossWins, 0) + 1;
          logEvent('BOSS_CLEARED', { floor: run.floor, bossWins: run.bossWins, benchCapacity: getBenchCapacity() });
          showToast(`Boss cleared. Bench capacity is now ${getBenchCapacity()}.`);
          if (run.floor < 3) {
            blackjackMatch = null;
            initFloor(run.floor + 1);
            showToast(`Floor ${run.floor} begins!`);
          } else {
            victory();
          }
        } else {
          gameOver("You lost to the boss.");
        }
      } else {
        blackjackMatch = null;
        run.ui.mode = 'BOARD';
        renderAll();
      }
    };

    function gameOver(message) {
      clearDealerTimers();
      run.ui.mode = 'GAMEOVER';
      run.ui.message = message;
      logEvent('GAME_END', { result: 'GAMEOVER', message });
      finalizeRunLog({ outcome: 'loss', message });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    function victory() {
      clearDealerTimers();
      run.ui.mode = 'VICTORY';
      logEvent('GAME_END', { result: 'VICTORY' });
      finalizeRunLog({ outcome: 'win', message: null });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    // =============================================
    // UI RENDERING
    // =============================================
    function renderAll() {
      renderHUD();
      renderBoard();
      renderBlackjack();
      renderEndScreen();
    }

    function renderHUD() {
      const hud = document.getElementById('hud');
      const chips = safeNumber(run.chips, 0);
      const playerName = run.playerName ? escapeHtml(run.playerName) : '';

      const loanStatus = run.loan.active ? (run.loan.repaid ? 'Repaid' : `Owed: ${LOAN_REPAY}`) : 'None';
      const loanClass = run.loan.active && !run.loan.repaid ? 'debt' : '';
      const canRepay = run.loan.active && !run.loan.repaid && chips >= LOAN_REPAY;

      hud.innerHTML = `
        <div class="hud-left">
          ${playerName ? `
          <div class="hud-stat">
            <span class="hud-stat-label">Player</span>
            <span class="hud-stat-value">${playerName}</span>
          </div>
          ` : ''}
          <div class="hud-stat">
            <span class="hud-stat-label">Floor</span>
            <span class="hud-stat-value">${run.floor}/3</span>
          </div>
          <div class="hud-stat">
            <span class="hud-stat-label">Chips</span>
            <span class="hud-stat-value chips">${chips}</span>
          </div>
          <div class="hud-stat">
            <span class="hud-stat-label">Karma</span>
            <span class="hud-stat-value karma">${safeNumber(run.karma, 0)}</span>
          </div>
          <div class="hud-stat">
            <span class="hud-stat-label">Calling</span>
            <span class="hud-stat-value">${run.callingCard ? cardToString(run.callingCard) : '—'}</span>
          </div>
          <div class="hud-stat">
            <span class="hud-stat-label">Deck</span>
            <span class="hud-stat-value">${run.playerDeck.length}</span>
          </div>
          <div class="hud-stat">
            <span class="hud-stat-label">Tokens</span>
            <span class="hud-stat-value tokens">${run.bankedTokens || 0}</span>
          </div>
<div class="hud-stat">
  <span class="hud-stat-label">Bench</span>
  <span class="hud-stat-value">${getBenchCapacity()}</span>
</div>
<div class="hud-stat">
  <span class="hud-stat-label">Rake</span>
  <span class="hud-stat-value">${Math.round(getHouseRakeRate(run.floor) * 100)}%</span>
</div>
          <div class="hud-stat">
            <span class="hud-stat-label">Debt</span>
            <span class="hud-stat-value ${loanClass}">${loanStatus}</span>
          </div>
        </div>

        <div class="hud-center">
          <button class="hud-icon-btn" title="Run Log" onclick="openLogPanel('stats')">📋</button>
          <button class="hud-icon-btn" title="Deck Viewer" onclick="openDeckViewer()">🃏</button>
          <button class="hud-icon-btn" title="Settings" onclick="openSettingsPanel()">⚙️</button>
          <button class="hud-icon-btn" title="Feedback" onclick="openFeedbackModal()">📝</button>
          <button class="hud-icon-btn" title="Rules" onclick="openRulesPanel()">📖</button>
        </div>

        <div class="hud-right">
          ${run.loan.active && !run.loan.repaid ? `
            <button class="hud-btn success" ${canRepay ? '' : 'disabled'} onclick="repayLoan()">Repay ${LOAN_REPAY}</button>
          ` : ''}
          <button class="hud-btn danger" onclick="confirmReset()">Reset Run</button>
        </div>
      `;
    }

    window.repayLoan = function() {
      const chips = safeNumber(run.chips);
      if (!run.loan.active || run.loan.repaid || chips < LOAN_REPAY) return;
      run.chips = chips - LOAN_REPAY;
      run.loan.repaid = true;
      logEvent('LOAN_REPAID', { amount: LOAN_REPAY });
      renderAll();
      showToast('Debt repaid!');
    };

    window.confirmReset = function() {
      showConfirmDialog('Are you sure you want to reset your run?', () => {
        initRun();
        showToast('New run started!');
      });
    };

    function renderBoard() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BOARD') {
        boardView.classList.add('hidden');
        return;
      }

      boardView.classList.remove('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.add('hidden');

      const available = getAvailableMoves();
      const isStarting = run.board.currentTileId === null;

      const instructions = isStarting
        ? 'Choose a starting tile from the bottom row'
        : 'Move to an available tile (gold outline)';

      let svg = `<svg id="boardSvg" viewBox="0 0 400 460" width="400" height="460">`;

      if (run.board.path.length > 1) {
        const pathPoints = run.board.path.map(id => run.board.tiles[id].center.join(',')).join(' ');
        svg += `<polyline class="path-line" points="${pathPoints}"/>`;
      }

      for (const tile of run.board.tiles) {
        const isVisited = run.board.visited.has(tile.id);
        const isCurrent = run.board.currentTileId === tile.id;
        const isAvailable = available.includes(tile.id);

        let tileClass = 'hex-tile';
        if (isVisited) tileClass += ' visited';
        if (isCurrent) tileClass += ' current';
        if (isAvailable) tileClass += ' available';

        const clickHandler = isAvailable ? `onclick="onTileClick(${tile.id})"` : '';
        let subLabel = '';
        if (tile.npc && tile.npc.callingCard) {
          const calling = `${tile.npc.callingCard.rank}${tile.npc.callingCard.suit}`;
          const affinity = run.callingCard ? getAffinity(run.callingCard.suit, tile.npc.callingCard.suit) : null;
          const affIcon = affinity ? ` ${affinityIcon(affinity)}` : '';
          subLabel = `<text class="hex-sub" x="${tile.center[0]}" y="${tile.center[1] + 12}">${calling}${affIcon}</text>`;
        }

        svg += `
          <g class="${tileClass}" ${clickHandler}>
            <path class="hex-bg" d="${tile.svgPath}" fill="${tile.color}" stroke="#1a2436" stroke-width="2"/>
            <text class="hex-label" x="${tile.center[0]}" y="${tile.center[1]}">${tile.label}</text>
            ${subLabel}
          </g>
        `;
      }

      svg += '</svg>';

      boardView.innerHTML = `
        <div class="board-instructions">${instructions}</div>
        ${svg}
      `;
    }

    window.onTileClick = function(tileId) {
      const available = getAvailableMoves();
      if (available.includes(tileId)) enterTile(tileId);
    };

    function renderCard(card, faceDown=false, extraClass='') {
      const cls = ['playing-card', extraClass, faceDown ? 'face-down' : cardCssClass(card)].filter(Boolean).join(' ');
      const text = faceDown ? '' : cardToString(card);
      const stampId = !faceDown ? getCardStampId(card) : null;
      const stampDef = stampId ? getStampDef(stampId) : null;
      const sleeveId = !faceDown && card ? card.sleeveId : null;
      const dataAttrs = [
        `data-card-label="${text}"`,
        `data-card-type="${isModifier(card) ? 'MOD' : (isFused(card) ? 'FUSE' : 'STANDARD')}"`,
        card && card.rank ? `data-card-rank="${card.rank}"` : '',
        card && card.suit ? `data-card-suit="${card.suit}"` : '',
        stampId ? `data-card-stamp="${stampId}"` : '',
        sleeveId ? `data-card-sleeve="${sleeveId}"` : ''
      ].filter(Boolean).join(' ');
      const stampIcon = (stampDef && stampDef.icon) ? `<div class="stamp-icon">${stampDef.icon}</div>` : '';
      return `<div class="${cls}" ${dataAttrs}>${text}${stampIcon}</div>`;
    }

    function setupCardTooltip() {
      const tooltip = document.getElementById('cardTooltip');
      if (!tooltip) return;

      let activeCard = null;
      let longPressTimer = null;

      const buildTooltipHtml = (cardEl) => {
        const ds = cardEl.dataset || {};
        const label = ds.cardLabel || 'Card';
        const type = ds.cardType || '';
        const stamp = ds.cardStamp ? getStampDef(ds.cardStamp) : null;
        const sleeve = ds.cardSleeve ? getSleeveDef(ds.cardSleeve) : null;
        const lines = [];

        if (type && type !== 'STANDARD') lines.push(`${type} card`);
        if (stamp) lines.push(`Stamp: ${stamp.name} — ${stamp.desc}`);
        if (sleeve) lines.push(`Sleeve: ${sleeve.name} — ${sleeve.desc}`);

        return `
          <div class="tooltip-title">${label}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const buildActionTooltipHtml = (el) => {
        const ds = el.dataset || {};
        const title = ds.ttTitle || '';
        const rawLines = ds.ttLines || '';
        const lines = rawLines.split('|').map(l => l.trim()).filter(Boolean);
        return `
          <div class="tooltip-title">${title}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (el, x, y) => {
        if (!el || !el.dataset) return;
        if (el.dataset.cardLabel) {
          tooltip.innerHTML = buildTooltipHtml(el);
        } else if (el.dataset.ttTitle) {
          tooltip.innerHTML = buildActionTooltipHtml(el);
        } else {
          return;
        }
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeCard = el;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeCard = null;
      };

      document.addEventListener('mouseover', (e) => {
        const actionEl = e.target.closest('[data-tt-title]');
        if (actionEl) {
          showTooltip(actionEl, e.clientX, e.clientY);
          return;
        }
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        showTooltip(cardEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (activeCard && !e.relatedTarget?.closest('.playing-card') && !e.relatedTarget?.closest('[data-tt-title]')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!activeCard) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        const actionEl = e.target.closest('[data-tt-title]');
        if (actionEl) {
          longPressTimer = setTimeout(() => showTooltip(actionEl, e.clientX, e.clientY), 450);
          return;
        }
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        longPressTimer = setTimeout(() => showTooltip(cardEl, e.clientX, e.clientY), 450);
      });

      document.addEventListener('pointerup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('pointercancel', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.playing-card') && !e.target.closest('[data-tt-title]')) hideTooltip();
      });
    }

    function posState(pos) {
      if (!pos.isOpen) return 'closed';
      if (pos.isComplete) return pos.isBust ? 'bust' : 'stand';
      return 'open';
    }

    function stateBadge(state) {
      return `<div class="bj-state ${state}">${state}</div>`;
    }

    function renderPosition(pos, idx, side, isResolved, laneWinner) {
  const state = posState(pos);
  const total = getPositionTotal(pos);
  const activeTarget = blackjackMatch && blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.activeTarget;
  const pulseLane = activeTarget && activeTarget.type === 'lane' && activeTarget.side === side && activeTarget.idx === idx;
  const pulseMod = activeTarget && activeTarget.type === 'mod' && activeTarget.side === side && activeTarget.idx === idx;
  const pulseStamp = activeTarget && activeTarget.type === 'stamp' && activeTarget.side === side && activeTarget.idx === idx;

  // Spy Glass should always override visibility for that lane
  const spy = (side === 'dealer')
    && blackjackMatch
    && blackjackMatch.spyReveals
    && blackjackMatch.spyReveals.has(idx);
  const spadeReveal = (side === 'dealer')
    && blackjackMatch
    && blackjackMatch.spadePeekLanes
    && blackjackMatch.spadePeekLanes.has(idx);

  // NEW: totals + hole-card reveal behavior for dealer
  // - if revealTotalsOnClose: reveal when lane closes (stood/bust)
  // - else: reveal only when match resolves
  const revealTotalsOnClose = (uiSettings && uiSettings.revealTotalsOnClose) !== false;
  const showDealerTotal = spy || spadeReveal || isResolved || (revealTotalsOnClose && pos.isComplete);

  const showTotal = (side === 'player') ? true : showDealerTotal;
  const canReveal = (side === 'player') ? true : showDealerTotal;
  const totalText = showTotal ? `${total}` : '??';
  const totalBustVisual = canReveal && total > 21 ? 'bust' : '';

  // Hole card reveals when we reveal totals (or via spy, or on match resolve)
  const revealHole = (side === 'dealer') ? showDealerTotal : true;

  const displayState = (state === 'bust' && !canReveal) ? 'stand' : state;
  let cls = `bj-position ${displayState}`;
  if (displayState === 'open') cls += ' open';
  if (displayState === 'stand') cls += ' stand';
  if (displayState === 'bust') cls += ' bust';
  if (displayState === 'closed') cls += ' closed';
  if (pulseLane) cls += ' karma-pulse';

  if (isResolved) {
    if (laneWinner === side) cls += ' winner';
  }

  // NEW: Dealer cards: first card face-down unless revealed; others face-up
  const cardsHtml = (pos.cards || []).map((c, j) => {
    if (side === 'dealer') {
      const faceDown = (j === 0) && !revealHole;
      return renderCard(c, faceDown);
    }
    return renderCard(c, false);
  }).join('');

  const mods = (pos.mods || []);
  const trapDelta = (!pos.isOpen && blackjackMatch && blackjackMatch.traps) ? blackjackMatch.traps[side][idx] : 0;
  const displayMods = mods.length ? mods : (trapDelta ? [trapDelta] : []);
  const modsText = displayMods.length ? displayMods.map(m => (m > 0 ? `+${m}` : `${m}`)).join(' ') : '';
  const modsLineClass = pulseMod ? 'bj-position-num karma-pulse' : 'bj-position-num';
  const modsLine = displayMods.length
    ? `<div class="${modsLineClass}" style="color: var(--accent-blue); font-weight:800;">MOD: ${modsText}</div>`
    : `<div class="${modsLineClass}">MOD: —</div>`;

  return `
    <div class="${cls}">
      <div class="bj-position-num">${side.toUpperCase()} #${idx+1}</div>
      <div class="bj-cards ${pulseStamp ? 'karma-pulse' : ''}">${cardsHtml}</div>
      <div class="bj-total ${totalBustVisual}">${totalText}</div>
      ${stateBadge(displayState)}
      ${modsLine}
      <div id="${side}_lane_actions_${idx}" style="display:flex; gap:6px; flex-wrap:wrap; justify-content:center;"></div>
    </div>
  `;
}


    function renderBlackjack() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BLACKJACK' || !blackjackMatch) {
        blackjackView.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.remove('hidden');
      endScreen.classList.add('hidden');

      const isResolved = blackjackMatch.phase === 'resolved';
      const result = blackjackMatch.result;
      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      const npc = blackjackMatch.npc;
      const affinity = blackjackMatch.affinity || 'neutral';
      const edgeDelta = blackjackMatch.edgeDelta || 0;
      const procPct = Math.round((blackjackMatch.callingProcChance || CALLING_PROC_CHANCE) * 100);
      const npcLine = npc
        ? `${npc.name} · ${cardToString(npc.callingCard)} · ${affinityIcon(affinity)} · Edge ${edgeDelta >= 0 ? '+' : ''}${edgeDelta} · Proc ${procPct}%`
        : `Dealer · Proc ${procPct}%`;

      const typeLabel = blackjackMatch.type === 'BOSS' ? 'BOSS BATTLE' :
                        blackjackMatch.type === 'HIGH_STAKES' ? 'HIGH STAKES' : 'STANDARD TABLE';

      let html = `
        <div class="bj-header">
          <div class="bj-title">${typeLabel}</div>
          <div class="bj-status">Buy-in: ${blackjackMatch.buyIn} chips · Transfer x${transferMultiplier}</div>
          <div class="bj-status">${npcLine}</div>
        </div>
      `;

      // Dealer + Player positions
      const laneWinners = (isResolved && result) ? result.positionResults : ['push','push','push','push','push'];

      html += `
        <div class="bj-board">
          <div class="bj-side">
            <div class="bj-side-label">${npc ? `${npc.name} · ${cardToString(npc.callingCard)}` : 'Dealer'}</div>
            <div class="bj-positions">
              ${blackjackMatch.dealerPositions.map((p, i) => renderPosition(p, i, 'dealer', isResolved, laneWinners[i])).join('')}
            </div>
          </div>

          <div class="bj-side">
            <div class="bj-side-label">Player</div>
            <div class="bj-positions">
              ${blackjackMatch.playerPositions.map((p, i) => renderPosition(p, i, 'player', isResolved, laneWinners[i])).join('')}
            </div>
          </div>
        </div>
      `;

      // Controls / Result section
      if (isResolved && result) {
        const outcome = result.outcome;
        const titleCls = outcome === 'WIN' ? 'win' : (outcome === 'LOSS' ? 'lose' : 'tie');
        const seq = blackjackMatch.scoreSeq;
        const resultPulse = seq && seq.activeTarget && seq.activeTarget.type === 'result' ? ' karma-pulse' : '';

        const transfer = blackjackMatch.transferChipsNet || 0;
        const bonus = blackjackMatch.bonusChipsEarned || 0;
        const payout = result.payout || 0;
        const rake = (result && result.rake) ? result.rake : 0;
        const rakeRate = (result && result.rakeRate) ? result.rakeRate : 0;

        const netFromEnd = payout + transfer - rake + bonus; // buy-in already paid earlier
        const netCls = netFromEnd > 0 ? 'positive' : (netFromEnd < 0 ? 'negative' : 'neutral');

        const rakeLine = rake > 0 ? ` · Rake: -${rake} (${Math.round(rakeRate * 100)}%)` : '';

        const rewardNote = blackjackMatch.rewardPending
          ? `<div class="bj-result-score" style="color:var(--accent-gold); font-weight:800;">Winner reward pending…</div>`
          : '';

        const exhaustionNote = result.exhaustion
          ? `<div class="bj-result-score" style="color:var(--accent-red); font-weight:800;">Deck exhaustion (${result.exhaustion.side})</div>`
          : '';

        const activeSeqIndex = (seq && seq.running) ? Math.max(0, seq.idx - 1) : (seq ? seq.steps.length - 1 : -1);
        const karmaSeqHtml = seq ? `
          <div class="karma-seq">
            <div class="karma-seq-title">Karma Tally</div>
            <div class="karma-seq-total">+${seq.runningTotal} / ${seq.totalGained}</div>
            <div class="karma-seq-steps">
              ${seq.steps.map((step, i) => {
                const cls = i === activeSeqIndex && seq.running ? 'karma-step active' : (i < activeSeqIndex ? 'karma-step completed' : 'karma-step');
                const amountText = step.amount ? `+${step.amount}` : '—';
                return `<div class="${cls}"><span>${escapeHtml(step.label)}</span><span class="karma-amount">${amountText}</span></div>`;
              }).join('')}
            </div>
          </div>
        ` : '';

        html += `
          <div class="bj-result">
            <div class="bj-result-title ${titleCls}${resultPulse}">${outcome}</div>
            <div class="bj-result-score">
              Lanes: You ${result.playerWins} — Dealer ${result.dealerWins}<br/>
              Payout: ${payout} · Transfer x${transferMultiplier}: ${transfer >= 0 ? '+' : ''}${transfer}${rakeLine} · Bonus: ${bonus}
            </div>
            <div class="bj-result-chips ${netCls}">
              Match Net: ${netFromEnd >= 0 ? '+' : ''}${netFromEnd}
            </div>
            ${karmaSeqHtml}
            ${rewardNote}
            ${exhaustionNote}
            <button class="bj-btn" onclick="blackjackContinue()" ${blackjackMatch.rewardPending ? 'disabled' : ''}>Continue</button>
          </div>
        `;
      } else {
        if (blackjackMatch.phase === 'betting') {
          const stage = blackjackMatch.transferMultiplierStage;
          const min = blackjackMatch.transferMultiplierMin || 1;
          const max = blackjackMatch.transferMultiplierMax || 1;
          const options = Array.from({ length: max - min + 1 }, (_, i) => min + i);

          let betButtons = '';
          let betHint = '';

          if (stage === 'player') {
            betButtons = options.map(val => (
              `<button class="bj-btn" onclick="setTransferMultiplier(${val})">x${val}</button>`
            )).join('');
            betHint = 'Choose your transfer multiplier. Dealer can call or raise by +1.';
          } else if (stage === 'response' && blackjackMatch.transferRaiseOffer) {
            betButtons = `
              <button class="bj-btn success" onclick="acceptTransferRaise()">Accept x${blackjackMatch.transferRaiseOffer}</button>
              <button class="bj-btn danger" onclick="declineTransferRaise()">Decline</button>
            `;
            betHint = `Dealer raised to x${blackjackMatch.transferRaiseOffer}. Accept or decline.`;
          } else {
            betButtons = `<button class="bj-btn" disabled>Waiting…</button>`;
            betHint = 'Dealer is deciding…';
          }

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">Transfer Multiplier</div>
              <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
                <div class="bj-drawn-label">${betHint}</div>
              </div>
              <div class="bj-action-btns">
                ${betButtons}
              </div>
            </div>
          `;
        } else {
          const isPlayerTurn = blackjackMatch.turn === 'player';

          const drawn = blackjackMatch.drawnCard;
          const drawnHtml = drawn ? `
            <div class="bj-drawn-card">
              <div class="bj-drawn-label">Drawn:</div>
              ${renderCard(drawn, false)}
              <div class="bj-drawn-label" style="opacity:.9;">Place it into an open lane.</div>
            </div>
          ` : `
            <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
              <div class="bj-drawn-label">${isPlayerTurn ? 'No drawn card. Draw or use a bench card.' : 'Dealer is acting…'}</div>
            </div>
          `;

          // Action tokens UI
          const tokenTotal = blackjackMatch.tokensTotal || 0;
          const tokenSpent = blackjackMatch.tokensSpent || 0;
          const clickable = canClickToken();

          const tokensHtml = Array.from({ length: tokenTotal }, (_, i) => {
            const spent = i < tokenSpent;
            const disabled = spent || !clickable;
            const cls = spent ? 'token-icon spent' : (disabled ? 'token-icon disabled' : 'token-icon');
            const handler = (!spent && clickable) ? `onclick="onActionTokenClick()"` : '';
            return `<div class="${cls}" ${handler} title="${spent ? 'Spent' : (clickable ? 'Click to use an action token' : 'Unavailable')}">${i+1}</div>`;
          }).join('');

          const owned = run.ownedActions || [];
          const canSpend = (blackjackMatch.turn === 'player')
            && blackjackMatch.phase === 'playing'
            && !blackjackMatch.actionUsedThisTurn
            && !blackjackMatch.actionSelectionInProgress
            && tokensRemaining() > 0;

          const actionsHtml = owned.length
            ? owned.map(id => {
                const def = ACTIONS[id];
                const already = blackjackMatch.usedActions && blackjackMatch.usedActions[id];
                const usable = !!def && !already && canSpend && (!def.isUsable || def.isUsable(blackjackMatch));
                const cls = already ? 'action-chip used' : (usable ? 'action-chip ready' : 'action-chip locked');
                const name = def ? def.name : id;
                const desc = def ? def.desc : '';
                const ttTitle = name;
                const ttLines = `${desc}|Costs 1 token · Once per match`;

                return `<button class="${cls}" onclick="${usable ? `useActionFromBar('${id}')` : ''}"
                  data-tt-title="${escapeHtml(ttTitle)}"
                  data-tt-lines="${escapeHtml(ttLines)}">
                  ${escapeHtml(name)} <span class="pill">1⚡</span>
                </button>`;
              }).join('')
            : `<div class="action-hint" style="padding:6px 2px;">No cocktails owned yet. Visit the Bartender.</div>`;

          // Bench UI
          const bench = blackjackMatch.bench || [];
          const armedIdx = blackjackMatch.armedBenchIdx;
          const armedCard = (armedIdx !== null && armedIdx !== undefined) ? bench[armedIdx] : null;
          const armedLabel = armedCard ? `Armed: ${cardToString(armedCard)}` : 'Arm a bench card';

          const benchHtml = `
            <div class="action-bar bench-bar">
              <div class="action-bar-title">Bench (${bench.length}/${getBenchCapacity()}) · ${armedLabel}</div>
              <div class="bench-cards">
                ${bench.length ? bench.map((c, i) => {
                  const ring = (armedIdx === i) ? 'bench-armed-ring' : '';
                  return `
                    <button class="bench-card-btn ${ring}" onclick="armBench(${i})" ${!isPlayerTurn ? 'disabled' : ''} title="Arm">
                      ${renderCard(c, false, 'bench')}
                    </button>
                  `;
                }).join('') : `<div class="action-hint" style="padding: 6px 2px;">Bench is empty.</div>`}
              </div>
              <div class="action-hint">
                ${armedCard
                  ? (isModifier(armedCard)
                    ? 'Armed modifier: apply to any open lane (player or dealer). Costs 1 token.'
                    : 'Armed card: place into any open player lane (ends your turn). Costs 1 token.')
                  : 'Modifiers drawn are benched automatically. Using the Bench costs 1 token.'}
              </div>
            </div>
          `;

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">${isPlayerTurn ? 'Your Turn' : 'Dealer Turn'}</div>

              ${drawnHtml}

              <div class="bj-action-btns">
                <button class="bj-btn" onclick="playerDrawCard()" ${(!isPlayerTurn || !!drawn || countOpenPositions(blackjackMatch.playerPositions) === 0) ? 'disabled' : ''}>Draw</button>
                <button class="bj-btn" onclick="playerEndTurn()" ${(!isPlayerTurn || !!drawn || countOpenPositions(blackjackMatch.playerPositions) > 0) ? 'disabled' : ''}>End Turn</button>
              </div>

              <div class="controls-row">
                <div class="action-bar">
                  <div class="action-bar-title">Tokens</div>
                  <div class="action-tokens">${tokensHtml || '<div class="action-hint">No tokens</div>'}</div>
                  <div class="action-hint">Tokens power Bench plays and Cocktails.</div>
                </div>
                <div class="action-bar">
                  <div class="action-bar-title">Actions</div>
                  <div class="action-chips">${actionsHtml}</div>
                  <div class="action-hint">Hover / long-press an action for details.</div>
                </div>
                ${benchHtml}
              </div>

              <div class="action-hint" style="max-width: 720px;">
                Tip: You can stand to close a lane immediately. Over-21 totals only bust at end of turn unless you close that lane.
              </div>
            </div>
          `;
        }
      }

      blackjackView.innerHTML = html;

      // After DOM is in, inject lane action buttons (keeps markup clean)
      injectLaneActionButtons();
    }

    function injectLaneActionButtons() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const isPlayerTurn = blackjackMatch.turn === 'player';
      const drawn = blackjackMatch.drawnCard;
      const benchTokenBlocked = !isPlayerTurn || blackjackMatch.actionUsedThisTurn || tokensRemaining() <= 0 || !!drawn;

      const bench = blackjackMatch.bench || [];
      const bi = blackjackMatch.armedBenchIdx;
      const armed = (bi !== null && bi !== undefined) ? bench[bi] : null;

      for (let i = 0; i < 5; i++) {
        const p = blackjackMatch.playerPositions[i];
        const d = blackjackMatch.dealerPositions[i];

        const pEl = document.getElementById(`player_lane_actions_${i}`);
        const dEl = document.getElementById(`dealer_lane_actions_${i}`);
        if (!pEl || !dEl) continue;

        // reset
        pEl.innerHTML = '';
        dEl.innerHTML = '';

        // PLAYER lane buttons
        if (isPlayerTurn && p.isOpen && !p.isComplete) {
          // place drawn card
          if (drawn) {
            const btn = document.createElement('button');
            btn.className = 'bj-btn place';
            btn.textContent = 'Place';
            btn.onclick = () => playerPlaceCard(i);
            pEl.appendChild(btn);
          } else {
            // stand
            const stand = document.createElement('button');
            stand.className = 'bj-btn stand-pos';
            stand.textContent = 'Stand';
            stand.onclick = () => playerStand(i);
            pEl.appendChild(stand);

            // bench placement/apply
            if (armed) {
              if (isModifier(armed)) {
                const apply = document.createElement('button');
                apply.className = 'bj-btn apply-mod';
                apply.textContent = 'Apply Mod';
                apply.disabled = benchTokenBlocked;
                apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
                apply.onclick = () => applyBenchTo('player', i);
                pEl.appendChild(apply);
              } else {
                const placeB = document.createElement('button');
                placeB.className = 'bj-btn place-bench';
                placeB.textContent = 'Place Bench';
                placeB.disabled = benchTokenBlocked;
                placeB.title = benchTokenBlocked ? 'Requires 1 token' : '';
                placeB.onclick = () => playerPlaceBenchCard(i);
                pEl.appendChild(placeB);
              }
            }
          }
        }

        // DEALER lane buttons (only bench modifier applies here)
        if (isPlayerTurn && !drawn && armed && isModifier(armed) && d.isOpen && !d.isComplete) {
          const apply = document.createElement('button');
          apply.className = 'bj-btn apply-mod';
          apply.textContent = 'Apply Mod';
          apply.disabled = benchTokenBlocked;
          apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
          apply.onclick = () => applyBenchTo('dealer', i);
          dEl.appendChild(apply);
        }
      }
    }

    function buildKarmaCumulative(matches, startKarma){
      let k = (typeof startKarma==='number') ? startKarma : 0;
      return (matches || []).map(m=>{
        const g = (typeof m.karmaGained==='number') ? m.karmaGained : 0;
        k += g;
        return k;
      });
    }

    function buildFloorEndMarkers(matches){
      const byFloor = new Map();
      (matches || []).forEach((m, i)=>{
        const f = (m.floor==null) ? null : Number(m.floor);
        if(f==null || Number.isNaN(f)) return;
        byFloor.set(f, i);
      });
      const floors = [...byFloor.keys()].sort((a,b)=>a-b);
      return floors.map(f=>{
        const i = byFloor.get(f);
        const isBoss = String(matches[i]?.tableType||'').toUpperCase()==='BOSS';
        return { floor:f, matchPos:i, isBoss };
      });
    }

    function setupCanvas(canvas) {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, Math.floor(rect.width || canvas.clientWidth || 640));
      const h = Math.max(200, Math.floor(rect.height || canvas.clientHeight || 240));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }

    function clearChart(ctx, w, h) {
      ctx.clearRect(0, 0, w, h);
    }

    function drawAxes(ctx, w, h, pad, xLabel, yLabel, yMin, yMax) {
      ctx.save();
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.45)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, h - pad);
      ctx.lineTo(w - pad, h - pad);
      ctx.stroke();
      ctx.fillStyle = 'rgba(203, 213, 225, 0.8)';
      ctx.font = '11px Fira Code, monospace';
      ctx.fillText(yLabel, 8, pad - 8);
      ctx.fillText(xLabel, w - pad - 36, h - pad + 18);
      ctx.fillText(formatCompact(yMax), 8, pad + 3);
      ctx.fillText(formatCompact(yMin), 8, h - pad + 3);
      ctx.restore();
    }

    function drawLineScaled(ctx, w, h, pad, xs, ys, yMin, yMax, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < xs.length; i++) {
        const x = pad + xs[i] * (w - 2 * pad);
        const y = pad + (1 - ((ys[i] - yMin) / (yMax - yMin || 1))) * (h - 2 * pad);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawPoint(ctx, x, y, r=3){
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }

    function drawTextBox(ctx, text, x, y){
      ctx.font = '11px Fira Code, monospace';
      const pad = 4;
      const w = ctx.measureText(text).width + pad*2;
      const h = 16;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(x, y-h, w, h);
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText(text, x+pad, y-4);
    }

    function renderEndSummaryChart(summary, derived){
      const canvas = document.getElementById('chartEndSummary');
      if(!canvas) return;
      const ctx = setupCanvas(canvas);
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const pad = 42;

      const matches = derived.matches || [];
      if(!matches.length){
        clearChart(ctx,w,h);
        const caption = document.getElementById('endChartCaption');
        if (caption) caption.textContent = 'No match data available for this run.';
        return;
      }

      const xs = matches.map((_,i)=> i/(Math.max(1, matches.length-1)));
      const chips = matches.map(m=> (typeof m.chipsAfter==='number') ? m.chipsAfter : 0);
      const karma = buildKarmaCumulative(matches, summary.startKarma);
      const yVals = [...chips, ...karma].filter(v=>typeof v==='number');
      const yMin = Math.min(0, ...yVals);
      const yMax = Math.max(1, ...yVals);

      clearChart(ctx,w,h);
      drawAxes(ctx,w,h,pad,'Match','Value',yMin,yMax);
      drawLineScaled(ctx,w,h,pad,xs,chips,yMin,yMax,'rgba(125,211,252,0.90)');
      drawLineScaled(ctx,w,h,pad,xs,karma,yMin,yMax,'rgba(52,211,153,0.90)');

      const markers = buildFloorEndMarkers(matches);
      const labelStride = (markers.length > 8) ? 2 : 1;

      markers.forEach((m, idx)=>{
        const xN = xs[m.matchPos] || 0;
        const x = pad + xN*(w-2*pad);

        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, h-pad); ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.65)';
        ctx.font = '11px Fira Code, monospace';
        if(idx % labelStride === 0) ctx.fillText(`F${m.floor}`, x+4, pad+12);
        if(m.isBoss) ctx.fillText('♛', x+4, pad+26);
        ctx.restore();

        const chipV = chips[m.matchPos] ?? 0;
        const karmaV = karma[m.matchPos] ?? 0;
        const yChip = pad + (1-((chipV-yMin)/(yMax-yMin||1)))*(h-2*pad);
        const yKarma = pad + (1-((karmaV-yMin)/(yMax-yMin||1)))*(h-2*pad);

        ctx.save();
        ctx.fillStyle = 'rgba(125,211,252,0.95)';
        drawPoint(ctx, x, yChip, 3);
        drawTextBox(ctx, `C ${formatCompact(chipV)}`, x+6, yChip-2);
        ctx.restore();

        ctx.save();
        ctx.fillStyle = 'rgba(52,211,153,0.95)';
        drawPoint(ctx, x, yKarma, 3);
        drawTextBox(ctx, `K ${formatCompact(karmaV)}`, x+6, yKarma-2);
        ctx.restore();
      });

      const caption = document.getElementById('endChartCaption');
      if (caption) caption.textContent = 'Chips (C) and Karma (K) by match • floor ends marked • boss floors flagged ♛';
    }

    function renderRunEndPanel() {
      const analysis = buildRunEndAnalysis();
      const s = analysis.summary;
      const d = analysis.derived;
      const result = (s.runOutcome?.result || 'UNKNOWN').toUpperCase();
      const loreEl = document.getElementById('endLore');
      if (loreEl) loreEl.textContent = PIT_MESSAGES[result] || PIT_MESSAGES.UNKNOWN;

      const play = s.playstyle || computePlaystyle(s, d);
      const archetypeLine = formatArchetypeAttribution(play.primary?.name);
      const resonancePct = Math.round((play.confidence || 0) * 100);

      const archetypeEl = document.getElementById('endArchetypeLine');
      const resonanceEl = document.getElementById('endResonance');
      if (archetypeEl) archetypeEl.textContent = archetypeLine;
      if (resonanceEl) resonanceEl.textContent = `${resonancePct}% Resonance`;

      const build = s.appBuild ?? '—';
      const deckStart = s.deckSizeStart ?? '—';
      const deckEnd = s.deckSizeEnd ?? '—';
      const modsEnd = s.modCountEnd ?? '—';
      const modDens = (s.modDensityEnd!=null) ? `${Math.round(s.modDensityEnd*100)}%` : '—';
      const sid = (s.sessionId || '—');
      const sidShort = (typeof sid==='string' && sid.length>10) ? sid.slice(0,10)+'…' : sid;

      const stats = document.getElementById('endBuildDeckStats');
      if (stats) {
        stats.innerHTML = `
          <div>
            <div><b>Build:</b> ${escapeHtml(String(build))}</div>
            <div><b>Config:</b> —</div>
            <div><b>Session:</b> ${escapeHtml(String(sidShort))}</div>
            <div><b>Start:</b> ${escapeHtml(String(s.startedAtISO || '—'))}</div>
          </div>
          <div>
            <div><b>Deck:</b> ${escapeHtml(String(deckStart))} → ${escapeHtml(String(deckEnd))}</div>
            <div><b>Mods:</b> ${escapeHtml(String(modsEnd))}</div>
            <div><b>Mod density:</b> ${escapeHtml(String(modDens))}</div>
            <div><b>Chips:</b> ${escapeHtml(fmt(s.startChips))} → ${escapeHtml(fmt(s.endChips))}</div>
          </div>
        `;
      }

      renderEndSummaryChart(s, d);
    }

    function renderEndScreen() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'GAMEOVER' && run.ui.mode !== 'VICTORY') {
        endScreen.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.remove('hidden');

      const isVictory = run.ui.mode === 'VICTORY';
      const title = isVictory ? 'Victory' : 'Game Over';
      const titleCls = isVictory ? 'victory' : 'gameover';
      const msg = isVictory ? 'You cleared the tower.' : (run.ui.message || 'Your run has ended.');

      endScreen.innerHTML = `
        <div class="end-screen">
          <div class="end-title ${titleCls}">${title}</div>
          <div class="end-message">${msg}</div>

          <div class="run-end-card" id="runEndCard">
            <div class="run-end-header">
              <div>
                <div class="run-end-title">Run End</div>
                <div class="run-end-sub" id="runEndSub">A compact summary for players.</div>
              </div>
            </div>

            <div class="run-end-lore" id="endLore"></div>
            <div id="endArchetypeLine" class="run-end-tiny" style="margin-bottom:2px;"></div>
            <div id="endResonance" class="run-end-tiny run-end-muted" style="margin-bottom:10px;"></div>

            <div id="endBuildDeckStats" class="run-end-meta"></div>

            <canvas id="chartEndSummary"></canvas>
            <div class="run-end-tiny run-end-muted" id="endChartCaption" style="margin-top:8px;"></div>
          </div>

          <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="bj-btn" onclick="openLogPanel('stats')">Open Run Log</button>
            <button class="bj-btn" onclick="openFeedbackModal()">Feedback</button>
            <button class="bj-btn" onclick="initRun()">New Run</button>
          </div>
        </div>
      `;

      renderRunEndPanel();
    }

    // =============================================
    // TILE RESOLUTION
    // =============================================
    function encounterBlackjackStandard() {
      if (run.chips < BUYIN_STANDARD) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('STANDARD', BUYIN_STANDARD);
    }

    function encounterBlackjackHigh() {
      if (run.chips < BUYIN_HIGH) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('HIGH_STAKES', BUYIN_HIGH);
    }

    // =============================================
    // BOOT
    // =============================================
    (function boot() {
      // Try to keep last log available after refresh (doesn't overwrite current run)
      try {
        const saved = localStorage.getItem(LOG_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          if (parsed && parsed.sessionId && !gameLog) gameLog = parsed;
        }
      } catch (e) {}

      setupCardTooltip();
      initRun();
      renderAll();
    })();
  </script>
</body>
</html>
