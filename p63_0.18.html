<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Project 63 - Slot Blackjack</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
  /* Film Noir — Default Theme */
  --bg-primary: #0f0f0f;
  --bg-secondary: #1a1a1a;
  --bg-card: #262626;
  --bg-hover: #2c2c2c;

  --text-primary: #f5f5f5;
  --text-secondary: #b8b8b8;
  --text-muted: #737373;

  --accent-gold: #d4af37;
  --accent-gold-dim: #8a6f1f;

  --accent-red: #a83232;
  --accent-green: #5e8c61;
  --accent-blue: #5f7d95;
  --accent-purple: #7d6a82;

  --border-color: #404040;

  /* Playing card ink (used on white cards) */
  --card-red: #b13b3b;
  --card-black: #111111;

  /* Typography */
  --font-display: 'Bebas Neue', sans-serif;
  --font-mono: 'Space Mono', monospace;
  --font-body: 'Inter', sans-serif;

  /* Derived “wash” colors (keeps hover/bust backgrounds consistent) */
  --wash-gold: rgba(212, 175, 55, 0.14);
  --wash-red: rgba(168, 50, 50, 0.18);
  --wash-green: rgba(94, 140, 97, 0.18);
  --wash-blue: rgba(95, 125, 149, 0.16);
  --wash-purple: rgba(125, 106, 130, 0.16);
}

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: var(--font-body);
      font-size: 15px;
      line-height: 1.35;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
      isolation: isolate;
    }

    /* Ambient (subtle, non-gimmicky) */
    body::before{
      content:"";
      position: fixed;
      inset: -20%;
      z-index: -2;
      pointer-events: none;
      background:
        radial-gradient(600px 420px at 18% 12%, rgba(212,175,55,0.18), transparent 60%),
        radial-gradient(700px 520px at 82% 18%, rgba(95,125,149,0.16), transparent 62%),
        radial-gradient(720px 520px at 50% 86%, rgba(125,106,130,0.14), transparent 62%);
      filter: blur(36px) saturate(115%);
      opacity: 0.9;
    }

    /* Vignette + faint texture */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at center, transparent 45%, rgba(0,0,0,0.55) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 6px);
      opacity: 0.35;
      mix-blend-mode: overlay;
    }

        .hud-bank {
      min-width: 220px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .hud-bank-main { font-family: var(--font-mono); font-size: 18px; color: var(--accent-green); font-weight: 800; }
    .hud-bank-sub { font-size: 11px; color: var(--text-secondary); }

    .proc-banner { margin: 8px auto 12px; max-width: 680px; padding: 10px 12px; border: 1px solid var(--accent-blue); border-radius: 12px; background: rgba(95,125,149,0.16); font-family: var(--font-mono); }
    .proc-banner-title { font-weight: 800; color: var(--accent-gold); }
    .proc-banner-desc { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }

    .end-chart-wrap { width: min(980px, 96vw); display:grid; grid-template-columns: 1fr; gap: 14px; margin: 18px 0 24px; }
    .end-chart-card { background: var(--bg-card); border:1px solid var(--border-color); border-radius:12px; padding:12px; }
    .end-chart-title { font-family: var(--font-display); letter-spacing: 1px; color: var(--accent-gold); margin-bottom: 8px; }
    .sparkline { width: 100%; height: 120px; }
    .bar-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap:8px; }
    .bar-item { text-align:center; }
    .bar-col { height: 88px; display:flex; align-items:flex-end; justify-content:center; }
    .bar-fill { width: 22px; background: var(--accent-blue); border-radius: 6px 6px 0 0; }
    .bar-label { font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); margin-top: 4px; }

    .start-screen{
      position: fixed; inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
    }
    .start-plasma{ position:absolute; inset:0; width:100%; height:100%; }
    .start-shell{
      position: relative;
      width: min(560px, calc(100vw - 28px));
      padding: 18px;
      border: 1px solid var(--border-color);
      border-radius: 16px;
      background: rgba(15,15,15,0.74);
      backdrop-filter: blur(10px) saturate(120%);
      box-shadow: 0 24px 60px rgba(0,0,0,0.55);
    }
    .start-shell::before{
      content:"";
      position:absolute; left:0; right:0; top:0; height:3px;
      border-top-left-radius:16px; border-top-right-radius:16px;
      background: linear-gradient(90deg, var(--accent-gold), var(--accent-blue));
      opacity:.9;
    }
    .start-h1{ font-family: var(--font-display); letter-spacing: 1.2px; font-size: 44px; line-height: 1; }
    .start-h2{ font-family: var(--font-display); letter-spacing: 1px; font-size: 18px; color: var(--text-secondary); margin-top: 4px; }
    .start-lore{ font-family: var(--font-body); color: var(--text-secondary); margin-top: 10px; font-size: 14px; }
    .start-card{ margin-top:14px; padding:14px; border:1px solid var(--border-color); border-radius:14px; background: rgba(26,26,26,0.85); }
    .start-card-top{ font-family: var(--font-display); letter-spacing: 1px; color: var(--text-muted); }
    .start-card-row{ margin-top:8px; font-family: var(--font-mono); color: var(--text-secondary); font-size:12px; min-height: 16px; }
    .start-actions{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    .start-grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width: 420px){ .start-grid{ grid-template-columns:1fr; } .start-actions{ grid-template-columns:1fr; } }

    .rules-wrap{ display:flex; flex-direction:column; gap:12px; }
    .rules-h{ font-family: var(--font-display); letter-spacing: 1px; margin: 0; }
    .rules-ul{ margin: 0; padding-left: 18px; color: var(--text-secondary); }
    .rules-ul li{ margin: 6px 0; }

    /* HUD Styles */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(18, 26, 42, 0.95) 100%);
      border-bottom: 1px solid var(--border-color);
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      backdrop-filter: blur(10px);
    }

    .hud-primary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      width: 100%;
    }

    .hud-primary-left {
      display: flex;
      align-items: baseline;
      gap: 14px;
      flex-wrap: nowrap;
      min-width: 0;
      white-space: nowrap;
    }

    .hud-primary-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .hud-secondary {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 12px;
      width: 100%;
      padding-top: 10px;
      border-top: 1px solid var(--border-color);
    }

    #hud.hud-collapsed .hud-secondary { display: none; }

    .hud-left, .hud-right {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .hud-center{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .hud-icon-btn{
      width: 38px;
      height: 38px;
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor:pointer;
      transition: all 0.18s;
      border-radius: 10px;
      font-size: 18px;
      user-select: none;
    }
    .hud-icon-btn:hover{
      background: var(--bg-hover);
      border-color: var(--accent-gold);
      transform: translateY(-1px);
    }

    .hud-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
    }

    .hud-stat-label {
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: clamp(11px, 2.2vw, 12px);
      letter-spacing: 0.9px;
    }

    .hud-stat-value {
      color: var(--accent-gold);
      font-weight: 600;
      font-size: clamp(16px, 3.2vw, 18px);
    }

    .hud-stat-value.chips { color: var(--accent-green); }
    .hud-stat-value.debt { color: var(--accent-red); }
    .hud-stat-value.tokens { color: var(--accent-purple); }
    .hud-stat-value.karma { color: var(--accent-blue); }

    .hud-btn {
      font-family: var(--font-display);
      font-size: 13px;
      padding: 10px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .hud-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .hud-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .hud-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .hud-btn.danger:hover:not(:disabled) { background: var(--wash-red); }

    .hud-btn.success { border-color: var(--accent-green); color: var(--accent-green); }
    .hud-btn.success:hover:not(:disabled) { background: var(--wash-green); }

    :root { --hud-offset: 70px; }

    /* Main App Container */
    #app { padding-top: var(--hud-offset); min-height: 100vh; }
    .hidden { display: none !important; }

    /* Board View */
    #boardView { display: flex; flex-direction: column; align-items: center; padding: 20px; }
    #boardSvg { max-width: 100%; height: auto; }

    .hex-tile { cursor: pointer; transition: all 0.2s; }
    .hex-tile.visited { opacity: 0.5; }

    .hex-tile.current .hex-bg {
      stroke: var(--accent-blue);
      stroke-width: 4;
      filter: drop-shadow(0 0 10px var(--accent-blue));
    }

    .hex-tile.available .hex-bg {
      stroke: var(--accent-gold);
      stroke-width: 3;
      animation: pulse-glow 1.5s ease-in-out infinite;
    }

    .hex-tile.key-roller .hex-bg {
      stroke: rgba(240, 192, 64, 0.9);
      stroke-width: 4;
      animation: key-roller-glow 1.6s ease-in-out infinite;
      filter: drop-shadow(0 0 10px rgba(240, 192, 64, 0.25));
    }

    @keyframes key-roller-glow {
      0%, 100% { filter: drop-shadow(0 0 6px rgba(240, 192, 64, 0.18)); }
      50% { filter: drop-shadow(0 0 18px rgba(240, 192, 64, 0.42)); }
    }

    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 5px var(--accent-gold-dim)); }
      50% { filter: drop-shadow(0 0 15px var(--accent-gold)); }
    }

    .hex-label {
      font-family: 'Fira Code', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      fill: var(--text-primary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      font-weight: 600;
    }
    .hex-sub {
      font-family: 'Fira Code', monospace;
      font-size: clamp(10px, 2.2vw, 12px);
      fill: var(--text-secondary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .path-line {
      stroke: var(--accent-blue);
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.7;
    }

    /* Modal Overlay */
    #modalOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.55), rgba(0,0,0,0.72));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 20px;
      backdrop-filter: blur(7px) saturate(120%);
    }

    #modal {
      position: relative;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.9), rgba(125,106,130,0.65)) top/100% 3px no-repeat,
        var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      max-width: 560px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
      font-family: 'Cinzel', serif;
      font-size: 20px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .modal-body { padding: 24px; }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .modal-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .modal-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .modal-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .modal-btn.primary {
      background: var(--accent-gold);
      color: var(--bg-primary);
      border-color: var(--accent-gold);
    }
    .modal-btn.primary:hover:not(:disabled) { background: #ffda70; }

    .modal-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .modal-btn.danger:hover:not(:disabled) { background: var(--wash-red); }


    /* Unified button surface */
    .hud-btn, .modal-btn, .bj-btn, .log-mini-btn, .hud-icon-btn, .action-chip, .token-icon{
      background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.18));
      box-shadow:
        0 10px 24px rgba(0,0,0,0.25),
        inset 0 1px 0 rgba(255,255,255,0.05);
    }

    @media (hover:hover){
      .hud-btn:hover:not(:disabled),
      .modal-btn:hover:not(:disabled),
      .bj-btn:hover:not(:disabled),
      .log-mini-btn:hover:not(:disabled),
      .hud-icon-btn:hover:not(:disabled),
      .action-chip.ready:hover,
      .token-icon:hover:not(.spent):not(.disabled):not(.locked){
        transform: translateY(-1px);
      }
    }

    /* Mobile press feedback (important for phones) */
    .hud-btn:active:not(:disabled),
    .modal-btn:active:not(:disabled),
    .bj-btn:active:not(:disabled),
    .log-mini-btn:active:not(:disabled),
    .hud-icon-btn:active:not(:disabled),
    .action-chip:active:not(.locked):not(.used),
    .token-icon:active:not(.spent):not(.disabled):not(.locked){
      transform: translateY(0px) scale(0.99);
      filter: brightness(1.08);
    }


    /* keep semantic button colors over unified surface */
    .modal-btn.primary {
      background: var(--accent-gold);
      color: var(--bg-primary);
      border-color: var(--accent-gold);
    }
    .bj-btn.place,
    .bj-btn.apply-mod {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }
    .bj-btn.stand-pos {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: white;
    }
    .bj-btn.place-bench {
      background: rgba(95, 125, 149, 0.2);
      border-color: var(--accent-blue);
      color: white;
    }

    .modal-text {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 16px;
    }

    .modal-reward {
      font-family: 'Fira Code', monospace;
      font-size: 24px;
      color: var(--accent-green);
      text-align: center;
      padding: 20px;
      background: rgba(61, 214, 140, 0.1);
      border-radius: 10px;
      margin-bottom: 16px;
      border: 1px solid rgba(61,214,140,0.2);
    }

    /* Merchant Styles */
    .merchant-section { margin-bottom: 18px; }
    .merchant-section-title {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }
    .merchant-cards { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

    .merchant-card-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      min-width: 110px;
    }

    .merchant-card-slot .playing-card { font-size: 18px; }

    .rarity-pip {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .rarity-common { background: #94a3b8; }
    .rarity-uncommon { background: #22c55e; }
    .rarity-rare { background: #f59e0b; }

    /* Blackjack View */
    #blackjackView {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .bj-header { text-align: center; font-family: 'Cinzel', serif; }
    .bj-title {
      font-size: 24px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 8px;
    }
    .bj-status {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .bj-board { display: flex; flex-direction: column; gap: 34px; }
    .bj-side { display: flex; flex-direction: column; gap: 12px; }
    .bj-side-label {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-positions {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }

    @media (max-width: 768px) {
      .bj-positions { grid-template-columns: repeat(5, 1fr); gap: 6px; }
    }

    .bj-position {
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 14px;
      padding: 12px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-height: 160px;
      transition: all 0.2s;
    }

    .bj-position.closed { opacity: 0.4; background: var(--bg-secondary); }
    .bj-position.open { border-color: var(--accent-blue); }
    .bj-position.bust { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }
    .bj-position.stand { border-color: var(--accent-green); }
    .bj-position.winner { border-color: var(--accent-gold); box-shadow: 0 0 20px rgba(240, 192, 64, 0.22); }

    .bj-position-num { font-family: 'Fira Code', monospace; font-size: 10px; color: var(--text-muted); }

    .bj-cards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 4px;
      min-height: 50px;
    }

    .bj-total {
      font-family: 'Fira Code', monospace;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .bj-total.bust { color: var(--accent-red); }

    .bj-state {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 800;
    }

    .bj-state.open { background: var(--accent-blue); color: white; }
    .bj-state.stand { background: var(--accent-green); color: white; }
    .bj-state.bust { background: var(--accent-red); color: white; }
    .bj-state.closed { background: var(--text-muted); color: var(--bg-primary); }

    /* Playing Cards */
    .playing-card {
      width: 36px;
      height: 50px;
      background: white;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-family: 'Fira Code', monospace;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid #ddd;
    }

    .playing-card.red { color: var(--card-red); }
    .playing-card.black { color: var(--card-black); }

    /* Modifier cards: shaded blue (per spec) */
    .playing-card.mod {
      background: rgba(95, 125, 149, 0.18);
      border-color: rgba(95, 125, 149, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-blue {
      background: rgba(95, 125, 149, 0.18);
      border-color: rgba(95, 125, 149, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-crystal {
      box-shadow: 0 2px 6px rgba(148, 163, 184, 0.8);
      background: linear-gradient(135deg, rgba(226,232,240,0.7), rgba(255,255,255,0.9));
    }

    .playing-card.sleeve-steel {
      border-color: rgba(148, 163, 184, 0.9);
      box-shadow: 0 2px 6px rgba(100, 116, 139, 0.6);
    }

    .playing-card.sleeve-gold {
      border-color: rgba(234, 179, 8, 0.9);
      box-shadow: 0 2px 6px rgba(234, 179, 8, 0.6);
      background: linear-gradient(135deg, rgba(254, 243, 199, 0.9), rgba(255,255,255,0.9));
    }

    .playing-card.fused {
      background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(77,166,255,0.22));
      border-color: rgba(168,85,247,0.65);
      color: #1f2937;
      font-size: 11px;
    }

    .stamp-icon {
      position: absolute;
      top: -6px;
      right: -6px;
      background: var(--accent-gold);
      color: #1b1f2a;
      font-size: 9px;
      font-weight: 800;
      border-radius: 999px;
      padding: 2px 5px;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      pointer-events: none;
    }

    .card-tooltip {
      position: fixed;
      z-index: 9999;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-primary);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      max-width: 220px;
      pointer-events: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .card-tooltip.hidden { display: none; }
    .card-tooltip .tooltip-title { font-weight: 800; margin-bottom: 4px; }
    .card-tooltip .tooltip-line { color: var(--text-secondary); line-height: 1.35; }

    /* Bench styling (subtle blue “bench” tint) */
    .playing-card.bench {
      background: rgba(95, 125, 149, 0.10);
      border-color: rgba(95, 125, 149, 0.55);
    }

    .playing-card.face-down {
      background: linear-gradient(135deg, #1a237e 0%, #0d47a1 50%, #1a237e 100%);
      color: transparent;
    }
    .playing-card.face-down::after {
      content: '?';
      color: rgba(255,255,255,0.3);
      font-size: 20px;
    }

    /* Blackjack Controls */
    .bj-controls {
      display: flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
      padding: 16px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55)) top/100% 3px no-repeat,
        var(--bg-secondary);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-turn-info {
      font-family: 'Cinzel', serif;
      font-size: 16px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-drawn-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: rgba(95, 125, 149, 0.1);
      border: 1px solid var(--accent-blue);
      border-radius: 12px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 560px;
    }

    .bj-drawn-label { font-size: 14px; color: var(--text-secondary); }

    .bj-action-btns {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .bj-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 12px;
    }

    .bj-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .bj-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .bj-btn.place {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.stand-pos {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.apply-mod {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.place-bench {
      background: rgba(95, 125, 149, 0.2);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    /* Action bar */
    .action-bar {
      width: 100%;
      max-width: 560px;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 14px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55)) top/100% 3px no-repeat,
        var(--bg-secondary);
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .action-bar-title {
      width: 100%;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .action-tokens {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    /* ACTIONS BOX (owned cocktails surfaced on-board) */
    .action-chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      padding-top:6px;
    }

    .action-chip{
      border:1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      user-select:none;
      transition: all .15s;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .action-chip.ready:hover{ border-color: var(--accent-gold); transform: translateY(-1px); }
    .action-chip.locked{ opacity:.45; cursor:not-allowed; transform:none; }
    .action-chip.used{ opacity:.30; cursor:not-allowed; text-decoration: line-through; }

    .action-chip .pill{
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--accent-gold);
      opacity:.9;
    }

    .token-icon {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--accent-gold);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
      font-family: 'Fira Code', monospace;
      font-weight: 800;
    }

    .token-icon:hover:not(.spent):not(.disabled):not(.locked) { border-color: var(--accent-gold); transform: translateY(-1px); }
    .token-icon.spent { opacity: 0.25; cursor: not-allowed; transform: none; }
    .token-icon.disabled { opacity: 0.35; cursor: not-allowed; transform: none; }
    .token-icon.locked { opacity: 0.55; border-style: dashed; cursor: not-allowed; transform: none; }

    .action-hint {
      color: var(--text-secondary);
      font-size: 12px;
      text-align: center;
      line-height: 1.4;
    }

    /* Bench block next to Actions */
    .controls-row {
      width: 100%;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: stretch;
    }

    .bench-bar {
      max-width: 380px;
      min-width: 260px;
      flex: 1;
    }

    .bench-cards {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding-top: 6px;
    }

    .bench-card-btn {
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      border-radius: 10px;
    }

    .bench-card-btn:disabled { cursor: not-allowed; opacity: 0.5; }

    .bench-armed-ring {
      outline: 2px solid rgba(95, 125, 149, 0.85);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* Action picker list */
    .action-list { display: flex; flex-direction: column; gap: 10px; }
    .action-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
    }
    .action-row.disabled { opacity: 0.45; }
    .action-row-title {
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 14px;
      margin-bottom: 4px;
    }
    .action-row-desc { color: var(--text-secondary); font-size: 12px; line-height: 1.4; }
    .action-row-left { flex: 1; }
    .action-row-right { display: flex; flex-direction: column; gap: 8px; }

    /* Match Result */
    .bj-result {
      text-align: center;
      padding: 24px;
      background: var(--bg-card);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-result-title {
      font-family: 'Cinzel', serif;
      font-size: 28px;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .bj-result-title.win { color: var(--accent-green); }
    .bj-result-title.lose { color: var(--accent-red); }
    .bj-result-title.tie { color: var(--accent-gold); }

    .bj-result-score {
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      line-height: 1.5;
    }

    .bj-result-chips {
      font-family: 'Fira Code', monospace;
      font-size: 22px;
      margin-bottom: 20px;
    }

    .bj-result-chips.positive { color: var(--accent-green); }
    .bj-result-chips.negative { color: var(--accent-red); }
    .bj-result-chips.neutral { color: var(--text-muted); }

    .boss-hp {
      width: 100%;
      max-width: 360px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      margin: 6px auto 0;
      border: 1px solid var(--border-color);
    }

    .boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #f39c12, #e74c3c);
      transition: width 0.3s ease;
    }

    .boss-phase2 .boss-hp-fill {
      background: linear-gradient(90deg, #ff6b6b, #ff4757);
      box-shadow: 0 0 12px rgba(255, 71, 87, 0.6);
    }

    .boss-target {
      border-color: rgba(255, 107, 107, 0.9);
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.6), 0 0 14px rgba(255, 107, 107, 0.5);
      animation: bossPulse 1.6s ease-in-out infinite;
    }

    .watcher-target {
      border-color: rgba(125, 211, 252, 0.92);
      box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.25), 0 0 20px rgba(125, 211, 252, 0.22);
      animation: watcherPulse 1.7s ease-in-out infinite;
    }

    @keyframes bossPulse {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    @keyframes watcherPulse {
      0%, 100% { box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.20), 0 0 12px rgba(125, 211, 252, 0.16); }
      50% { box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.34), 0 0 22px rgba(125, 211, 252, 0.34); }
    }

    /* Game Over / Victory Screens */
    .end-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 70px);
      padding: 40px 20px;
      text-align: center;
    }

    .end-title {
      font-family: 'Cinzel', serif;
      font-size: 48px;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 4px;
    }

    .end-title.victory {
      color: var(--accent-gold);
      text-shadow: 0 0 40px rgba(240, 192, 64, 0.5);
    }

    .end-title.gameover {
      color: var(--accent-red);
      text-shadow: 0 0 40px rgba(232, 69, 69, 0.5);
    }

    .end-message {
      font-size: 18px;
      color: var(--text-secondary);
      margin-bottom: 30px;
      max-width: 520px;
      line-height: 1.6;
    }

    .end-stats { display: flex; gap: 26px; margin-bottom: 30px; flex-wrap: wrap; justify-content: center; }
    .end-stat { text-align: center; min-width: 120px; }

    .end-stat-value {
      font-family: 'Fira Code', monospace;
      font-size: 28px;
      color: var(--accent-gold);
      font-weight: 800;
    }

    .end-stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* Toast */
    #toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 300;
      animation: toast-in 0.3s ease-out;
      box-shadow: 0 18px 50px rgba(0,0,0,0.5);
      max-width: min(640px, 92vw);
      text-align: center;
    }

    @keyframes toast-in {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Confirm Dialog */
    .confirm-dialog {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.55), rgba(0,0,0,0.72));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 300;
      padding: 20px;
      backdrop-filter: blur(7px) saturate(120%);
    }

    .confirm-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 24px;
      max-width: 420px;
      width: 100%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .confirm-message { color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6; }
    .confirm-btns { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    /* Removal / selection picker */
    .removal-picker { display: flex; flex-direction: column; gap: 16px; }
    .removal-cards { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    .removal-card-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 72px;
    }

    .removal-card-option:hover { border-color: var(--accent-red); }
    .removal-card-option.selected { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }

    /* Board instructions */
    .board-instructions {
      text-align: center;
      padding: 16px;
      color: var(--text-secondary);
      font-size: 14px;
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 20px;
      max-width: 520px;
      border: 1px solid var(--border-color);
    }

    /* =============================================
       LOG PANEL (slide-in)
       ============================================= */
    #logPanel{
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: min(420px, 92vw);
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      z-index: 150; /* below modal overlay */
      transform: translateX(110%);
      transition: transform 0.24s ease;
      display: flex;
      flex-direction: column;
      box-shadow: -20px 0 60px rgba(0,0,0,0.45);
    }
    #logPanel.open{ transform: translateX(0); }

    .log-panel-header{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(26,36,54,0.55), rgba(18,26,42,0.15));
    }
    .log-panel-title{
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 14px;
      line-height: 1.2;
    }
    .log-panel-sub{
      margin-top: 2px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }
    .log-panel-actions{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .log-mini-btn{
      font-family: 'Cinzel', serif;
      font-size: 11px;
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      user-select:none;
    }
    .log-mini-btn:hover{ background: var(--bg-hover); border-color: var(--accent-gold); }
    .log-mini-btn.danger{ border-color: var(--accent-red); color: var(--accent-red); }
    .log-mini-btn.danger:hover{ background: var(--wash-red); }

    .log-tabs{
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      gap: 8px;
    }
    .log-tab{
      flex: 1;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor:pointer;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      font-family: 'Cinzel', serif;
    }
    .log-tab:hover{ background: var(--bg-hover); border-color: var(--accent-gold); color: var(--text-primary); }
    .log-tab.active{
      border-color: var(--accent-gold);
      color: var(--text-primary);
      box-shadow: 0 0 18px rgba(240,192,64,0.15);
    }

    .log-panel-body{
      padding: 14px 16px;
      overflow-y: auto;
      flex: 1;
    }
    .log-card{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .log-card-head{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 8px;
      align-items: baseline;
    }
    .log-type{
      color: var(--accent-blue);
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .log-card-body{
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.45;
      word-break: break-word;
    }
    .log-kv{
      margin-top: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      background: rgba(10,14,23,0.35);
      border: 1px solid rgba(42,58,84,0.85);
      border-radius: 12px;
      padding: 10px;
      white-space: pre-wrap;
    }
    .stats-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .log-section-title{
      margin: 18px 0 8px;
      font-weight: 800;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 12px;
    }
    .log-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      overflow: hidden;
    }
    .log-table th,
    .log-table td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      text-align: left;
    }
    .log-table th{
      color: var(--text-secondary);
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 0.8px;
      background: rgba(18, 26, 42, 0.6);
    }
    .log-table tr:last-child td{ border-bottom: none; }
    .stat-box{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
    }
    .stat-label{
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .stat-value{
      font-family: 'Fira Code', monospace;
      font-size: 18px;
      color: var(--text-primary);
      font-weight: 800;
    }
    .stat-value.good{ color: var(--accent-green); }
    .stat-value.bad{ color: var(--accent-red); }
    .stat-value.gold{ color: var(--accent-gold); }

    .intro-panel {
      max-width: 720px;
      margin: 24px auto;
      padding: 24px;
      border-radius: 18px;
      background: rgba(18, 26, 42, 0.75);
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .intro-title { font-size: 22px; font-weight: 900; margin-bottom: 8px; }
    .intro-text { color: var(--text-secondary); line-height: 1.5; margin-bottom: 16px; }
    .intro-input {
      width: 100%;
      max-width: 360px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 10px;
    }
    .intro-actions { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .intro-suits { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); margin-top: 12px; }
    .intro-suit-btn { text-align: left; }
    .intro-large-card { transform: scale(1.4); margin: 18px auto; }

    .score-flash {
      animation: scorePulse 1.05s ease-in-out;
      box-shadow: 0 0 0 2px rgba(255, 215, 128, 0.72), 0 0 22px rgba(255, 215, 128, 0.44);
    }
    @keyframes scorePulse {
      0% { transform: translateY(0) scale(1); }
      35% { transform: translateY(-2px) scale(1.015); }
      100% { transform: translateY(0) scale(1); }
    }

    .karma-pop {
      animation: karmaPop 0.6s ease-out;
      box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.26);
    }
    @keyframes karmaPop {
      0% { transform: scale(1); }
      35% { transform: scale(1.16); }
      100% { transform: scale(1); }
    }

    .karma-float {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Fira Code', monospace;
      font-size: 12px;
      font-weight: 900;
      color: var(--accent-gold);
      text-shadow: 0 0 8px rgba(240, 192, 64, 0.45);
      animation: karmaFloatUp 1s ease-out forwards;
      pointer-events: none;
    }
    @keyframes karmaFloatUp {
      0% { opacity: 0; transform: translate(-50%, -40%); }
      20% { opacity: 1; transform: translate(-50%, -52%); }
      100% { opacity: 0; transform: translate(-50%, -78%); }
    }

    .scoring-mode .bj-position { opacity: 0.55; }
    .scoring-mode .bj-position.score-flash { opacity: 1; }

    .hud-calling {
      min-width: 240px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .hud-calling-row { display: flex; justify-content: space-between; align-items: baseline; gap: 8px; }
    .hud-calling-main { font-family: 'Fira Code', monospace; font-weight: 800; color: var(--accent-gold); }
    .hud-calling-sub { font-size: 11px; color: var(--text-secondary); }
    .xpbar { width: 100%; height: 8px; border-radius: 999px; background: rgba(255,255,255,0.1); overflow: hidden; }
    .xpbar-fill { height: 100%; background: linear-gradient(90deg, #60a5fa, #7dd3fc); transition: width 0.25s ease; }
    .xpbar-text { font-size: 10px; color: var(--text-muted); text-align: right; }
    .calling-rank-pulse { animation: rankPulse 0.85s ease-in-out 2; }
    @keyframes rankPulse {
      0%,100% { box-shadow: 0 0 0 rgba(125,211,252,0); }
      50% { box-shadow: 0 0 0 2px rgba(125,211,252,0.35), 0 0 18px rgba(125,211,252,0.3); }
    }


    /* =========================================================
       Film Noir Typography Map (overrides hard-coded fonts)
       ========================================================= */
    .hud-btn, .modal-btn, .bj-btn, .log-mini-btn,
    .modal-header, .bj-title, .merchant-section-title,
    .bj-side-label, .bj-turn-info,
    .action-row-title, .bj-result-title, .end-title,
    .log-panel-title, .log-tab {
      font-family: var(--font-display) !important;
    }

    .hud-stat, .hud-stat-value,
    .hex-label, .hex-sub,
    .bj-position-num, .bj-total,
    .playing-card, .modal-reward,
    .bj-result-score, .bj-result-chips,
    .end-stat-value, .stat-value,
    .log-panel-sub, .log-card-head, .log-kv {
      font-family: var(--font-mono) !important;
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; }
      .hex-tile.available .hex-bg{ animation: none !important; }
      .boss-target{ animation: none !important; }
    }

  </style>
</head>

<body>
  <div id="startScreen" class="start-screen">
    <canvas id="startPlasma" class="start-plasma" aria-hidden="true"></canvas>

    <div class="start-shell">
      <div class="start-title">
        <div class="start-h1">Project 63</div>
        <div class="start-h2">The Tower</div>
        <div class="start-lore">A casino with no address. An indecipherable ledger. Will you test fate?</div>
      </div>

      <div class="start-card" id="startRunCard">
        <div class="start-card-top">Run</div>
        <div class="start-card-row" id="startRunSummary"></div>

        <div class="start-actions">
          <button class="hud-btn primary" id="btnContinue">Continue</button>
          <button class="hud-btn" id="btnNewRun">New Run</button>
        </div>
      </div>

      <div class="start-grid">
        <button class="hud-btn" id="btnRules">Rules</button>
        <button class="hud-btn" id="btnStats">Run Stats</button>
        <button class="hud-btn" id="btnSettings">Settings</button>
        <button class="hud-btn" id="btnFeedback">Feedback</button>
      </div>
    </div>
  </div>

  <header id="hud"></header>

  <main id="app">
    <section id="boardView"></section>
    <section id="blackjackView" class="hidden"></section>
    <section id="endScreen" class="hidden"></section>
  </main>

  <div id="modalOverlay" class="hidden">
    <div id="modal"></div>
  </div>

  <div id="toast" class="hidden"></div>
  <div id="cardTooltip" class="card-tooltip hidden"></div>
  <div id="actionTooltip" class="card-tooltip hidden"></div>

  <!-- Log Panel -->
  <aside id="logPanel" aria-label="Run Log"></aside>

  <script>
    // =============================================
    // CONSTANTS
    // =============================================
    const STARTING_CHIPS = 500;
    const REST_REWARD = 50;
    const BARTENDER_REWARD = 50;
    const MINIGAME_REWARD = 50;

    const MERCHANT_BUY_BASE_STANDARD = 50;
    const MERCHANT_BUY_BASE_MOD = 100;
    const MERCHANT_BUY_INCREMENT = 25;
    const MERCHANT_REMOVE_COST = 50;
    const REMOVAL_REROLL_COST = 25;      // also used as inventory reroll cost
    const MERCHANT_INVENTORY_REROLL_COST = 25;
    const COLLECTOR_ITEM_COST = 150;

// Economy tuning
const MERCHANT_REMOVE_INCREMENT = 25; // removal cost increases by this amount each time you start a paid removal
const MOD_PURCHASE_LIMIT_PER_DELTA = 2; // only this many of each modifier (-4..+4) can be purchased per run
const BENCH_BASE_CAPACITY = 2; // bench slots at start of run
const BENCH_CAPACITY_BONUS_PER_BOSS_WIN = 1; // +1 bench slot after each boss victory
const HOUSE_RAKE_RATES = { 1: 0.10, 2: 0.20, 3: 0.30 }; // applied to positive (payout + transfer) only
const CALLING_PROC_CHANCE = 0.50;
const DIAMOND_BONUS_CHIPS = 10;
const CALLING_RANK_THRESHOLDS = [
  { rank: '2', karma: 0 },
  { rank: '3', karma: 200 },
  { rank: '4', karma: 500 },
  { rank: '5', karma: 900 },
  { rank: '6', karma: 1400 },
  { rank: '7', karma: 2000 },
  { rank: '8', karma: 2700 },
  { rank: '9', karma: 3500 },
  { rank: '10', karma: 4400 },
  { rank: 'J', karma: 5400 },
  { rank: 'Q', karma: 6500 },
  { rank: 'K', karma: 7700 },
  { rank: 'A', karma: 9000 }
];


    const LOAN_AMOUNT = 500;
    const LOAN_REPAY = 750;

    const BUYIN_STANDARD = 100;
    const BUYIN_HIGH = 200;
    const BUYIN_BOSS = 300;

    // Action tokens + cocktails
    const COCKTAIL_COST = 150;
    const ACTION_TOKEN_MAX_BANKED = 3;
    const KEY_SUIT = '★';
    const KEY_MERCHANT_COST = 150;

    // Rewards / mechanics
    const BLACKJACK_21_REWARD = 21;
    const ALL_FIVE_21_BONUS = 210;

    // Modifiers (merchant + deck)
    const MODIFIER_DELTAS = [-4,-3,-2,-1, +1,+2,+3,+4];
    const MOD_OFFER_CHANCE = 0.22;

    const FLOOR_COUNTS = {
      1: { standard: 11, high: 2 },
      2: { standard: 7, high: 6 },
      3: { standard: 3, high: 10 }
    };

    const NODES = [
      [0, 200, 50, []],
      [1, 140, 95, [0]], [2, 260, 95, [0]],
      [3, 80, 140, [1]], [4, 200, 140, [0, 1, 2]], [5, 320, 140, [2]],
      [6, 140, 185, [1, 3, 4]], [7, 260, 185, [2, 4, 5]],
      [8, 80, 230, [3, 6]], [9, 200, 230, [4, 6, 7]], [10, 320, 230, [5, 7]],
      [11, 140, 275, [6, 8, 9]], [12, 260, 275, [7, 9, 10]],
      [13, 80, 320, [8, 11]], [14, 200, 320, [9, 11, 12]], [15, 320, 320, [10, 12]],
      [16, 140, 365, [11, 13, 14]], [17, 260, 365, [12, 14, 15]],
      [18, 80, 410, [13, 16]], [19, 200, 410, [14, 16, 17]], [20, 320, 410, [15, 17]]
    ];

    const HEX_SIZE = 30;
    const SUITS = ['♠', '♥', '♦', '♣'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    const TILE_COLORS = {
      'BOSS': '#FFD700',
      'STANDARD': '#4a6fa5',
      'HIGH_STAKES': '#9b59b6',
      'MERCHANT': '#27ae60',
      'MODIFY': '#16a085',
      'COLLECTOR': '#f39c12',
      'LOAN_SHARK': '#e67e22',
      'REST_STOP': '#3498db',
      'BARTENDER': '#e74c3c',
      'MINIGAME': '#1abc9c'
    };

    const TILE_LABELS = {
      'BOSS': 'BOSS',
      'STANDARD': 'STD',
      'HIGH_STAKES': 'HIGH',
      'MERCHANT': 'MER',
      'MODIFY': 'MOD',
      'COLLECTOR': 'COL',
      'LOAN_SHARK': 'LOAN',
      'REST_STOP': 'REST',
      'BARTENDER': 'BAR',
      'MINIGAME': 'MINI'
    };

    // =============================================
    // COCKTAIL ACTION REGISTRY
    // =============================================
    const ACTIONS = {
      splitDecision: {
        name: "Split Decision",
        desc: "Draw 2 playable cards. Choose 1 to play; the other is immediately played by the Dealer.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSplitDecision()
      },
      secondOpinion: {
        name: "Second Opinion",
        desc: "Draw 2 playable cards. Choose 1 to play; discard the other.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSecondOpinion()
      },
      benched: {
        name: "Benched",
        desc: "Draw a playable card and send it to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateBenched()
      },
      spyGlass: {
        name: "Spy Network",
        desc: "Reveal the current totals of all Dealer lanes for the rest of the match.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateSpyGlass()
      },
      forcedPlay: {
        name: "Forced Play",
        desc: "Choose a Dealer open lane. The Dealer's next placed card must go there (if still valid).",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateForcedPlay()
      },
      revival: {
        name: "Revival",
        desc: "Reopen any of your closed lanes (stood or busted).",
        isUsable: (m) => isPlayerActionContextOK(m) && getEligibleRevivalLanes(m).length > 0,
        activate: () => activateRevival()
      },
      findMyCard: {
        name: "Find My Card",
        desc: "Search the top 10 of your draw pile for a modifier; move the first found to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateFindMyCard()
      },
      closer: {
        name: "Closer",
        desc: "Choose a Dealer open lane and close it immediately.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateCloser()
      }
    };

    // =============================================
    // STARTER SCREEN
    // =============================================
    const START_PLASMA_CONFIG = {
      speed: 0.85, intensity: 1.25, scale: 1.6,
      colors: [
        [0.0431, 0.0549, 0.0471],
        [0.1176, 0.1647, 0.1333],
        [0.3686, 0.5490, 0.3804]
      ]
    };

    class StartPlasma2D {
      constructor(canvas, cfg){
        this.canvas = canvas;
        this.ctx = canvas ? canvas.getContext('2d', { alpha: false }) : null;
        this.cfg = cfg; this.t = 0; this.running = false;
        this.off = document.createElement('canvas');
        this.offCtx = this.off.getContext('2d');
        this.onResize = this.onResize.bind(this);
        window.addEventListener('resize', this.onResize);
        this.onResize();
      }
      onResize(){
        if (!this.canvas || !this.ctx) return;
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const w = Math.floor(window.innerWidth * dpr);
        const h = Math.floor(window.innerHeight * dpr);
        this.canvas.width = w; this.canvas.height = h;
        const scale = 0.33;
        this.off.width = Math.max(240, Math.floor(w * scale));
        this.off.height = Math.max(180, Math.floor(h * scale));
      }
      start(){ if (this.running) return; if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return; this.running = true; requestAnimationFrame(()=>this.frame()); }
      stop(){ this.running = false; }
      field(x,y,t){ const s=this.cfg.scale,nx=x/this.off.width,ny=y/this.off.height; return (Math.sin((nx*3.2*s)+t)+Math.sin((ny*3.0*s)+t*0.9)+Math.sin(((nx+ny)*2.2*s)+t*0.7)+Math.sin((Math.hypot(nx-0.5, ny-0.5)*7.0*s)-t*1.1))*0.25+0.5; }
      lerp(a,b,t){ return a+(b-a)*t; }
      sampleGradient(v){ const [c0,c1,c2]=this.cfg.colors; if(v<0.5){ const t=v/0.5; return [this.lerp(c0[0],c1[0],t),this.lerp(c0[1],c1[1],t),this.lerp(c0[2],c1[2],t)]; } const t=(v-0.5)/0.5; return [this.lerp(c1[0],c2[0],t),this.lerp(c1[1],c2[1],t),this.lerp(c1[2],c2[2],t)]; }
      frame(){ if (!this.running || !this.ctx) return; const w=this.off.width,h=this.off.height,img=this.offCtx.createImageData(w,h),d=img.data; this.t += 0.016*this.cfg.speed; const inten=this.cfg.intensity; for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ let v=this.field(x,y,this.t); v=Math.min(1,Math.max(0,0.5+(v-0.5)*inten)); const [r,g,b]=this.sampleGradient(v); const i=(y*w+x)*4; d[i]=(r*255)|0; d[i+1]=(g*255)|0; d[i+2]=(b*255)|0; d[i+3]=255; } } this.offCtx.putImageData(img,0,0); this.ctx.imageSmoothingEnabled=true; this.ctx.drawImage(this.off,0,0,this.canvas.width,this.canvas.height); requestAnimationFrame(()=>this.frame()); }
    }

    let startPlasma = null;
    let uiView = 'start';
    function initStartPlasma(){ const c=document.getElementById('startPlasma'); if (!c) return; startPlasma = new StartPlasma2D(c, START_PLASMA_CONFIG); }
    function showStartScreen(){ uiView = 'start'; const el=document.getElementById('startScreen'); if (el) el.style.display='flex'; if (startPlasma) startPlasma.start(); }
    function hideStartScreen(){ uiView = 'game'; const el=document.getElementById('startScreen'); if (el) el.style.display='none'; if (startPlasma) startPlasma.stop(); }
    function updateStartRunCard(){
      const sum = document.getElementById('startRunSummary');
      const btnContinue = document.getElementById('btnContinue');
      if (!sum || !btnContinue) return;
      const hasRun = !!run;
      if (hasRun) {
        sum.textContent = `Floor ${run.floor} · Chips ${safeNumber(run.chips)} · Debt ${run.loan && run.loan.active && !run.loan.repaid ? "Owed" : "None"}`;
        btnContinue.disabled = false;
      } else {
        sum.textContent = 'No saved run yet';
        btnContinue.disabled = true;
      }
    }

    // =============================================
    // GAME STATE
    // =============================================
    let run = null;
    let blackjackMatch = null;

    // Merchant state
    let merchantOffers = [];
    let removalMode = false;
    let removalCandidates = [];
    let selectedRemovalIdx = null;
    let removalPaidCost = 0;

    // Dealer timers (bug-proof reset)
    let dealerTimerA = null;
    let dealerTimerB = null;
    function clearDealerTimers() {
      if (dealerTimerA) clearTimeout(dealerTimerA);
      if (dealerTimerB) clearTimeout(dealerTimerB);
      dealerTimerA = null;
      dealerTimerB = null;
    }

    // =============================================
    // UI SETTINGS + LOGGING (Option B)
    // =============================================
    const LOG_STORAGE_KEY = 'p63_runlog_latest';
    const PLAYER_NAME_KEY = 'p63_player_name';
    let uiSettings = {
      autoOpenLogOnEnd: true,

      // if false, dealer totals + hole cards reveal only at match resolution (unless Spy Network)
      revealTotalsOnClose: false,

      // NEW: opponent AI difficulty
      opponentDifficulty: 'hard', // 'easy' | 'medium' | 'hard'

      // (kept) house rake mode (this used to be uiSettings.difficulty)
      rakeMode: 'hard', // 'easy' (none) | 'medium' (10% flat) | 'hard' (10/20/30)

      // hard cap for bench capacity (0 = no cap)
      benchHardCap: 3 // 2 or 3 (or 0 for “no cap”)
    };

    // Back-compat: if you had older saves/edits that set uiSettings.difficulty
    if (uiSettings.difficulty && !uiSettings.opponentDifficulty) uiSettings.opponentDifficulty = uiSettings.difficulty;
    if (uiSettings.difficulty && !uiSettings.rakeMode) uiSettings.rakeMode = uiSettings.difficulty;

    function loadPlayerName() {
      try { return localStorage.getItem(PLAYER_NAME_KEY) || ''; } catch (e) { return ''; }
    }

    function savePlayerName(name) {
      try { localStorage.setItem(PLAYER_NAME_KEY, name || ''); } catch (e) {}
    }

    function clearPlayerName() {
      try { localStorage.removeItem(PLAYER_NAME_KEY); } catch (e) {}
    }


    let gameLog = null;
    let logPanelOpen = false;
    let logPanelTab = 'stats'; // 'events' | 'stats'

    let persistTimer = null;
    function persistLogSoon() {
      if (!gameLog) return;
      if (persistTimer) return;
      persistTimer = setTimeout(() => {
        persistTimer = null;
        try { localStorage.setItem(LOG_STORAGE_KEY, JSON.stringify(gameLog)); } catch (e) {}
      }, 120);
    }

    function generateSessionId() {
      return 'S' + Math.random().toString(16).slice(2, 8).toUpperCase() + '-' + Date.now().toString(16).toUpperCase().slice(-6);
    }

    function getSettingsSnapshot() {
      return {
        revealTotalsOnClose: (uiSettings && uiSettings.revealTotalsOnClose) !== false,
        opponentDifficulty: (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard',
        rakeMode: (uiSettings && uiSettings.rakeMode) || 'hard',
        benchHardCap: safeNumber(uiSettings && uiSettings.benchHardCap, 3),
        autoOpenLogOnEnd: !!(uiSettings && uiSettings.autoOpenLogOnEnd),
        rulesContext: {
          benchBaseCapacity: BENCH_BASE_CAPACITY,
          benchBonusPerBossWin: BENCH_CAPACITY_BONUS_PER_BOSS_WIN,
          modifierPurchaseLimitPerDelta: MOD_PURCHASE_LIMIT_PER_DELTA,
          startingChips: STARTING_CHIPS,
          buyins: {
            standard: BUYIN_STANDARD,
            highStakes: BUYIN_HIGH,
            boss: BUYIN_BOSS
          },
          blackjack21Reward: BLACKJACK_21_REWARD,
          allFive21Bonus: ALL_FIVE_21_BONUS
        }
      };
    }

    function buildDeckSummary() {
      const deck = run ? (run.playerDeck || []) : [];
      const bySuit = { '♠': 0, '♥': 0, '♦': 0, '♣': 0, [KEY_SUIT]: 0 };
      const byRank = Object.fromEntries(RANKS.map(r => [r, 0]));
      let modCount = 0;
      let fusedCount = 0;
      let sleevedCount = 0;

      for (const c of deck) {
        if (isModifier(c)) {
          modCount += 1;
          continue;
        }
        if (isFused(c)) {
          fusedCount += 1;
          continue;
        }
        if (isKeyCard(c)) {
          if (bySuit[c.suit] !== undefined) bySuit[c.suit] += 1;
          if (byRank[c.rank] !== undefined) byRank[c.rank] += 1;
          continue;
        }
        if (isStandardCard(c)) {
          if (bySuit[c.suit] !== undefined) bySuit[c.suit] += 1;
          if (byRank[c.rank] !== undefined) byRank[c.rank] += 1;
          if (c.sleeveId) sleevedCount += 1;
        }
      }

      return {
        deckSize: deck.length,
        modCount,
        fusedCount,
        sleevedCount,
        stampsByRank: { ...(run && run.stampsByRank ? run.stampsByRank : {}) },
        bySuit,
        byRank
      };
    }

    function serializeCard(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { uid: card.uid || null, kind: 'KEY', rank: card.rank, suit: card.suit, keySource: card.keySource || null };
      if (isFused(card)) {
        return {
          uid: card.uid || null,
          kind: 'FUSE',
          a: serializeCard(card.a),
          b: serializeCard(card.b)
        };
      }
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function serializeDeck() {
      const deck = run ? (run.playerDeck || []) : [];
      return {
        cards: deck.map(serializeCard),
        stampsByRank: { ...(run && run.stampsByRank ? run.stampsByRank : {}) }
      };
    }

    function deckSnapshot() {
      const summary = buildDeckSummary();
      return {
        deckId: gameLog ? gameLog.currentDeckId : null,
        deckSize: summary.deckSize,
        modCount: summary.modCount,
        fusedCount: summary.fusedCount,
        sleevedCount: summary.sleevedCount,
        stampsByRank: summary.stampsByRank,
        bySuit: summary.bySuit,
        byRank: summary.byRank
      };
    }

    function recordDeckSnapshot(reason, extraData = {}) {
      if (!gameLog || !run) return null;
      const nextId = safeNumber(gameLog.currentDeckId, 0) + 1;
      gameLog.currentDeckId = nextId;
      const entry = {
        deckId: nextId,
        ts: new Date().toISOString(),
        reason,
        ctx: getEventCtx(),
        deck: serializeDeck(),
        summary: buildDeckSummary(),
        ...extraData
      };
      gameLog.deckHistory.push(entry);
      if (gameLog.stats) gameLog.stats.deckSnapshots = safeNumber(gameLog.stats.deckSnapshots, 0) + 1;
      persistLogSoon();
      return nextId;
    }

    function resetLog() {
      const snap = deckSnapshot();
      const chipsNow = run ? safeNumber(run.chips, 0) : 0;
      const sessionId = generateSessionId();
      const rulesContext = {
        collector: {
          itemCost: COLLECTOR_ITEM_COST,
          rarityRates: { common: 0.70, uncommon: 0.25, rare: 0.05 }
        },
        modify: {
          services: Object.values(MODIFY_SERVICES).map(s => ({ id: s.id, tier: s.tier, kind: s.kind })),
          pricing: { coreBase: 100, coreInc: 25, premiumBase: 200, premiumInc: 50 }
        },
        stamps: Object.values(STAMP_DEFS).map(s => ({ id: s.id, rarity: s.rarity })),
        sleeves: Object.values(SLEEVE_DEFS).map(s => ({ id: s.id, rarity: s.rarity }))
      };

      gameLog = {
        logVersion: "C",
        sessionId,
        runId: sessionId,
        startedAt: new Date().toISOString(),
        endedAt: null,
        exportedAt: null,
        app: {
          name: "Project 63",
          build: "0.18",
          variant: "p63_0.18.html",
          userAgent: navigator.userAgent
        },
        player: {
          name: run && run.playerName ? run.playerName : ''
        },
        settingsAtStart: getSettingsSnapshot(),
        settingsLatest: getSettingsSnapshot(),
        rulesContext,
        initialState: null,
        finalState: null,
        runOutcome: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        deckHistory: [],
        currentDeckId: null,
        events: [],
        stats: {
          floorsReached: 1,
          tilesEntered: 0,
          tilesByType: {},
          matches: 0,
          wins: 0,
          losses: 0,
          ties: 0,
          buyinSpent: 0,
          payoutReceived: 0,
          transferNet: 0,
          bonusChips: 0,
          merchantBuys: 0,
          merchantRemoves: 0,
          merchantRerolls: 0,
          cocktailsBought: 0,
          loansTaken: 0,
          loansRepaid: 0,
          tokensGained: 0,
          tokensSpent: 0,
          actionsUsed: 0,
          collectorOffersShown: 0,
          collectorPurchases: 0,
          modifyCandidateSetsShown: 0,
          modifyApplies: 0,
          deckSnapshots: 0,
          feedbackUpdates: 0,

          chipsPeak: chipsNow,
          chipsLow: chipsNow,

          deckSizeMin: snap.deckSize,
          deckSizeMax: snap.deckSize,
          modCountMin: snap.modCount,
          modCountMax: snap.modCount,

          matchDurationMsTotal: 0,
          rakePaidTotal: 0,
          bossClears: 0
        }
      };
      persistLogSoon();
    }

    function updateLogStats(evt) {
      if (!gameLog || !gameLog.stats) return;
      const s = gameLog.stats;

      if (evt && typeof evt.chips === 'number') {
        s.chipsPeak = Math.max(s.chipsPeak, evt.chips);
        s.chipsLow = Math.min(s.chipsLow, evt.chips);
      }

      if (evt && evt.data && evt.data.deckSnapshot) {
        const ds = evt.data.deckSnapshot;
        if (typeof ds.deckSize === 'number') {
          s.deckSizeMin = Math.min(s.deckSizeMin, ds.deckSize);
          s.deckSizeMax = Math.max(s.deckSizeMax, ds.deckSize);
        }
        if (typeof ds.modCount === 'number') {
          s.modCountMin = Math.min(s.modCountMin, ds.modCount);
          s.modCountMax = Math.max(s.modCountMax, ds.modCount);
        }
      }

      switch (evt.type) {
        case 'FLOOR_START':
          s.floorsReached = Math.max(s.floorsReached, evt.floor || 1);
          break;
        case 'TILE_ENTER':
          s.tilesEntered += 1;
          s.tilesByType[evt.data.tileType] = (s.tilesByType[evt.data.tileType] || 0) + 1;
          break;
        case 'MATCH_START':
          s.matches += 1;
          s.buyinSpent += safeNumber(evt.data.buyIn, 0);
          break;
        case 'MATCH_END':
          if (evt.data.outcome === 'WIN') s.wins += 1;
          else if (evt.data.outcome === 'LOSS') s.losses += 1;
          else s.ties += 1;
          s.payoutReceived += safeNumber(evt.data.payout, 0);
          s.transferNet += safeNumber(evt.data.transferNet, 0);
          s.bonusChips += safeNumber(evt.data.bonusChips, 0);
          s.rakePaidTotal += safeNumber(evt.data.rake, 0);
          s.matchDurationMsTotal += safeNumber(evt.data.durationMs, 0);
          break;
        case 'BOSS_CLEARED':
          s.bossClears += 1;
          break;
        case 'TOKEN_GAIN':
          s.tokensGained += safeNumber(evt.data.amount, 0);
          break;
        case 'TOKEN_SPENT':
          s.tokensSpent += safeNumber(evt.data.amount, 0);
          break;
        case 'ACTION_USED':
          s.actionsUsed += 1;
          break;
        case 'MERCHANT_BUY':
          s.merchantBuys += 1;
          break;
        case 'MERCHANT_REMOVE_CONFIRM':
          s.merchantRemoves += 1;
          break;
        case 'MERCHANT_REROLL':
          s.merchantRerolls += 1;
          break;
        case 'COCKTAIL_BOUGHT':
          s.cocktailsBought += 1;
          break;
        case 'LOAN_TAKEN':
          s.loansTaken += 1;
          break;
        case 'LOAN_REPAID':
          s.loansRepaid += 1;
          break;
        case 'COLLECTOR_SHOP_GENERATED':
          s.collectorOffersShown += 1;
          break;
        case 'COLLECTOR_BUY':
          s.collectorPurchases += 1;
          break;
        case 'MODIFY_CANDIDATES_SHOWN':
          s.modifyCandidateSetsShown += 1;
          break;
        case 'MODIFY_APPLY':
          s.modifyApplies += 1;
          break;
        case 'FEEDBACK_UPDATED':
          s.feedbackUpdates += 1;
          break;
        case 'DECK_SNAPSHOT':
          s.deckSnapshots += 1;
          break;
      }
    }

    function getEventCtx() {
      const currentTile = run && run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      return {
        floor: run ? run.floor : null,
        chips: run ? safeNumber(run.chips, null) : null,
        karma: run ? safeNumber(run.karma, null) : null,
        playerName: run ? (run.playerName || '') : '',
        callingCard: run && run.callingCard ? { ...run.callingCard } : null,
        callingRankValue: run && run.callingCard ? rankToValue(run.callingCard.rank) : null,
        tileId: run && run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        encounterSeq: run && run.activeEncounter ? run.activeEncounter.seq : null,
        encounterType: run && run.activeEncounter ? run.activeEncounter.type : null,
        matchSeq: blackjackMatch ? blackjackMatch.matchSeq : null,
        matchType: blackjackMatch ? blackjackMatch.type : null,
        matchPhase: blackjackMatch ? blackjackMatch.phase : null,
        turn: blackjackMatch ? blackjackMatch.turn : null,
        visibility: {
          revealOnClose: (uiSettings && uiSettings.revealTotalsOnClose) !== false,
          difficulty: getOpponentDifficulty()
        },
        bossFight: (run && run.bossFight && run.bossFight.active) ? {
          round: run.bossFight.round,
          maxRounds: run.bossFight.maxRounds,
          hp: run.bossFight.hp,
          maxHp: run.bossFight.maxHp,
          phase: run.bossFight.phase,
          targetLaneIdx: run.bossFight.targetLaneIdx
        } : null
      };
    }

    function logEvent(type, data = {}) {
      if (!gameLog) return;
      const evt = {
        id: gameLog.events.length + 1,
        ts: new Date().toISOString(),
        type,
        floor: run ? run.floor : null,
        chips: run ? safeNumber(run.chips, null) : null,
        ctx: getEventCtx(),
        data
      };
      gameLog.events.push(evt);
      updateLogStats(evt);
      persistLogSoon();

      if (logPanelOpen) renderLogPanel();
    }

    function finalizeRunLog(outcomeObj = {}) {
      if (!gameLog || !run) return;
      if (!gameLog.endedAt) gameLog.endedAt = new Date().toISOString();

      const currentTile = run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      const baseOutcome = {
        outcome: outcomeObj.outcome || null,
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        matchSeq: blackjackMatch ? blackjackMatch.matchSeq : null,
        chips: safeNumber(run.chips, 0),
        message: outcomeObj.message || null
      };

      gameLog.runOutcome = { ...baseOutcome };
      gameLog.finalState = {
        chips: safeNumber(run.chips, 0),
        karma: safeNumber(run.karma, 0),
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        callingCard: run.callingCard ? { ...run.callingCard } : null,
        deckSnapshot: deckSnapshot(),
        deckSummary: buildDeckSummary()
      };
      if (run.feedback) gameLog.feedback = { ...run.feedback };
      persistLogSoon();
    }

    function formatTime(tsIso) {
      const d = new Date(tsIso);
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      return `${hh}:${mm}:${ss}`;
    }

    function eventSummary(evt) {
      const t = evt.type;
      const d = evt.data || {};
      if (t === 'GAME_START') return `Run started. Chips=${d.startingChips}, Deck=${d.deckSize}`;
      if (t === 'FLOOR_START') return `Entered Floor ${d.floor}`;
      if (t === 'TILE_ENTER') return `Entered tile #${d.tileId} (${d.tileType})`;
      if (t === 'REST_CHOICE') return `Lounge: ${d.choice}${d.freeRemoval ? ' (free removal)' : ''}`;
      if (t === 'MINIGAME') return `Minigame reward +${d.chips} chips, +${d.tokens} token`;
      if (t === 'BARTENDER_TAKE') return `Bartender: took +${d.chips} chips`;
      if (t === 'COCKTAIL_BOUGHT') return `Bought cocktail: ${d.actionName} (-${d.cost})`;
      if (t === 'LOAN_TAKEN') return `Loan taken +${d.amount}, owe ${d.repay}`;
      if (t === 'LOAN_REPAID') return `Loan repaid -${d.amount}`;
      if (t === 'MERCHANT_ENTER') return `Shop Keeper opened`;
      if (t === 'MODIFY_ENTER') return `Card Press opened`;
      if (t === 'MODIFY_SERVICE_SELECT') return `Card Press service: ${d.serviceId} (-${d.cost})`;
      if (t === 'MODIFY_CANDIDATES_SHOWN') return `Card Press candidates shown (${d.countShown || 0})`;
      if (t === 'MODIFY_SELECTION') return `Card Press selection: ${d.serviceId}`;
      if (t === 'MODIFY_APPLY') return `Card Press applied: ${d.serviceId} (${d.count || 0} cards)`;
      if (t === 'MODIFY_LEAVE') return `Card Press closed`;
      if (t === 'COLLECTOR_SHOP_GENERATED') return `Collector shop generated`;
      if (t === 'COLLECTOR_ENTER') return `Collector opened`;
      if (t === 'COLLECTOR_BUY') return `Collector buy: ${d.name} (-${d.cost})`;
      if (t === 'STAMP_OPTIONS_SHOWN') return `Stamp options shown (${d.options ? d.options.join(',') : ''})`;
      if (t === 'SLEEVE_CANDIDATES_SHOWN') return `Sleeve candidates shown`;
      if (t === 'STAMP_APPLY') return `Stamp applied: ${d.stampId} on ${d.rank}`;
      if (t === 'SLEEVE_APPLY') return `Sleeve applied: ${d.sleeveId} on ${d.card}`;
      if (t === 'COLLECTOR_LEAVE') return `Collector closed`;
      if (t === 'MERCHANT_BUY') return `Bought ${d.card} (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_START') return `Removal started (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_CONFIRM') return `Removed ${d.card}`;
      if (t === 'MERCHANT_REROLL') return `Merchant reroll (${d.which}) (-${d.cost})`;
      if (t === 'MODIFIER_SOLD_OUT') return `Modifier sold out: ${d.card} (limit ${d.limit})`;
      if (t === 'MATCH_START') return `Match start: ${d.type}, buy-in ${d.buyIn}, tokens ${d.tokensTotal}`;
      if (t === 'PLAYER_DRAW') return `Player drew ${d.card}`;
      if (t === 'PLAYER_DRAW_BENCH') return `Player drew modifier ${d.card} (benched)`;
      if (t === 'PLAYER_PLACE') return `Player placed ${d.card} to lane #${d.lane}`;
      if (t === 'PLAYER_STAND') return `Player stood lane #${d.lane} (total ${d.total})`;
      if (t === 'BENCH_APPLY') return `Bench applied ${d.card} to ${d.side} lane #${d.lane}`;
      if (t === 'BENCH_PLACE') return `Bench placed ${d.card} to player lane #${d.lane}`;
      if (t === 'BENCH_OVERFLOW') return `Bench overflow: discarded ${d.removed}`;
      if (t === 'TRANSFER_BET') return `Side Bet: player x${d.playerMultiplier} (${d.dealerAction}${d.offer ? ` to x${d.offer}` : ''})`;
      if (t === 'TRANSFER_BET_RESPONSE') return `Side Bet response: ${d.response} (x${d.finalMultiplier})`;
      if (t === 'ACTION_USED') return `Action used: ${d.actionName}`;
      if (t === 'BONUS_21') return `Bonus: lane #${d.lane} hit 21 (+${d.amount})`;
      if (t === 'BONUS_ALL_FIVE') return `Bonus: all five hit 21 (+${d.amount})`;
      if (t === 'SETTINGS_CHANGED') return `Settings updated`;
      if (t === 'CALLING_CARD_SET') return `Calling card set: ${d.callingCard ? cardToString(d.callingCard) : '—'}`;
      if (t === 'CALLING_PROC_DIAMOND') return `Calling (♦): +${d.amount} chips`;
      if (t === 'CALLING_PROC_CLUBS') return `Calling (♣): dealer lane #${d.laneIdx} ${d.delta}`;
      if (t === 'CALLING_PROC_SPADES') return `Calling (♠): revealed dealer lane #${d.laneIdx}`;
      if (t === 'CALLING_PROC_HEARTS_TRIAGE') return `Calling (♥): triage lane #${d.laneIdx}`;
      if (t === 'CALLING_CARD_LEVEL_UP') return `Calling card leveled: ${d.fromRank} → ${d.toRank}`;
      if (t === 'NPC_ASSIGNED') return `NPC: ${d.npcName} (${d.tileType})`;
      if (t === 'CRYSTAL_SLEEVE_SAVE') return `Crystal sleeve saved lane #${d.laneIdx}`;
      if (t === 'GOLD_SLEEVE_BONUS') return `Gold sleeve bonus +${d.amount} (lane #${d.laneIdx})`;
      if (t === 'BURN_AFTER_READING') return `Burned ${d.count} stamped card(s)`;
      if (t === 'MERCHANT_ENTER') return `Merchant: ${d.npcName} (prices x${d.priceMult})`;
      if (t === 'WINNER_REWARD_FUSE') return `Fused ${d.cards ? d.cards.join(' + ') : 'cards'}`;
      if (t === 'DECK_EXHAUSTION') return `Deck exhaustion: ${d.side} (${d.reason})`;
      if (t === 'MATCH_END') return `Match end: ${d.outcome} (payout ${d.payout}, transfer ${d.transferNet >= 0 ? '+' : ''}${d.transferNet})`;
      if (t === 'BOSS_CLEARED') return `Boss cleared on floor ${d.floor}`;
      if (t === 'KARMA_GAIN') return `Karma +${d.amount} (total ${d.total})`;
      if (t === 'FEEDBACK_UPDATED') return `Feedback updated`;
      if (t === 'DECK_SNAPSHOT') return `Deck snapshot saved`;
      if (t === 'GAME_END') return `Run ended: ${d.result}`;
      return t;
    }

    function openLogPanel(tab = 'stats') {
      logPanelTab = tab;
      logPanelOpen = true;
      const el = document.getElementById('logPanel');
      el.classList.add('open');
      renderLogPanel();
    }

    function closeLogPanel() {
      logPanelOpen = false;
      const el = document.getElementById('logPanel');
      el.classList.remove('open');
    }

    function switchLogTab(tab) {
      logPanelTab = tab;
      renderLogPanel();
    }

    function exportLog() {
      if (!gameLog) return;
      if (!gameLog.exportedAt) gameLog.exportedAt = new Date().toISOString();
      if (!gameLog.endedAt && run && (run.ui.mode === 'GAMEOVER' || run.ui.mode === 'VICTORY')) {
        const outcome = run.ui.mode === 'VICTORY' ? 'win' : 'loss';
        finalizeRunLog({ outcome, message: run.ui.message || null });
      }
      const payload = JSON.stringify(gameLog, null, 2);
      const blob = new Blob([payload], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `project63_runlog_${gameLog.sessionId}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast('Log exported');
    }

    function clearSavedLog() {
      try { localStorage.removeItem(LOG_STORAGE_KEY); } catch (e) {}
      showToast('Saved log cleared');
    }

    function renderLogEvents() {
      const events = (gameLog && gameLog.events) ? gameLog.events.slice().reverse() : [];
      if (!events.length) return `<div class="log-card"><div class="log-card-body">No events yet.</div></div>`;

      return events.map(evt => {
        const time = formatTime(evt.ts);
        const summary = eventSummary(evt);
        const details = JSON.stringify(evt.data || {}, null, 2);
        return `
          <div class="log-card">
            <div class="log-card-head">
              <div><span class="log-type">${evt.type}</span> <span style="opacity:.85;">· F${evt.floor ?? '-'}</span></div>
              <div>${time}</div>
            </div>
            <div class="log-card-body">${summary}</div>
            ${details && details !== "{}" ? `<div class="log-kv">${details}</div>` : ``}
          </div>
        `;
      }).join('');
    }

    function formatRate(numerator, denominator) {
      if (!denominator) return '—';
      return `${Math.round((numerator / denominator) * 100)}%`;
    }

    function initPerfBucket() {
      return {
        matches: 0,
        lanesPlayed: 0,
        playerTotalSum: 0,
        playerNonBustSum: 0,
        playerNonBustCount: 0,
        playerBustLanes: 0,
        dealerBustLanes: 0,
        player21Lanes: 0,
        dealer21Lanes: 0,
        laneW: 0,
        laneL: 0,
        laneT: 0,
        matchW: 0,
        matchL: 0,
        matchT: 0
      };
    }

    function computeDerivedPerf(events) {
      const perf = {
        overall: initPerfBucket(),
        byFloor: {},
        byType: {},
        recentMatches: []
      };

      (events || []).forEach(evt => {
        if (!evt || evt.type !== 'MATCH_END') return;
        const lanes = evt.data && evt.data.lanes;
        if (!lanes) return;

        const playerTotals = lanes.playerTotals || [];
        const dealerTotals = lanes.dealerTotals || [];
        const playerBusts = lanes.playerBusts || [];
        const dealerBusts = lanes.dealerBusts || [];
        const laneWinners = lanes.laneWinners || [];

        const bucket = perf.overall;
        const floorKey = String(evt.floor || '—');
        const typeKey = evt.data.type || 'UNKNOWN';

        if (!perf.byFloor[floorKey]) perf.byFloor[floorKey] = initPerfBucket();
        if (!perf.byType[typeKey]) perf.byType[typeKey] = initPerfBucket();

        const floorBucket = perf.byFloor[floorKey];
        const typeBucket = perf.byType[typeKey];
        const buckets = [bucket, floorBucket, typeBucket];

        buckets.forEach(b => { b.matches += 1; });
        if (evt.data.outcome === 'WIN') buckets.forEach(b => { b.matchW += 1; });
        else if (evt.data.outcome === 'LOSS') buckets.forEach(b => { b.matchL += 1; });
        else buckets.forEach(b => { b.matchT += 1; });

        let matchPlayerTotalSum = 0;
        let matchPlayerNonBustSum = 0;
        let matchPlayerNonBustCount = 0;
        let matchPlayerBusts = 0;
        let matchPlayer21s = 0;
        let matchLaneW = 0;
        let matchLaneL = 0;
        let matchLaneT = 0;

        for (let i = 0; i < 5; i++) {
          const pTotal = safeNumber(playerTotals[i], 0);
          const dTotal = safeNumber(dealerTotals[i], 0);
          const pBust = !!playerBusts[i];
          const dBust = !!dealerBusts[i];
          const winner = laneWinners[i];

          matchPlayerTotalSum += pTotal;
          if (!pBust) {
            matchPlayerNonBustSum += pTotal;
            matchPlayerNonBustCount += 1;
          } else {
            matchPlayerBusts += 1;
          }
          if (pTotal === 21 && !pBust) matchPlayer21s += 1;

          buckets.forEach(b => {
            b.lanesPlayed += 1;
            b.playerTotalSum += pTotal;
            if (!pBust) {
              b.playerNonBustSum += pTotal;
              b.playerNonBustCount += 1;
            }
            if (pBust) b.playerBustLanes += 1;
            if (dBust) b.dealerBustLanes += 1;
            if (pTotal === 21 && !pBust) b.player21Lanes += 1;
            if (dTotal === 21 && !dBust) b.dealer21Lanes += 1;
          });

          if (winner === 'player') {
            buckets.forEach(b => { b.laneW += 1; });
            matchLaneW += 1;
          } else if (winner === 'dealer') {
            buckets.forEach(b => { b.laneL += 1; });
            matchLaneL += 1;
          } else {
            buckets.forEach(b => { b.laneT += 1; });
            matchLaneT += 1;
          }
        }

        const matchAvgIncl = matchPlayerTotalSum / 5;
        const matchAvgExcl = matchPlayerNonBustCount ? (matchPlayerNonBustSum / matchPlayerNonBustCount) : null;
        perf.recentMatches.push({
          floor: evt.floor,
          type: evt.data.type,
          outcome: evt.data.outcome,
          avgIncl: matchAvgIncl,
          avgExcl: matchAvgExcl,
          playerBusts: matchPlayerBusts,
          player21s: matchPlayer21s,
          laneW: matchLaneW,
          laneL: matchLaneL,
          laneT: matchLaneT
        });
      });

      return perf;
    }

    function renderLogStats() {
      const s = (gameLog && gameLog.stats) ? gameLog.stats : null;
      if (!s) return `<div class="log-card"><div class="log-card-body">No stats yet.</div></div>`;

      const derived = computeDerivedPerf(gameLog.events || []);
      const overall = derived.overall;
      const avgLaneIncl = overall.lanesPlayed ? (overall.playerTotalSum / overall.lanesPlayed) : 0;
      const avgLaneExcl = overall.playerNonBustCount ? (overall.playerNonBustSum / overall.playerNonBustCount) : null;

      const net = safeNumber(run ? run.chips : 0) - STARTING_CHIPS;

      const tileLines = Object.entries(s.tilesByType || {})
        .sort((a,b) => b[1]-a[1])
        .map(([k,v]) => `${k}: ${v}`)
        .join('\n');

      const avgMatchMs = s.matches ? Math.round(s.matchDurationMsTotal / s.matches) : 0;

      const recentMatches = derived.recentMatches.slice(-10).reverse();

      const floorRows = Object.entries(derived.byFloor).map(([floor, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>Floor ${floor}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? '—' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const typeRows = Object.entries(derived.byType).map(([type, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>${type}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? '—' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const recentRows = recentMatches.map(m => `
        <tr>
          <td>F${m.floor}</td>
          <td>${m.type}</td>
          <td>${m.outcome}</td>
          <td>${m.avgIncl.toFixed(1)}</td>
          <td>${m.avgExcl === null ? '—' : m.avgExcl.toFixed(1)}</td>
          <td>${m.playerBusts}</td>
          <td>${m.player21s}</td>
          <td>${m.laneW}/${m.laneL}/${m.laneT}</td>
        </tr>
      `).join('') || `<tr><td colspan="8">No recent matches.</td></tr>`;

      return `
        <div class="log-section-title">Run Overview</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Session</div>
            <div class="stat-value gold" style="font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${gameLog.sessionId}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Floors Reached</div>
            <div class="stat-value">${s.floorsReached}/3</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Chips Peak</div>
            <div class="stat-value good">${s.chipsPeak}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Chips Low</div>
            <div class="stat-value bad">${s.chipsLow}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Net vs Start</div>
            <div class="stat-value ${net >= 0 ? 'good' : 'bad'}">${net >= 0 ? '+' : ''}${net}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Matches</div>
            <div class="stat-value">${s.matches}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">W / L / T</div>
            <div class="stat-value">${s.wins} / ${s.losses} / ${s.ties}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Match Time</div>
            <div class="stat-value">${avgMatchMs}ms</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Buy-ins Spent</div>
            <div class="stat-value">${s.buyinSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Payouts</div>
            <div class="stat-value">${s.payoutReceived}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Transfers Net</div>
            <div class="stat-value ${s.transferNet >= 0 ? 'good' : 'bad'}">${s.transferNet >= 0 ? '+' : ''}${s.transferNet}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Bonus Chips</div>
            <div class="stat-value gold">${s.bonusChips}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Rake Paid</div>
            <div class="stat-value bad">${s.rakePaidTotal}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Tokens Gained / Spent</div>
            <div class="stat-value">${s.tokensGained} / ${s.tokensSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Actions Used</div>
            <div class="stat-value">${s.actionsUsed}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Deck Size Min / Max</div>
            <div class="stat-value">${s.deckSizeMin} / ${s.deckSizeMax}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Mods Min / Max</div>
            <div class="stat-value">${s.modCountMin} / ${s.modCountMax}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Merchant Buys</div>
            <div class="stat-value">${s.merchantBuys}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Removals</div>
            <div class="stat-value">${s.merchantRemoves}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Boss Clears</div>
            <div class="stat-value">${s.bossClears}</div>
          </div>

          <div class="stat-box" style="grid-column: 1 / -1;">
            <div class="stat-label">Tiles Entered</div>
            <div class="stat-value">${s.tilesEntered}</div>
            <div class="log-kv" style="margin-top:10px;">${tileLines || '(none yet)'}</div>
          </div>
        </div>

        <div class="log-section-title">Performance</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Match W/L/T</div>
            <div class="stat-value">${overall.matchW} / ${overall.matchL} / ${overall.matchT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Match Win Rate</div>
            <div class="stat-value">${formatRate(overall.matchW, overall.matches)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane W/L/T</div>
            <div class="stat-value">${overall.laneW} / ${overall.laneL} / ${overall.laneT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane Win Rate</div>
            <div class="stat-value">${formatRate(overall.laneW, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player Bust Rate</div>
            <div class="stat-value">${formatRate(overall.playerBustLanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player 21 Rate</div>
            <div class="stat-value">${formatRate(overall.player21Lanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Incl Bust)</div>
            <div class="stat-value">${avgLaneIncl.toFixed(1)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Excl Bust)</div>
            <div class="stat-value">${avgLaneExcl === null ? '—' : avgLaneExcl.toFixed(1)}</div>
          </div>
        </div>

        <div class="log-section-title">Breakdown by Floor</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${floorRows}
          </tbody>
        </table>

        <div class="log-section-title">Breakdown by Match Type</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Type</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${typeRows}
          </tbody>
        </table>

        <div class="log-section-title">Recent Matches</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Type</th>
              <th>Outcome</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust Lanes</th>
              <th>21 Lanes</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${recentRows}
          </tbody>
        </table>
      `;
    }

    function renderLogPanel() {
      const el = document.getElementById('logPanel');
      if (!el) return;

      const sid = gameLog ? gameLog.sessionId : '—';
      const started = gameLog ? gameLog.startedAt : '';
      const sub = started ? `Started ${started.slice(0,19).replace('T',' ')}` : '';

      el.innerHTML = `
        <div class="log-panel-header">
          <div>
            <div class="log-panel-title">Run Log</div>
            <div class="log-panel-sub">${sid} · ${sub}</div>
          </div>
          <div class="log-panel-actions">
            <button class="log-mini-btn" onclick="exportLog()">Export</button>
            <button class="log-mini-btn" onclick="clearSavedLog()">Clear</button>
            <button class="log-mini-btn danger" onclick="closeLogPanel()">Close</button>
          </div>
        </div>

        <div class="log-tabs">
          <button class="log-tab ${logPanelTab === 'events' ? 'active' : ''}" onclick="switchLogTab('events')">Events</button>
          <button class="log-tab ${logPanelTab === 'stats' ? 'active' : ''}" onclick="switchLogTab('stats')">Stats</button>
        </div>

        <div class="log-panel-body">
          ${logPanelTab === 'events' ? renderLogEvents() : renderLogStats()}
        </div>
      `;
    }

    function openSettingsPanel() {
      const checked = !!uiSettings.autoOpenLogOnEnd;
      const revealOnClose = (uiSettings.revealTotalsOnClose !== false);

      const oppDiff = getOpponentDifficulty();
      const rakeMode = (uiSettings.rakeMode || 'hard');

      const benchCap = String(safeNumber(uiSettings.benchHardCap, 3));

      const body = `
        <p class="modal-text">Lightweight runtime options for testing.</p>

        <div style="display:flex; flex-direction:column; gap:12px;">

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer;">
              <input id="setting_autoOpenLog" type="checkbox" ${checked ? 'checked' : ''} style="margin-top:3px;"/>
              <div>
                <div style="font-weight:800; color:var(--text-primary);">Auto-open Run Log on Game Over / Victory</div>
                <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">
                  Helpful for rapid playtesting and immediate review.
                </div>
              </div>
            </label>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer;">
              <input id="setting_revealTotalsOnClose" type="checkbox" ${revealOnClose ? 'checked' : ''} style="margin-top:3px;"/>
              <div>
                <div style="font-weight:800; color:var(--text-primary);">Reveal Dealer totals + hole card when a lane closes</div>
                <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">
                  If off, Dealer totals + hole card reveal only at match resolution (Spy Network still works).
                </div>
              </div>
            </label>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Opponent Difficulty</div>
            <select id="setting_opponentDifficulty" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="easy" ${oppDiff === 'easy' ? 'selected' : ''}>Easy — safer play, rarely uses bench mods</option>
              <option value="medium" ${oppDiff === 'medium' ? 'selected' : ''}>Medium — situational bench use, normal standing</option>
              <option value="hard" ${oppDiff === 'hard' ? 'selected' : ''}>Hard — counterplay-focused, proactive bench use</option>
            </select>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">House Rake</div>
            <select id="setting_rakeMode" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="easy" ${rakeMode === 'easy' ? 'selected' : ''}>Off — 0%</option>
              <option value="medium" ${rakeMode === 'medium' ? 'selected' : ''}>Flat — 10% all floors</option>
              <option value="hard" ${rakeMode === 'hard' ? 'selected' : ''}>Scaled — 10% / 20% / 30%</option>
            </select>
          </div>

          <div style="padding:12px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:12px;">
            <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Bench hard cap</div>
            <select id="setting_benchHardCap" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
              <option value="2" ${benchCap === '2' ? 'selected' : ''}>2 slots</option>
              <option value="3" ${benchCap === '3' ? 'selected' : ''}>3 slots</option>
              <option value="0" ${benchCap === '0' ? 'selected' : ''}>No cap (dev)</option>
            </select>
            <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:8px;">
              Capacity still starts at ${BENCH_BASE_CAPACITY} and grows by boss wins, but won’t exceed the cap.
            </div>
          </div>

        </div>
      `;

      showModal('Settings', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const prevSettings = getSettingsSnapshot();
            const cbLog = document.getElementById('setting_autoOpenLog');
            const cbReveal = document.getElementById('setting_revealTotalsOnClose');
            const selOpp = document.getElementById('setting_opponentDifficulty');
            const selRake = document.getElementById('setting_rakeMode');
            const selCap = document.getElementById('setting_benchHardCap');

            uiSettings.autoOpenLogOnEnd = !!(cbLog && cbLog.checked);
            uiSettings.revealTotalsOnClose = !!(cbReveal && cbReveal.checked);

            uiSettings.opponentDifficulty = (selOpp && selOpp.value) ? selOpp.value : 'hard';
            uiSettings.rakeMode = (selRake && selRake.value) ? selRake.value : 'hard';

            uiSettings.benchHardCap = safeNumber(selCap && selCap.value, 3);

            const nextSettings = getSettingsSnapshot();
            logEvent('SETTINGS_CHANGED', { prev: prevSettings, next: nextSettings });
            if (gameLog) gameLog.settingsLatest = nextSettings;

            closeModal();
            renderAll();
            showToast('Settings saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);
    }



    function openRulesPanel() {
      const html = `
      <div class="rules-wrap">
        <h3 class="rules-h">Goal of the Run</h3>
        <ul class="rules-ul">
          <li>Climb the Tower floor by floor.</li>
          <li>Win tables to earn chips, improve your deck, and advance.</li>
          <li>Clear the <b>Floor Boss</b> to move on.</li>
        </ul>

        <h3 class="rules-h">Board & Tiles</h3>
        <ul class="rules-ul">
          <li>Move tile-to-tile on each floor.</li>
          <li><b>Tables</b> start a match. <b>Services</b> improve your deck and economy.</li>
          <li>Routing is a risk choice: buy-ins vs upgrades vs recovery.</li>
        </ul>

        <h3 class="rules-h">Five-Hand Blackjack</h3>
        <ul class="rules-ul">
          <li>Each match plays across <b>five lanes</b>. Each lane is its own hand.</li>
          <li>On your turn: <b>Draw</b> → <b>Place</b> into an open lane, or use an effect, then end turn.</li>
          <li><b>Stand</b> closes a lane so no more cards can be placed there.</li>
          <li>At resolution, each lane compares totals vs the dealer’s matching lane.</li>
          <li><b>Attack rule:</b> The first player to close a lane deals an <b>Attack</b> to the opponent equal to the <b>last card played</b> to that lane before it closed.</li>
          <li><b>Tokens</b> are a consumable resource used to power certain plays and effects (including Bench plays).</li>
          <li><b>Bench</b> holds cards you set aside to play later. Bench capacity is limited.</li>
        </ul>

        <h3 class="rules-h">Side Bets</h3>
        <ul class="rules-ul">
          <li>Some matches offer a <b>Side Bet</b>.</li>
          <li>Accepting increases risk for higher payoff based on the odds shown.</li>
        </ul>

        <h3 class="rules-h">Calling Card, Karma, Rank Ups</h3>
        <ul class="rules-ul">
          <li>Choose a Calling Suit. Your Calling Card starts at <b>Rank 2</b>.</li>
          <li>Karma is earned from match performance and effects.</li>
          <li><b>Higher rank improves the rate at which your calling card’s unique suit trait triggers during gameplay.</b></li>
        </ul>

        <h3 class="rules-h">Services & Shops</h3>
        <ul class="rules-ul">
          <li><b>Shopkeeper</b>: buy cards and modifiers.</li>
          <li><b>Card Press</b>: re-suit / re-rank cards (premium services affect multiple cards).</li>
          <li><b>Collector</b>: stamps/sleeves and other upgrades.</li>
          <li><b>Loan Shark</b>: trade safety for immediate power (debt).</li>
          <li><b>Bartender</b>: purchase <b>cocktails</b>. Each cocktail can be used <b>once per match</b>.</li>
        </ul>

        <h3 class="rules-h">Floor Boss</h3>
        <ul class="rules-ul">
          <li>The Floor Boss has a <b>health pool</b> that must be depleted.</li>
          <li><b>Boss HP must be depleted before time runs out.</b></li>
          <li>Boss phases may add targeting and countermeasures.</li>
          <li>Bench persists across boss rounds.</li>
        </ul>
      </div>
      `;
      showModal("Rules", html, [{ text: 'Close', primary: true, action: () => closeModal() }]);
    }

    function openFeedbackModal() {
      const comments = run && run.feedback ? run.feedback.comments : '';
      const bugs = run && run.feedback ? run.feedback.bugs : '';
      const body = `
        <p class="modal-text">Share any feedback or bugs you noticed during the run.</p>
        <div style="display:flex; flex-direction:column; gap:12px;">
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Comments</div>
            <textarea id="feedback_comments" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${comments}</textarea>
          </div>
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Bugs</div>
            <textarea id="feedback_bugs" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${bugs}</textarea>
          </div>
        </div>
      `;
      showModal('Feedback', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const commentsEl = document.getElementById('feedback_comments');
            const bugsEl = document.getElementById('feedback_bugs');
            const next = {
              comments: commentsEl ? commentsEl.value : '',
              bugs: bugsEl ? bugsEl.value : '',
              updatedAt: new Date().toISOString()
            };
            if (run) run.feedback = next;
            if (gameLog) gameLog.feedback = { ...next };
            logEvent('FEEDBACK_UPDATED', { commentsLen: next.comments.length, bugsLen: next.bugs.length });
            closeModal();
            showToast('Feedback saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);
    }

    function openDeckViewer() {
      if (!run) return;
      const summary = buildDeckSummary();
      const stamps = summary.stampsByRank || {};
      const stampLines = Object.keys(stamps).length
        ? Object.entries(stamps).map(([rank, stampId]) => `${rank}: ${getStampDef(stampId)?.name || stampId}`).join(', ')
        : 'None';

      const bySuitLine = Object.entries(summary.bySuit)
        .map(([suit, count]) => `${suit} ${count}`)
        .join(' · ');

      const byRankLine = RANKS.map(rank => `${rank}:${summary.byRank[rank] || 0}`).join(' ');

      const standards = [];
      const modifiers = [];
      const fused = [];
      run.playerDeck.forEach(card => {
        if (isModifier(card)) modifiers.push(card);
        else if (isFused(card)) fused.push(card);
        else standards.push(card);
      });
      const rankIndex = Object.fromEntries(RANKS.map((r, i) => [r, i]));
      standards.sort((a, b) => {
        const suitIndexA = a.suit === KEY_SUIT ? 99 : SUITS.indexOf(a.suit);
        const suitIndexB = b.suit === KEY_SUIT ? 99 : SUITS.indexOf(b.suit);
        const suitDiff = suitIndexA - suitIndexB;
        if (suitDiff !== 0) return suitDiff;
        return (rankIndex[a.rank] || 0) - (rankIndex[b.rank] || 0);
      });

      const list = [...standards, ...fused, ...modifiers];
      const listHtml = list.map(card => renderCard(card, false)).join('');

      const body = `
        <div class="log-kv" style="margin-bottom:10px;">
          <div><strong>Deck size:</strong> ${summary.deckSize}</div>
          <div><strong>Standard:</strong> ${summary.deckSize - summary.modCount - summary.fusedCount} · <strong>Mods:</strong> ${summary.modCount} · <strong>Fused:</strong> ${summary.fusedCount}</div>
          <div><strong>Sleeved:</strong> ${summary.sleevedCount}</div>
          <div><strong>Stamps:</strong> ${stampLines}</div>
        </div>
        <div style="margin-bottom:10px;"><strong>By suit:</strong> ${bySuitLine}</div>
        <div style="margin-bottom:10px;"><strong>By rank:</strong> ${byRankLine}</div>
        <div class="merchant-cards">${listHtml}</div>
      `;

      showModal('Deck Viewer', body, [
        { text: 'Close', primary: true, action: () => closeModal() }
      ]);
    }

    // =============================================
    // UI: MODALS, TOAST, CONFIRM
    // =============================================
    let __modalButtons = [];
    let __modalTitle = '';
    window.__modalAction = function(i) {
      const b = __modalButtons[i];
      if (!b || b.disabled) return;
      if (typeof b.action === 'function') b.action();
    };

    function showModal(title, bodyHtml, buttons = []) {
      __modalButtons = buttons.map(b => ({ ...b }));
      __modalTitle = title || '';
      const overlay = document.getElementById('modalOverlay');
      const modal = document.getElementById('modal');
      const footer = buttons.length ? `
        <div class="modal-footer">
          ${buttons.map((b, i) => {
            const cls = [
              'modal-btn',
              b.primary ? 'primary' : '',
              b.danger ? 'danger' : ''
            ].filter(Boolean).join(' ');
            const dis = b.disabled ? 'disabled' : '';
            return `<button class="${cls}" ${dis} onclick="__modalAction(${i})">${b.text}</button>`;
          }).join('')}
        </div>
      ` : '';

      modal.innerHTML = `
        <div class="modal-header">${title}</div>
        <div class="modal-body">${bodyHtml}</div>
        ${footer}
      `;
      overlay.classList.remove('hidden');
    }

    function closeModal() {
      if (__modalTitle === 'Merchant' && run && run.floor === 2 && run.secret && run.secret.keys && run.secret.keys.merchant) {
        const mk = run.secret.keys.merchant;
        if (mk.state === 'offered') mk.state = 'missed';
      }
      __modalTitle = '';
      document.getElementById('modalOverlay').classList.add('hidden');
      document.getElementById('modal').innerHTML = '';
      __modalButtons = [];
    }

    let toastTimer = null;
    function showProcBanner(data = {}) {
      if (!blackjackMatch) return;
      blackjackMatch.procBanner = { suit: data.suit || '', title: data.title || 'Calling Proc', desc: data.desc || '' };
      renderBlackjack();
      setTimeout(() => { if (blackjackMatch) blackjackMatch.procBanner = null; renderBlackjack(); }, 1500);
    }

    function showToast(text, ms = 1600) {
      const el = document.getElementById('toast');
      el.textContent = text;
      el.classList.remove('hidden');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.classList.add('hidden');
      }, ms);
    }

    function showConfirmDialog(message, onConfirm) {
      const dialog = document.createElement('div');
      dialog.className = 'confirm-dialog';
      dialog.innerHTML = `
        <div class="confirm-content">
          <div class="confirm-message">${message}</div>
          <div class="confirm-btns">
            <button class="modal-btn danger" id="confirmYes">Yes</button>
            <button class="modal-btn" id="confirmNo">No</button>
          </div>
        </div>
      `;
      document.body.appendChild(dialog);

      dialog.querySelector('#confirmYes').onclick = () => {
        dialog.remove();
        if (onConfirm) onConfirm();
      };
      dialog.querySelector('#confirmNo').onclick = () => dialog.remove();
    }

    // ESC closes modal or log panel
    window.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      const overlay = document.getElementById('modalOverlay');
      if (overlay && !overlay.classList.contains('hidden')) closeModal();
      else if (logPanelOpen) closeLogPanel();
    });

    // =============================================
    // UTILITY FUNCTIONS
    // =============================================
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeStandardDeck52() {
      const deck = [];
      for (const s of SUITS) {
        for (const r of RANKS) deck.push({ uid: null, rank: r, suit: s, sleeveId: null, laminationId: null });
      }
      return deck;
    }

    function isModifier(c) {
      return c && c.type === 'MOD';
    }

    function isFused(c) {
      return c && c.type === 'FUSE';
    }

    function isKeyCard(c) {
      return c && c.type === 'KEY';
    }

    function makeKeyCard(source) {
      const rank = randomChoice(RANKS);
      return { uid: null, type: 'KEY', suit: KEY_SUIT, rank, keySource: source, sleeveId: null, laminationId: null };
    }

    function isStandardCard(c) {
      return c && !c.type && c.rank && c.suit;
    }

    const STAMP_DEFS = {
      PLUS_FIVE: { id: 'PLUS_FIVE', name: 'Plus Five', rarity: 'uncommon', desc: '+5 karma per stamped card in a winning lane.', icon: '+5' },
      PLUS_TEN: { id: 'PLUS_TEN', name: 'Plus Ten', rarity: 'rare', desc: '+10 karma per stamped card in a winning lane.', icon: '+10' },
      DOUBLE_DIP: { id: 'DOUBLE_DIP', name: 'Double Dip', rarity: 'uncommon', desc: 'x2 karma contribution per stamped card in a winning lane.', icon: 'x2' },
      TRIPLE_PLAY: { id: 'TRIPLE_PLAY', name: 'Triple Play', rarity: 'rare', desc: 'x3 karma contribution per stamped card in a winning lane.', icon: 'x3' },
      LANE_COUNT_MULT: { id: 'LANE_COUNT_MULT', name: 'Lane Count Mult', rarity: 'rare', desc: 'Multiply stamped-card karma by lane card count.', icon: 'N×' },
      PROXY_SUIT: { id: 'PROXY_SUIT', name: 'Proxy Suit', rarity: 'common', desc: 'Counts as calling suit for proc checks.', icon: 'PS' },
      DEJA_VU: { id: 'DEJA_VU', name: 'Deja Vu', rarity: 'rare', desc: 'Doubles card actions and karma contribution.', icon: 'DV' },
      BURN_AFTER_READING: { id: 'BURN_AFTER_READING', name: 'Burn After Reading', rarity: 'uncommon', desc: 'Remove stamped cards from deck after match.', icon: 'BR' }
    };

    const SLEEVE_DEFS = {
      CRYSTAL: { id: 'CRYSTAL', name: 'Crystal Sleeve', rarity: 'rare', desc: 'Prevent bust once by burning this card.', className: 'sleeve-crystal' },
      STEEL: { id: 'STEEL', name: 'Steel Sleeve', rarity: 'uncommon', desc: 'Lane cannot be targeted by opponent effects.', className: 'sleeve-steel' },
      GOLD: { id: 'GOLD', name: 'Gold Sleeve', rarity: 'rare', desc: 'Gain chips equal to lane total at close.', className: 'sleeve-gold' },
      BLUE: { id: 'BLUE', name: 'Blue Sleeve', rarity: 'common', desc: 'Drawn card goes to bench instead of forced play.', className: 'sleeve-blue' }
    };

    function getStampDef(id) {
      return id ? STAMP_DEFS[id] : null;
    }

    function getSleeveDef(id) {
      return id ? SLEEVE_DEFS[id] : null;
    }

    function getCardStampId(card) {
      if (!run || !run.stampsByRank) return null;
      if (!isStandardCard(card)) return null;
      return run.stampsByRank[card.rank] || null;
    }

    function assignUid(card) {
      if (!card) return null;
      if (card.uid) return card.uid;
      if (!run) return null;
      run.nextCardUid = safeNumber(run.nextCardUid, 1);
      card.uid = run.nextCardUid;
      run.nextCardUid += 1;
      return card.uid;
    }

    function cloneCardWithNewUid(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: null, type: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { ...card, uid: null };
      if (isFused(card)) return { uid: null, type: 'FUSE', a: card.a, b: card.b };
      return {
        uid: null,
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function cardRef(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { uid: card.uid || null, kind: 'KEY', rank: card.rank, suit: card.suit, keySource: card.keySource || null };
      if (isFused(card)) return { uid: card.uid || null, kind: 'FUSE', aUid: card.a?.uid || null, bUid: card.b?.uid || null };
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function getStampKarmaContribution(stampId, baseValue, laneSize) {
      switch (stampId) {
        case 'PLUS_FIVE':
          return 5;
        case 'PLUS_TEN':
          return 10;
        case 'DOUBLE_DIP':
          return baseValue;
        case 'TRIPLE_PLAY':
          return baseValue * 2;
        case 'LANE_COUNT_MULT':
          return baseValue * laneSize;
        case 'DEJA_VU':
          return baseValue;
        default:
          return 0;
      }
    }

    function cardToString(c) {
      if (!c) return '';
      if (isModifier(c)) return c.delta > 0 ? `+${c.delta}` : `${c.delta}`;
      if (isFused(c)) return `${cardToString(c.a)}/${cardToString(c.b)}`;
      return `${c.rank}${c.suit}`;
    }

    function isRedSuit(suit) {
      return suit === '♥' || suit === '♦';
    }

    function cardCssClass(card) {
      if (isModifier(card)) return 'mod';
      if (isFused(card)) return 'fused';
      if (isKeyCard(card)) return 'black';
      const classes = [isRedSuit(card.suit) ? 'red' : 'black'];
      if (card && card.sleeveId) {
        const sleeve = getSleeveDef(card.sleeveId);
        if (sleeve && sleeve.className) classes.push(sleeve.className);
      }
      return classes.join(' ');
    }

    function rankToValue(rank) {
      if (rank === 'A') return 14;
      if (rank === 'K') return 13;
      if (rank === 'Q') return 12;
      if (rank === 'J') return 11;
      const n = Number(rank);
      return Number.isFinite(n) ? n : 0;
    }

    function valueToRank(value) {
      if (value === 14) return 'A';
      if (value === 13) return 'K';
      if (value === 12) return 'Q';
      if (value === 11) return 'J';
      return String(value);
    }

    function suitColor(suit) {
      return (suit === '♥' || suit === '♦') ? 'red' : 'black';
    }

    function getAffinity(playerSuit, npcSuit) {
      if (!playerSuit || !npcSuit) return 'neutral';
      if (playerSuit === npcSuit) return 'resonant';
      if (suitColor(playerSuit) === suitColor(npcSuit)) return 'dissonant';
      return 'neutral';
    }

    function affinityIcon(affinity) {
      if (affinity === 'resonant') return '+';
      if (affinity === 'dissonant') return '-';
      return '•';
    }

    function getCallingRankInfo() {
      if (!run || !run.callingCard) return null;
      const rank = run.callingCard.rank || '2';
      const idx = CALLING_RANK_THRESHOLDS.findIndex(t => t.rank === rank);
      const safeIdx = idx >= 0 ? idx : 0;
      const current = CALLING_RANK_THRESHOLDS[safeIdx];
      const next = CALLING_RANK_THRESHOLDS[safeIdx + 1] || null;
      const karma = safeNumber(run.karma, 0);
      const prevKarma = current ? current.karma : 0;
      const nextKarma = next ? next.karma : prevKarma;
      const span = Math.max(1, nextKarma - prevKarma);
      const progress = next ? Math.max(0, Math.min(1, (karma - prevKarma) / span)) : 1;
      return {
        rank,
        current,
        next,
        isMax: !next,
        progress,
        toNext: next ? Math.max(0, next.karma - karma) : 0
      };
    }

    function maybeLevelUpCallingCardFromKarma() {
      if (!run || !run.callingCard) return null;
      const fromRank = run.callingCard.rank || '2';
      let idx = CALLING_RANK_THRESHOLDS.findIndex(t => t.rank === fromRank);
      if (idx < 0) idx = 0;
      let gained = 0;
      while (idx + 1 < CALLING_RANK_THRESHOLDS.length && safeNumber(run.karma, 0) >= CALLING_RANK_THRESHOLDS[idx + 1].karma) {
        idx += 1;
        gained += 1;
      }
      if (gained <= 0) return null;
      const toRank = CALLING_RANK_THRESHOLDS[idx].rank;
      run.callingCard.rank = toRank;
      run.ui.callingRankPulseUntil = Date.now() + 1500;
      logEvent('CALLING_CARD_LEVEL_UP', {
        fromRank,
        toRank,
        levelsGained: gained,
        karmaAtLevelUp: run.karma
      });
      showToast(`Calling Card leveled up: ${fromRank} → ${toRank}`);
      renderHUD();
      return { fromRank, toRank, levelsGained: gained };
    }

    function getCardValueOptions(card) {
      if (!card || isModifier(card)) return [];
      if (isFused(card)) {
        const options = [
          ...getCardValueOptions(card.a),
          ...getCardValueOptions(card.b)
        ];
        return Array.from(new Set(options));
      }
      if (card.rank === 'A') return [1, 11];
      if (['J', 'Q', 'K'].includes(card.rank)) return [10];
      const n = Number(card.rank);
      return Number.isFinite(n) ? [n] : [];
    }

    // Harden total calc to never produce NaN (supports fused + aces)
    function calcBestTotal(cards, modSum = 0) {
      let totals = [0];
      for (const c of cards || []) {
        const options = getCardValueOptions(c);
        if (!options.length) continue;
        const nextTotals = [];
        for (const t of totals) {
          for (const v of options) nextTotals.push(t + v);
        }
        totals = nextTotals;
      }
      totals = totals.map(t => t + modSum);
      const under = totals.filter(t => t <= 21);
      if (under.length) return Math.max(...under);
      return totals.length ? Math.min(...totals) : 0;
    }

    function hexPath(x, y) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i - 30);
        pts.push([x + HEX_SIZE * Math.cos(angle), y + HEX_SIZE * Math.sin(angle)]);
      }
      return `M ${pts.map(p => p.join(',')).join(' L ')} Z`;
    }

    function removeOne(arr, item) {
      const idx = arr.indexOf(item);
      if (idx !== -1) arr.splice(idx, 1);
    }

    function clampAddBankedToken(n = 1) {
      run.bankedTokens = Math.min(ACTION_TOKEN_MAX_BANKED, (run.bankedTokens || 0) + n);
    }

    function distinctRandomIndices(n, length) {
      const idxs = Array.from({ length }, (_, i) => i);
      const s = shuffle(idxs);
      return s.slice(0, Math.min(n, s.length));
    }

    // Merchant random offer: standard card OR modifier (intermixed)
    function cloneDeck(deck) {
      return (deck || []).map(card => {
        const c = cloneCardWithNewUid(card);
        assignUid(c);
        return c;
      });
    }

    function randomCard() {
      if (Math.random() < MOD_OFFER_CHANCE) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        return { uid: null, type: 'MOD', delta };
      }
      return {
        uid: null,
        rank: RANKS[Math.floor(Math.random() * RANKS.length)],
        suit: SUITS[Math.floor(Math.random() * SUITS.length)],
        sleeveId: null,
        laminationId: null
      };
    }

    function safeNumber(x, fallback = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : fallback;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }


// =============================================
// ECONOMY / LIMIT HELPERS
// =============================================
function getHouseRakeRate(floor) {
  const mode = (uiSettings && uiSettings.rakeMode) || 'hard';

  if (mode === 'easy') return 0;
  if (mode === 'medium') return 0.10;

  // hard = 10/20/30 by floor (default behavior)
  const hardRates = { 1: 0.10, 2: 0.20, 3: 0.30 };
  const r = hardRates[String(floor)] ?? hardRates[floor] ?? 0;
  return Math.max(0, Math.min(0.95, safeNumber(r, 0)));
}

function getOpponentDifficulty() {
  const d = (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard';
  return (d === 'easy' || d === 'medium' || d === 'hard') ? d : 'hard';
}

function getMerchantPriceMult() {
  const ctx = run && run.ui && run.ui.merchantContext;
  const mult = ctx && typeof ctx.priceMult === 'number' ? ctx.priceMult : 1;
  return Math.max(0.75, Math.min(1.25, mult));
}

function getMerchantRemovalCost() {
  const n = safeNumber(run && run.paidRemovalCount, 0);
  const base = MERCHANT_REMOVE_COST + (n * MERCHANT_REMOVE_INCREMENT);
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantCost(base) {
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantBuyCost(card) {
  if (isKeyCard(card)) return KEY_MERCHANT_COST;
  const isMod = isModifier(card);
  const base = isMod ? MERCHANT_BUY_BASE_MOD : MERCHANT_BUY_BASE_STANDARD;
  const count = isMod
    ? safeNumber(run && run.merchantModifierBuys, 0)
    : safeNumber(run && run.merchantStandardBuys, 0);
  const scaled = base + (MERCHANT_BUY_INCREMENT * count);
  return Math.ceil(scaled * getMerchantPriceMult());
}

function getModifyServiceCost(serviceId, floor) {
  const baseFloor = Math.max(1, safeNumber(floor, 1));
  const isPremium = serviceId === 'CALLING_SUIT_SWEEP' || serviceId === 'UNIFORM_RANK_PRESS';
  const base = isPremium ? 200 : 100;
  const step = isPremium ? 50 : 25;
  return base + ((baseFloor - 1) * step);
}

function getModKey(delta) { return String(delta); }

function getModifierPurchased(delta) {
  const key = getModKey(delta);
  return safeNumber(run && run.modPurchaseCounts && run.modPurchaseCounts[key], 0);
}

function getModifierRemaining(delta) {
  return Math.max(0, MOD_PURCHASE_LIMIT_PER_DELTA - getModifierPurchased(delta));
}

function recordModifierPurchase(delta) {
  const key = getModKey(delta);
  if (!run.modPurchaseCounts) run.modPurchaseCounts = {};
  run.modPurchaseCounts[key] = getModifierPurchased(delta) + 1;
}

function getBenchCapacity() {
  const wins = safeNumber(run && run.bossWins, 0);
  const uncapped = BENCH_BASE_CAPACITY + (wins * BENCH_CAPACITY_BONUS_PER_BOSS_WIN);

  const cap = safeNumber(uiSettings && uiSettings.benchHardCap, 0);
  if (cap > 0) return Math.max(1, Math.min(cap, uncapped));
  return uncapped;
}


// Push to bench with FIFO overflow (oldest discarded if full)
function benchPush(card, source = '') {
  if (!blackjackMatch) return;
  const cap = getBenchCapacity();
  blackjackMatch.bench = blackjackMatch.bench || [];
  let removed = null;

  if (blackjackMatch.bench.length >= cap) {
    removed = blackjackMatch.bench.shift();

    // keep armed index stable
    if (blackjackMatch.armedBenchIdx !== null && blackjackMatch.armedBenchIdx !== undefined) {
      if (blackjackMatch.armedBenchIdx === 0) blackjackMatch.armedBenchIdx = null;
      else blackjackMatch.armedBenchIdx = Math.max(0, blackjackMatch.armedBenchIdx - 1);
    }

    logEvent('BENCH_OVERFLOW', { removed: cardToString(removed), added: cardToString(card), cap, source });
    showToast(`Bench full (${cap}). Discarded ${cardToString(removed)}.`);
  }

  blackjackMatch.bench.push(card);
  return removed;
}


    // =============================================
    // BOARD GENERATION
    // =============================================
    const NPC_NAMES = ['Rowan', 'Maris', 'Calder', 'June', 'Sable', 'Nico', 'Arden', 'Vale', 'Tamsin', 'Quinn', 'Otto', 'Liora'];

    function randomChoice(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function rollNpcRankValue(floor, type) {
      const roll = Math.random();
      if (type === 'STANDARD') {
        if (floor === 1) {
          if (roll < 0.02) return randInt(12, 14);
          if (roll < 0.12) return randInt(9, 11);
          return randInt(2, 8);
        }
        if (floor === 2) {
          if (roll < 0.02) return 14;
          if (roll < 0.12) return randInt(11, 13);
          return randInt(4, 10);
        }
        if (roll < 0.10) return randInt(13, 14);
        return randInt(6, 12);
      }
      if (type === 'HIGH_STAKES') {
        if (floor === 1) {
          if (roll < 0.10) return randInt(12, 14);
          return randInt(6, 11);
        }
        if (floor === 2) {
          if (roll < 0.10) return 14;
          return randInt(8, 13);
        }
        return randInt(10, 14);
      }
      if (type === 'BOSS') {
        if (floor === 1) {
          if (roll < 0.20) return 14;
          return randInt(10, 13);
        }
        if (floor === 2) return randInt(12, 14);
        return 14;
      }
      return randInt(4, 12);
    }

    function makeNpcName(type) {
      const base = randomChoice(NPC_NAMES);
      if (type === 'HIGH_STAKES') return `High Roller ${base}`;
      if (type === 'BOSS') return `Floor Boss: ${base}`;
      return base;
    }

    function createNpcForTile(floor, type) {
      const tableTypes = ['STANDARD', 'HIGH_STAKES', 'BOSS'];
      const roleSuits = {
        BARTENDER: '♥',
        MERCHANT: '♦',
        LOAN_SHARK: '♣'
      };

      if (!tableTypes.includes(type) && !roleSuits[type]) return null;

      const suit = roleSuits[type] || randomChoice(['♥', '♠', '♦', '♣']);
      const rankValue = rollNpcRankValue(floor, type);
      const rank = valueToRank(rankValue);
      const name = makeNpcName(type);
      return { name, callingCard: { rank, suit } };
    }

    function buildTilePoolForFloor(floor) {
      const pool = [];
      const counts = FLOOR_COUNTS[floor];

      let standardCount = counts.standard;
      let highCount = counts.high;
      if (standardCount > 0) standardCount -= 1;
      else if (highCount > 0) highCount -= 1;

      for (let i = 0; i < standardCount; i++) pool.push('STANDARD');
      for (let i = 0; i < highCount; i++) pool.push('HIGH_STAKES');
      pool.push('COLLECTOR');

      pool.push('BARTENDER');
      pool.push('MINIGAME');
      pool.push('REST_STOP', 'REST_STOP');
      pool.push('MERCHANT', 'MODIFY');
      pool.push('LOAN_SHARK');

      return pool;
    }

    function assignTilesToNodes(floor) {
      const pool = shuffle(buildTilePoolForFloor(floor));
      const tiles = new Array(21).fill(null);

      // Boss at 0
      tiles[0] = 'BOSS';

      // Starting row: one must be bartender
      const startIds = [18, 19, 20];
      const bartenderId = startIds[Math.floor(Math.random() * startIds.length)];
      tiles[bartenderId] = 'BARTENDER';
      removeOne(pool, 'BARTENDER');

      // Fill other two starts
      for (const id of startIds) {
        if (!tiles[id]) tiles[id] = pool.pop();
      }

      // Fill 1-17
      for (let id = 1; id <= 17; id++) tiles[id] = pool.pop();
      return tiles;
    }

    function generateBoard(floor) {
      const tileTypes = assignTilesToNodes(floor);
      const tiles = [];

      for (const [id, x, y, connections] of NODES) {
        const tileType = tileTypes[id];
        const npc = createNpcForTile(floor, tileType);
        tiles.push({
          id,
          type: tileType,
          label: TILE_LABELS[tileType],
          color: TILE_COLORS[tileType],
          center: [x, y],
          svgPath: hexPath(x, y),
          connections,
          isStartRow: id >= 18,
          npc
        });
      }

      return tiles;
    }

    // =============================================
    // RUN INITIALIZATION
    // =============================================
    function initRun() {
      clearDealerTimers();

      run = {
        floor: 1,
        chips: STARTING_CHIPS,
        karma: 0,
        karmaWinStreak: 0,
        callingCard: null,
        callingCardChosenSuit: null,
        playerName: loadPlayerName() || '',
        playerDeck: makeStandardDeck52(),
        stampsByRank: {},
        collectorShop: null,
        ownedActions: [],
        nextCardUid: 1,
        matchSeq: 0,
        encounterSeq: 0,
        activeEncounter: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        bankedTokens: 0,
        bossWins: 0,
        bossFight: null,
        secret: {
          keys: {
            highStakes: { obtained: false, floor: 1, tileId: null, hinted: false },
            merchant: { state: 'unseen', floor: 2, chance: 0.05 },
            boss: { obtained: false, floor: 3 }
          }
        },
        paidRemovalCount: 0,
        merchantStandardBuys: 0,
        merchantModifierBuys: 0,
        modPurchaseCounts: Object.fromEntries(MODIFIER_DELTAS.map(d => [String(d), 0])),
        loan: { active: false, repaid: false },
        board: {
          tiles: [],
          currentTileId: null,
          visited: new Set(),
          path: []
        },
        ui: {
          mode: 'INTRO',
          message: '',
          callingRankPulseUntil: 0,
          karmaTallyFast: false,
          hudCollapsed: (window.innerWidth <= 520)
        },
        intro: {
          step: null,
          name: '',
          suit: null,
          callingCard: null
        }
      };

      resetLog();
      run.playerDeck.forEach(card => assignUid(card));
      run.intro.name = run.playerName || '';
      run.intro.step = run.playerName ? 'suit' : 'name';
      renderAll();
    }

    function initFloor(floor) {
      clearDealerTimers();

      run.floor = floor;
      run.bossFight = null;
      run.board.tiles = generateBoard(floor);
      run.board.currentTileId = null;
      run.board.visited = new Set();
      run.board.path = [];
      if (floor === 1 && run.secret && run.secret.keys && !run.secret.keys.highStakes.tileId) {
        const highs = run.board.tiles.filter(t => t.type === 'HIGH_STAKES');
        if (highs.length) {
          const pick = randomChoice(highs);
          run.secret.keys.highStakes.tileId = pick.id;
        }
      }
      run.ui.mode = 'BOARD';

      logEvent('FLOOR_START', { floor });
      run.board.tiles.forEach(tile => {
        if (tile.npc) {
          logEvent('NPC_ASSIGNED', {
            floor,
            tileId: tile.id,
            tileType: tile.type,
            npcName: tile.npc.name,
            npcCallingCard: tile.npc.callingCard
          });
        }
      });

      renderAll();
    }

    // =============================================
    // MOVEMENT
    // =============================================
    function getAvailableMoves() {
      const currentId = run.board.currentTileId;
      if (currentId === null) return [18, 19, 20].filter(id => !run.board.visited.has(id));
      const current = run.board.tiles[currentId];
      return current.connections.filter(id => !run.board.visited.has(id));
    }

    function enterTile(tileId) {
      run.board.currentTileId = tileId;
      run.board.visited.add(tileId);
      run.board.path.push(tileId);

      const tileType = run.board.tiles[tileId].type;
      run.encounterSeq = safeNumber(run.encounterSeq, 0) + 1;
      run.activeEncounter = { seq: run.encounterSeq, type: tileType, tileId, tileType };
      logEvent('TILE_ENTER', { tileId, tileType });

      renderBoard();
      resolveTileEncounter(tileType);
    }

    // =============================================
    // ENCOUNTERS
    // =============================================
    function resolveTileEncounter(tileType) {
      switch (tileType) {
        case 'REST_STOP': encounterRest(); break;
        case 'BARTENDER': encounterBartender(); break;
        case 'MINIGAME': encounterMinigame(); break;
        case 'LOAN_SHARK': encounterLoanShark(); break;
        case 'MERCHANT': encounterMerchant(); break;
        case 'MODIFY': encounterModify(); break;
        case 'COLLECTOR': encounterCollector(); break;
        case 'STANDARD': encounterBlackjackStandard(); break;
        case 'HIGH_STAKES': encounterBlackjackHigh(); break;
        case 'BOSS': encounterBoss(); break;
      }
    }

    // --- Rest Stop: choose FREE removal OR +50 chips, then always +1 banked token ---
    function encounterRest() {
      showModal('Rest Stop', `
        <p class="modal-text">You take a moment to rest. Choose one benefit.</p>
        <p class="modal-text" style="margin-top:-6px;"><span style="color:var(--accent-purple); font-weight:700;">Also:</span> You will gain <strong>+1 banked Action Token</strong> regardless of choice.</p>
      `, [
        {
          text: 'Free Card Removal',
          primary: true,
          action: () => {
            logEvent('REST_CHOICE', { choice: 'free_removal', freeRemoval: true });
            openFreeRemovalPicker('Rest Stop - Free Removal', () => {
              clampAddBankedToken(1);
              logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
              renderHUD();
              showToast('+1 banked token');
            });
          }
        },
        {
          text: `Take +${REST_REWARD} Chips`,
          action: () => {
            run.chips = safeNumber(run.chips) + REST_REWARD;
            clampAddBankedToken(1);
            logEvent('REST_CHOICE', { choice: 'chips', chips: REST_REWARD });
            logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
            closeModal();
            renderAll();
            showToast(`+${REST_REWARD} chips, +1 banked token`);
          }
        },
        { text: 'Leave', action: () => {
          clampAddBankedToken(1);
          logEvent('REST_CHOICE', { choice: 'leave' });
          logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
          closeModal();
          renderAll();
          showToast('+1 banked token');
        } }
      ]);
    }

    // helper: free removal picker (3 random cards, choose one or none)
    function openFreeRemovalPicker(title, onDone) {
      const pool = run.playerDeck.filter(c => !isKeyCard(c));
      const candidates = shuffle(pool.slice()).slice(0, Math.min(3, pool.length)).map(card => ({ card }));
      let selected = null;

      function renderPicker() {
        let body = `
          <p class="modal-text">Select a card to remove (free). You may also choose none.</p>
          <div class="removal-picker">
            <div class="removal-cards">
              ${candidates.map((d, idx) => {
                const sel = selected === idx ? 'selected' : '';
                return `
                  <div class="removal-card-option ${sel}" onclick="selectFreeRemoval(${idx})">
                    ${renderCard(d.card, false)}
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;

        showModal(title, body, [
          { text: 'Confirm', primary: true, disabled: selected === null, action: confirm },
          { text: 'Choose None', action: skip },
        ]);
      }

      window.selectFreeRemoval = function(idx) {
        selected = idx;
        renderPicker();
      };

      function confirm() {
        if (selected === null) return;
        const d = candidates[selected];
        const idx = run.playerDeck.indexOf(d.card);
        if (idx !== -1) run.playerDeck.splice(idx, 1);
        logEvent('FREE_REMOVAL', { card: cardToString(d.card), cardUid: d.card.uid || null, cardRef: cardRef(d.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('FREE_REMOVAL');
        closeModal();
        renderAll();
        showToast(`Removed ${cardToString(d.card)} (free)`);
        if (onDone) onDone();
      }

      function skip() {
        logEvent('FREE_REMOVAL_SKIP', {});
        closeModal();
        renderAll();
        if (onDone) onDone();
      }

      renderPicker();
    }

    // --- Bartender: choose +50 chips OR buy cocktail (150). Only one choice. ---
    function encounterBartender() {
      const allIds = Object.keys(ACTIONS);
      const unowned = allIds.filter(id => !run.ownedActions.includes(id));
      const offeredId = unowned.length ? unowned[Math.floor(Math.random() * unowned.length)] : null;

      const canBuy = offeredId && run.chips >= COCKTAIL_COST;
      const ownedCount = run.ownedActions.length;

      let offerHtml = '';
      const hsKey = run.secret && run.secret.keys ? run.secret.keys.highStakes : null;
      if (hsKey && !hsKey.obtained && run.floor === hsKey.floor && !hsKey.hinted && hsKey.tileId !== null) {
        offerHtml += `<p class="modal-text">"High roller on this floor. Find the right table and win big."</p>`;
        hsKey.hinted = true;
      }
      if (!offeredId) {
        offerHtml = `
          <p class="modal-text">The bartender has no new cocktails to offer right now.</p>
          <p class="modal-text">You can still take <strong>+${BARTENDER_REWARD} chips</strong> if you want.</p>
        `;
      } else {
        offerHtml = `
          <p class="modal-text">The bartender offers you a choice: take chips for luck, or buy a cocktail that unlocks a match action.</p>
          <div style="padding:12px; border:1px solid var(--border-color); border-radius:12px; background: var(--bg-card); margin: 14px 0;">
            <div style="font-family:'Cinzel', serif; color: var(--accent-gold); text-transform: uppercase; letter-spacing: 1px; font-size: 14px;">
              Cocktail Offer
            </div>
            <div style="margin-top:8px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
              <div style="flex:1;">
                <div style="font-weight:800; color: var(--text-primary);">${ACTIONS[offeredId].name}</div>
                <div style="color: var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">${ACTIONS[offeredId].desc}</div>
              </div>
              <div style="font-family:'Fira Code', monospace; color: var(--accent-purple); font-weight:800;">${COCKTAIL_COST} chips</div>
            </div>
          </div>
          <p class="modal-text" style="margin-top:-6px; color: var(--text-muted);">Actions owned: ${ownedCount}</p>
        `;
      }

      showModal('Bartender', offerHtml, [
        {
          text: `Take +${BARTENDER_REWARD} Chips`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + BARTENDER_REWARD;
            logEvent('BARTENDER_TAKE', { chips: BARTENDER_REWARD });
            closeModal();
            renderAll();
            showToast(`+${BARTENDER_REWARD} chips`);
          }
        },
        {
          text: offeredId ? `Buy Cocktail (${COCKTAIL_COST})` : 'Buy Cocktail (Unavailable)',
          disabled: !canBuy,
          action: () => {
            if (!offeredId) return;
            if (run.chips < COCKTAIL_COST) return;
            run.chips -= COCKTAIL_COST;
            run.ownedActions.push(offeredId);
            logEvent('COCKTAIL_BOUGHT', { actionId: offeredId, actionName: ACTIONS[offeredId].name, cost: COCKTAIL_COST });
            closeModal();
            renderAll();
            showToast(`Unlocked: ${ACTIONS[offeredId].name}`);
          }
        },
        { text: 'Leave', action: () => { closeModal(); renderAll(); } }
      ]);
    }

    // --- Minigame: +50 chips and +1 banked token ---
    function encounterMinigame() {
      run.chips = safeNumber(run.chips) + MINIGAME_REWARD;
      clampAddBankedToken(1);
      logEvent('MINIGAME', { chips: MINIGAME_REWARD, tokens: 1 });
      logEvent('TOKEN_GAIN', { amount: 1, source: 'MINIGAME' });
      showModal('Minigame', `
        <p class="modal-text">You win a quick side game.</p>
        <div class="modal-reward">+${MINIGAME_REWARD} chips</div>
        <p class="modal-text" style="text-align:center; color: var(--accent-purple); font-weight:800;">+1 banked Action Token</p>
      `, [{ text: 'Continue', primary: true, action: () => { closeModal(); renderAll(); } }]);
    }

    function encounterLoanShark() {
      const canTakeLoan = !run.loan.active;

      let body = '<p class="modal-text">The loan shark eyes you carefully.</p>';

      if (canTakeLoan) {
        body += `<p class="modal-text">"Need some chips? I can lend you ${LOAN_AMOUNT}, but you'll owe me ${LOAN_REPAY} before you face the final boss."</p>`;
      } else if (run.loan.active && !run.loan.repaid) {
        body += `<p class="modal-text">"You already owe me ${LOAN_REPAY}. Don't forget to pay up before the final boss."</p>`;
      } else {
        body += '<p class="modal-text">"Our business is concluded. Good luck."</p>';
      }

      const buttons = [];
      if (canTakeLoan) {
        buttons.push({
          text: `Take Loan (+${LOAN_AMOUNT})`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + LOAN_AMOUNT;
            run.loan.active = true;
            run.loan.repaid = false;
            logEvent('LOAN_TAKEN', { amount: LOAN_AMOUNT, repay: LOAN_REPAY });
            closeModal();
            renderAll();
            showToast(`Borrowed ${LOAN_AMOUNT} chips. Repay ${LOAN_REPAY} before Floor 3 boss!`);
          }
        });
      }
      buttons.push({ text: 'Decline', action: () => { closeModal(); renderAll(); } });

      showModal('Loan Shark', body, buttons);
    }

    // =============================================
    // MODIFY
    // =============================================
    const MODIFY_SERVICES = {
      RESUIT: { id: 'RESUIT', name: 'Re-Suit', tier: 'core', kind: 'single' },
      RERANK: { id: 'RERANK', name: 'Re-Rank', tier: 'core', kind: 'single' },
      CALLING_SUIT_SWEEP: { id: 'CALLING_SUIT_SWEEP', name: 'Calling Suit Sweep', tier: 'premium', kind: 'bulk' },
      UNIFORM_RANK_PRESS: { id: 'UNIFORM_RANK_PRESS', name: 'Uniform Rank Press', tier: 'premium', kind: 'bulk' }
    };

    function getEligibleStandardIndices() {
      if (!run || !run.playerDeck) return [];
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (isStandardCard(card)) eligible.push(idx);
      });
      return eligible;
    }

    function buildModifyOffers() {
      const eligible = getEligibleStandardIndices();
      if (!eligible.length) return [];
      const services = [MODIFY_SERVICES.RESUIT.id, MODIFY_SERVICES.RERANK.id];
      services.push(MODIFY_SERVICES.UNIFORM_RANK_PRESS.id);
      if (run && run.callingCard) services.push(MODIFY_SERVICES.CALLING_SUIT_SWEEP.id);
      return shuffle(services).slice(0, Math.min(2, services.length));
    }

    function encounterModify() {
      const offers = buildModifyOffers();
      const eligibleCount = getEligibleStandardIndices().length;

      run.ui.modifyContext = {
        tileId: run.board.currentTileId,
        servicesOffered: offers,
        serviceUsed: false,
        selectedServiceId: null,
        previewIndices: [],
        rankChoices: null
      };

      logEvent('MODIFY_ENTER', {
        tileId: run.board.currentTileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length,
        eligibleCount,
        servicesOffered: offers
      });

      renderModifyMenu();
    }

    function renderModifyMenu() {
      const ctx = run.ui.modifyContext || {};
      const eligibleCount = getEligibleStandardIndices().length;
      const offers = ctx.servicesOffered || [];
      const inProgress = !!ctx.selectedServiceId && !ctx.serviceUsed;
      const chipsNow = safeNumber(run.chips);

      let body = `
        <p class="modal-text">Modify changes cards already in your deck (base cards only). Choose one service.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Eligible cards: <strong>${eligibleCount}</strong></p>
      `;

      if (!eligibleCount) {
        body += `<p class="modal-text" style="color:var(--text-muted);">No eligible cards to modify.</p>`;
      } else if (inProgress) {
        const meta = MODIFY_SERVICES[ctx.selectedServiceId];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Service in progress: ${meta ? meta.name : ctx.selectedServiceId}</p>`;
      } else if (ctx.serviceUsed) {
        body += `<p class="modal-text" style="color:var(--accent-green); font-weight:700;">Service completed.</p>`;
      }

      const buttons = [];
      if (eligibleCount && !ctx.serviceUsed && !inProgress) {
        offers.forEach(serviceId => {
          const meta = MODIFY_SERVICES[serviceId];
          const cost = getModifyServiceCost(serviceId, run.floor);
          buttons.push({
            text: `${meta ? meta.name : serviceId} (${cost})`,
            primary: true,
            disabled: chipsNow < cost,
            action: () => selectModifyService(serviceId)
          });
        });
      } else if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openModifyService(ctx.selectedServiceId)
        });
      }

      if (!inProgress) {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('MODIFY_LEAVE', { tileId: run.board.currentTileId });
            run.ui.modifyContext = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Modify', body, buttons);
    }

    function selectModifyService(serviceId) {
      const ctx = run.ui.modifyContext;
      if (!ctx || ctx.serviceUsed) return;
      const meta = MODIFY_SERVICES[serviceId];
      const cost = getModifyServiceCost(serviceId, run.floor);
      if (run.chips < cost) return;

      const chipsBefore = run.chips;
      run.chips -= cost;
      ctx.selectedServiceId = serviceId;
      logEvent('MODIFY_SERVICE_SELECT', {
        serviceId,
        tier: meta ? meta.tier : null,
        kind: meta ? meta.kind : null,
        cost,
        chipsBefore,
        chipsAfter: run.chips
      });
      openModifyService(serviceId);
    }

    function openModifyService(serviceId) {
      if (serviceId === MODIFY_SERVICES.RESUIT.id) {
        openModifyCorePicker('Re-Suit', serviceId);
        return;
      }
      if (serviceId === MODIFY_SERVICES.RERANK.id) {
        openModifyCorePicker('Re-Rank', serviceId);
        return;
      }
      if (serviceId === MODIFY_SERVICES.CALLING_SUIT_SWEEP.id) {
        openModifyCallingSuitSweep();
        return;
      }
      if (serviceId === MODIFY_SERVICES.UNIFORM_RANK_PRESS.id) {
        openModifyUniformRankPress();
      }
    }

    function openModifyCorePicker(title, serviceId) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;
      const meta = MODIFY_SERVICES[serviceId];
      logEvent('MODIFY_CANDIDATES_SHOWN', {
        serviceId,
        tier: meta ? meta.tier : null,
        countShown: sample.length,
        candidates: sample.map(i => cardRef(run.playerDeck[i]))
      });

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="selectModifyCoreCard(${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Modify - ${title}`, `
        <p class="modal-text">Choose a card to modify.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);

      window.selectModifyCoreCard = function(deckIdx) {
        logEvent('MODIFY_SELECTION', {
          serviceId,
          selected: cardRef(run.playerDeck[deckIdx])
        });
        if (serviceId === MODIFY_SERVICES.RESUIT.id) {
          openModifySuitPicker(deckIdx);
        } else {
          openModifyRankPicker(deckIdx);
        }
      };
    }

    function openModifySuitPicker(deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;

      showModal('Modify - Re-Suit', `
        <p class="modal-text">Choose a new suit for ${cardToString(card)}.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          ${SUITS.map(suit => `<button class="modal-btn" onclick="applyModifyResuit(${deckIdx}, '${suit}')">${suit}</button>`).join('')}
        </div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function openModifyRankPicker(deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;

      const ranksHtml = RANKS.map(rank => `<button class="modal-btn" onclick="applyModifyRerank(${deckIdx}, '${rank}')">${rank}</button>`).join('');
      showModal('Modify - Re-Rank', `
        <p class="modal-text">Choose a new rank for ${cardToString(card)}.</p>
        <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px;">${ranksHtml}</div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    window.applyModifyResuit = function(deckIdx, suit) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;
      applyModifyService('RESUIT', [deckIdx], () => { card.suit = suit; });
    };

    window.applyModifyRerank = function(deckIdx, rank) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;
      applyModifyService('RERANK', [deckIdx], () => { card.rank = rank; });
    };

    function openModifyCallingSuitSweep() {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      showModal('Modify - Calling Suit Sweep', `
        <p class="modal-text">Preview the cards that will be re-suited to ${run.callingCard ? run.callingCard.suit : ''}.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        {
          text: 'Confirm',
          primary: true,
          action: () => {
            applyModifyService('CALLING_SUIT_SWEEP', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.suit = run.callingCard.suit;
              });
            });
          }
        },
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function openModifyUniformRankPress() {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      ctx.previewIndices = sample;
      const ranks = shuffle(RANKS.slice()).slice(0, 2);
      ctx.rankChoices = ranks;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      showModal('Modify - Uniform Rank Press', `
        <p class="modal-text">Choose a rank to press onto these cards.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        ...ranks.map(rank => ({
          text: `Set to ${rank}`,
          primary: true,
          action: () => {
            applyModifyService('UNIFORM_RANK_PRESS', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.rank = rank;
              });
            });
          }
        })),
        { text: 'Back', action: () => renderModifyMenu() }
      ]);
    }

    function applyModifyService(serviceId, indices, applyFn) {
      const ctx = run.ui.modifyContext;
      const before = indices.map(i => cardToString(run.playerDeck[i]));
      const affectedUids = indices.map(i => run.playerDeck[i]?.uid || null);
      applyFn();
      const after = indices.map(i => cardToString(run.playerDeck[i]));

      logEvent('MODIFY_APPLY', {
        serviceId,
        count: indices.length,
        affectedCardUids: affectedUids,
        affectedBefore: before,
        affectedAfter: after,
        deckSnapshot: deckSnapshot()
      });
      recordDeckSnapshot('MODIFY_APPLY');

      if (ctx) {
        ctx.serviceUsed = true;
        ctx.selectedServiceId = null;
        ctx.previewIndices = [];
        ctx.rankChoices = null;
      }

      renderModifyMenu();
      renderAll();
      showToast('Modify service applied');
    }

    // =============================================
    // COLLECTOR
    // =============================================
    const COLLECTOR_CATALOG = [
      ...Object.values(STAMP_DEFS).map(def => ({ ...def, type: 'STAMP' })),
      ...Object.values(SLEEVE_DEFS).map(def => ({ ...def, type: 'SLEEVE' }))
    ];

    function rollCollectorRarity() {
      const roll = Math.random();
      if (roll < 0.70) return 'common';
      if (roll < 0.95) return 'uncommon';
      return 'rare';
    }

    function randomCollectorItem() {
      const rarity = rollCollectorRarity();
      const pool = COLLECTOR_CATALOG.filter(item => item.rarity === rarity);
      const fallback = COLLECTOR_CATALOG;
      const source = pool.length ? pool : fallback;
      const pick = source[Math.floor(Math.random() * source.length)];
      return { ...pick, purchased: false };
    }

    function getEligibleStampRanks() {
      const ranks = new Set();
      for (const card of run.playerDeck) {
        if (!isStandardCard(card)) continue;
        if (run.stampsByRank && run.stampsByRank[card.rank]) continue;
        ranks.add(card.rank);
      }
      return Array.from(ranks);
    }

    function getEligibleSleeveCardIndices() {
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (!isStandardCard(card)) return;
        if (card.sleeveId) return;
        eligible.push(idx);
      });
      return eligible;
    }

    function encounterCollector() {
      const tileId = run.board.currentTileId;
      if (!run.collectorShop || run.collectorShop.tileId !== tileId) {
        const shopId = `shop-${safeNumber(run.encounterSeq, 0)}-${tileId}`;
        run.collectorShop = {
          tileId,
          shopId,
          items: Array.from({ length: 3 }, () => randomCollectorItem()),
          activeItemIdx: null
        };
        logEvent('COLLECTOR_SHOP_GENERATED', {
          shopId,
          items: run.collectorShop.items.map((item, slot) => ({
            slot,
            itemId: item.id,
            type: item.type,
            rarity: item.rarity,
            cost: COLLECTOR_ITEM_COST
          }))
        });
      }

      logEvent('COLLECTOR_ENTER', {
        tileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderCollector();
    }

    function renderCollector() {
      const shop = run.collectorShop;
      if (!shop) return;
      const chipsNow = safeNumber(run.chips);
      const activeIdx = shop.activeItemIdx;
      const inProgress = activeIdx !== null && activeIdx !== undefined;

      let body = `
        <p class="modal-text">The Collector offers stamps and sleeves to shape your deck.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong></p>
      `;

      if (inProgress) {
        const active = shop.items[activeIdx];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Selection in progress: ${active ? active.name : ''}</p>`;
      }

      const itemsHtml = shop.items.map((item, idx) => {
        const eligible = item.type === 'STAMP' ? getEligibleStampRanks().length : getEligibleSleeveCardIndices().length;
        const disabled = item.purchased || chipsNow < COLLECTOR_ITEM_COST || eligible === 0 || inProgress;
        const status = item.purchased ? 'Purchased' : (eligible === 0 ? 'No eligible cards' : '');
        const rarityClass = `rarity-${item.rarity}`;
        return `
          <div class="merchant-card-slot" style="min-width:180px;">
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <span class="rarity-pip ${rarityClass}"></span>
              <strong>${item.name}</strong>
            </div>
            <div style="font-size:12px; color:var(--text-secondary); min-height:32px;">${item.desc}</div>
            <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="buyCollectorItem(${idx})">
              ${item.purchased ? 'Purchased' : `Buy (${COLLECTOR_ITEM_COST})`}
            </button>
            ${status ? `<div style="font-size:11px; color:var(--text-muted); margin-top:6px;">${status}</div>` : ''}
          </div>
        `;
      }).join('');

      body += `<div class="merchant-cards">${itemsHtml}</div>`;

      const buttons = [];
      if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openCollectorSelection(activeIdx)
        });
      } else {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('COLLECTOR_LEAVE', { tileId: run.board.currentTileId });
            run.collectorShop = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Collector', body, buttons);
    }

    window.buyCollectorItem = function(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item || item.purchased) return;
      if (run.chips < COLLECTOR_ITEM_COST) return;

      if (item.type === 'STAMP' && getEligibleStampRanks().length === 0) return;
      if (item.type === 'SLEEVE' && getEligibleSleeveCardIndices().length === 0) return;

      const chipsBefore = run.chips;
      run.chips -= COLLECTOR_ITEM_COST;
      shop.activeItemIdx = idx;
      logEvent('COLLECTOR_BUY', {
        itemId: item.id,
        name: item.name,
        type: item.type,
        cost: COLLECTOR_ITEM_COST,
        shopId: shop.shopId,
        slot: idx,
        chipsBefore,
        chipsAfter: run.chips
      });
      openCollectorSelection(idx);
    };

    function openCollectorSelection(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item) return;
      if (item.type === 'STAMP') openStampSelection(item);
      else openSleeveSelection(item);
    }

    function openStampSelection(item) {
      const ranks = getEligibleStampRanks();
      if (!ranks.length) {
        renderCollector();
        return;
      }
      const options = shuffle(ranks).slice(0, Math.min(2, ranks.length));
      logEvent('STAMP_OPTIONS_SHOWN', {
        stampId: item.id,
        options,
        eligibleCount: ranks.length
      });
      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a rank to stamp.</p>
      `, options.map(rank => ({
        text: rank,
        primary: true,
        action: () => applyStampToRank(item, rank)
      })));
    }

    function applyStampToRank(item, rank) {
      if (!run.stampsByRank) run.stampsByRank = {};
      run.stampsByRank[rank] = item.id;

      logEvent('STAMP_APPLY', { stampId: item.id, rank, shopId: run.collectorShop?.shopId, slot: run.collectorShop?.activeItemIdx ?? null });
      recordDeckSnapshot('STAMP_APPLY');
      finalizeCollectorItem();
      showToast(`${item.name} applied to ${rank}`);
    }

    function openSleeveSelection(item) {
      const eligible = getEligibleSleeveCardIndices();
      if (!eligible.length) {
        renderCollector();
        return;
      }
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      logEvent('SLEEVE_CANDIDATES_SHOWN', {
        sleeveId: item.id,
        candidates: sample.map(idx => cardRef(run.playerDeck[idx]))
      });
      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="applySleeveToCard('${item.id}', ${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a card to sleeve.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderCollector() }
      ]);
    }

    window.applySleeveToCard = function(sleeveId, deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card) || card.sleeveId) return;
      card.sleeveId = sleeveId;
      if (card.laminationId === undefined) card.laminationId = null;
      logEvent('SLEEVE_APPLY', {
        sleeveId,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        shopId: run.collectorShop?.shopId,
        slot: run.collectorShop?.activeItemIdx ?? null
      });
      recordDeckSnapshot('SLEEVE_APPLY');
      finalizeCollectorItem();
      showToast(`${getSleeveDef(sleeveId).name} applied`);
    };

    function finalizeCollectorItem() {
      const shop = run.collectorShop;
      if (!shop) return;
      const idx = shop.activeItemIdx;
      if (idx !== null && idx !== undefined) {
        const item = shop.items[idx];
        if (item) item.purchased = true;
      }
      shop.activeItemIdx = null;
      renderCollector();
      renderAll();
    }

    // =============================================
    // MERCHANT
    // =============================================
    function encounterMerchant() {
      const tile = run.board.tiles[run.board.currentTileId];
      const npc = tile ? tile.npc : null;
      let affinity = 'neutral';
      let edgeDelta = 0;
      let priceMult = 1;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? -0.10 : (affinity === 'dissonant' ? 0.10 : 0);
        const edgeMod = Math.max(-0.10, Math.min(0.10, (rankToValue(npc.callingCard.rank) - rankToValue(run.callingCard.rank)) * 0.01));
        priceMult = Math.max(0.75, Math.min(1.25, 1 + affinityMod + edgeMod));
      }

      run.ui.merchantContext = {
        tileId: run.board.currentTileId,
        npc,
        affinity,
        edgeDelta,
        priceMult
      };

      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      maybeInjectMerchantKey(merchantOffers);
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      removalPaidCost = 0;
      removalPaidCost = 0;
      removalPaidCost = 0;

      logEvent('MERCHANT_ENTER', {
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        priceMult: Number(priceMult.toFixed(2)),
        offers: merchantOffers.map(cardRef),
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderMerchant();
    }

    function renderMerchant() {
      const chipsNow = safeNumber(run.chips);
      const ctx = run.ui.merchantContext || {};
      const npc = ctx.npc;
      const affinity = ctx.affinity || 'neutral';
      const priceMult = getMerchantPriceMult();
      const npcLine = npc
        ? `${npc.name} · ${cardToString(npc.callingCard)} · ${affinityIcon(affinity)} · Prices x${priceMult.toFixed(2)}`
        : `Prices x${priceMult.toFixed(2)}`;
      const rerollInvCost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      let body = `
        <p class="modal-text">The merchant displays their wares.</p>
        <div class="log-kv" style="margin-bottom:10px;">${npcLine}</div>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Deck: <strong>${run.playerDeck.length}</strong></p>
      `;

      // Buy cards + inventory reroll (always visible)
      const canRerollInv = chipsNow >= rerollInvCost;
      body += `
        <div class="merchant-section">
          <div class="merchant-section-title">Buy Cards (Standard ${MERCHANT_BUY_BASE_STANDARD}+ · Mod ${MERCHANT_BUY_BASE_MOD}+ · +${MERCHANT_BUY_INCREMENT} per buy)</div>
          <div style="display:flex; justify-content:center; margin-bottom:12px;">
            <button class="modal-btn" ${canRerollInv ? '' : 'disabled'} onclick="rerollMerchantInventory()">Re-roll Inventory (${rerollInvCost})</button>
          </div>
          <div class="merchant-cards">
      `;

      merchantOffers.forEach((card, idx) => {
  const isMod = isModifier(card);
  const remaining = isMod ? getModifierRemaining(card.delta) : null;
  const soldOut = isMod && remaining <= 0;
  const slotCost = getMerchantBuyCost(card);
  const canBuy = (chipsNow >= slotCost) && !soldOut;
  const stockLine = isMod
    ? `<div style="margin-top:6px; font-size:12px; color:var(--text-muted);">${soldOut ? 'Sold out' : `Stock: ${remaining}/${MOD_PURCHASE_LIMIT_PER_DELTA}`}</div>`
    : '';

  body += `
    <div class="merchant-card-slot">
      ${renderCard(card, false)}
      ${stockLine}
      <button class="modal-btn" ${canBuy ? '' : 'disabled'} onclick="buyMerchantCard(${idx})">${soldOut ? 'Sold Out' : `Buy (${slotCost})`}</button>
    </div>
  `;
});

      body += '</div></div>';

      
// Removal section (cost paid on entry; reroll still allowed)
const removeCost = getMerchantRemovalCost();
const canEnterRemoval = chipsNow >= removeCost && run.playerDeck.length >= 3;

body += `
  <div class="merchant-section">
    <div class="merchant-section-title">Remove a Card (${removeCost})</div>
          ${removalMode ? `
            <p class="modal-text" style="margin-top:-4px; color: var(--text-muted);">
              Removal fee paid (<strong>${removalPaidCost}</strong>). No refund.
            </p>
          ` : `
            <button class="modal-btn danger" ${canEnterRemoval ? '' : 'disabled'} onclick="startRemoval()">Choose Card to Remove</button>
            <p class="modal-text" style="margin-top:10px; color: var(--text-muted);">Cost is deducted immediately when you enter removal mode.</p>
          `}
        </div>
      `;

      if (removalMode) {
        const removalRerollCost = getMerchantCost(REMOVAL_REROLL_COST);
        const canReroll = safeNumber(run.chips) >= removalRerollCost && run.playerDeck.length >= 1;

        body += `
          <div class="removal-picker">
            <p class="modal-text">Select a card to remove from your deck:</p>
            <div class="removal-cards">
        `;

        removalCandidates.forEach((data, idx) => {
          const card = data.card;
          const selected = selectedRemovalIdx === idx;
          body += `
            <div class="removal-card-option ${selected ? 'selected' : ''}" onclick="selectRemovalCard(${idx})">
              ${renderCard(card, false)}
            </div>
          `;
        });

        body += `
            </div>
            <div style="display:flex; justify-content:center; gap:12px; flex-wrap:wrap;">
              <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollRemoval()">Re-roll (${removalRerollCost})</button>
            </div>
          </div>
        `;
      }

      const buttons = [];
      if (removalMode) {
        buttons.push({
          text: 'Confirm Removal',
          primary: true,
          disabled: selectedRemovalIdx === null,
          action: confirmRemoval
        });
        buttons.push({ text: 'Exit Removal', action: cancelRemoval });
      } else {
        buttons.push({ text: 'Leave', action: () => { leaveMerchant(); } });
      }

      showModal('Merchant', body, buttons);
      renderHUD();
    }

    window.rerollMerchantInventory = function() {
      if (run && run.secret && run.secret.keys && run.floor === 2) {
        const mk = run.secret.keys.merchant;
        if (mk.state === 'offered') mk.state = 'missed';
      }
      const cost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;
      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      if (run.floor === 2 && run.secret && run.secret.keys) {
        const mk = run.secret.keys.merchant;
        mk.chance = Math.min(0.35, safeNumber(mk.chance, 0.05) + 0.03);
      }
      maybeInjectMerchantKey(merchantOffers);
      logEvent('MERCHANT_REROLL', { which: 'inventory', cost, offers: merchantOffers.map(cardRef) });
      renderMerchant();
      showToast(`Re-rolled inventory (-${cost})`);
    };

    window.buyMerchantCard = function(idx) {
  const card = merchantOffers[idx];
  assignUid(card);
  const chipsBefore = run.chips;
  const cost = getMerchantBuyCost(card);
  if (run.chips < cost) return;

  // Per-run purchase limit on modifiers (-4..+4)
  if (isModifier(card) && getModifierRemaining(card.delta) <= 0) {
      showToast(`Sold out: ${cardToString(card)}`);
      logEvent('MODIFIER_SOLD_OUT', {
        floor: run.floor,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        delta: card.delta,
        limit: MOD_PURCHASE_LIMIT_PER_DELTA,
        purchased: run.modPurchaseCounts[String(card.delta)]
      });
    renderMerchant();
    return;
  }

  run.chips -= cost;
  run.playerDeck.push(card);

  if (isKeyCard(card) && run.secret && run.secret.keys) {
    run.secret.keys.merchant.state = 'obtained';
    logEvent('KEYCARD_OBTAINED', { source: 'MERCHANT', card: cardRef(card), cost });
    recordDeckSnapshot('KEYCARD_MERCHANT');
  }

  if (isModifier(card)) {
    recordModifierPurchase(card.delta);
    run.merchantModifierBuys = safeNumber(run.merchantModifierBuys, 0) + 1;
  } else {
    run.merchantStandardBuys = safeNumber(run.merchantStandardBuys, 0) + 1;
  }

  logEvent('MERCHANT_BUY', {
    card: cardToString(card),
    cardUid: card.uid || null,
    cardRef: cardRef(card),
    cost,
    chipsBefore,
    chipsAfter: run.chips,
    isModifier: isModifier(card),
    modifierRemaining: isModifier(card) ? getModifierRemaining(card.delta) : null,
    deckSnapshot: deckSnapshot()
  });
  recordDeckSnapshot('MERCHANT_BUY');

  // Refresh that inventory slot
  merchantOffers[idx] = randomCard();
  assignUid(merchantOffers[idx]);
  maybeInjectMerchantKey(merchantOffers);

  renderMerchant();
  showToast(`Bought ${cardToString(card)}`);
};

    window.startRemoval = function() {
  const cost = getMerchantRemovalCost();
  if (run.playerDeck.length < 3) return;

  const eligible = run.playerDeck
    .map((card, i) => ({ card, i }))
    .filter(d => !isKeyCard(d.card));
  if (eligible.length < 1) { showToast('No eligible cards to remove.'); return; }
  if (run.chips < cost) { showToast('Not enough chips.'); return; }

  // charge only after eligibility is confirmed
  run.chips -= cost;
  run.paidRemovalCount = safeNumber(run.paidRemovalCount, 0) + 1;
  removalPaidCost = cost;

  const picks = shuffle(eligible.slice()).slice(0, Math.min(3, eligible.length));
  removalCandidates = picks.map(d => ({ card: d.card }));
  removalMode = true;
  selectedRemovalIdx = null;

  logEvent('MERCHANT_REMOVE_START', {
    cost,
    removalCount: run.paidRemovalCount,
    candidates: removalCandidates.map(x => cardRef(x.card))
  });

  renderMerchant();
  showToast(`Removal started (-${cost})`);
};

    window.rerollRemoval = function() {
      if (!removalMode) return;
      const cost = getMerchantCost(REMOVAL_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;

      const eligible = run.playerDeck
        .map((card, i) => ({ card, i }))
        .filter(d => !isKeyCard(d.card));
      const picks = shuffle(eligible.slice()).slice(0, Math.min(3, eligible.length));
      removalCandidates = picks.map(d => ({ card: d.card }));
      selectedRemovalIdx = null;

      logEvent('MERCHANT_REROLL', { which: 'removal', cost, candidates: removalCandidates.map(x => cardRef(x.card)) });

      renderMerchant();
      showToast(`Re-rolled removal (-${cost})`);
    };

    window.selectRemovalCard = function(idx) {
      selectedRemovalIdx = idx;
      renderMerchant();
    };

    window.confirmRemoval = function() {
      if (selectedRemovalIdx === null) return;

      const data = removalCandidates[selectedRemovalIdx];
      if (isKeyCard(data.card)) return;
      const idx = run.playerDeck.indexOf(data.card);
      if (idx !== -1) {
        run.playerDeck.splice(idx, 1);
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('MERCHANT_REMOVE_CONFIRM');
        showToast(`Removed ${cardToString(data.card)} from deck`);
      } else {
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), result: 'not_found' });
        showToast(`Card no longer available to remove`);
      }

      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;

      renderMerchant();
    };

    window.cancelRemoval = function() {
      logEvent('MERCHANT_REMOVE_EXIT', {});
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      renderMerchant();
    };

    function maybeInjectMerchantKey(offers) {
      if (!run || run.floor !== 2 || !run.secret || !run.secret.keys) return;
      const mk = run.secret.keys.merchant;
      if (mk.state === 'missed' || mk.state === 'obtained') return;
      const already = offers.some(isKeyCard);
      if (already) return;
      const chance = safeNumber(mk.chance, 0.05);
      if (Math.random() < chance) {
        const slot = Math.floor(Math.random() * offers.length);
        const key = makeKeyCard('MERCHANT');
        assignUid(key);
        offers[slot] = key;
        mk.state = 'offered';
      }
    }

    function leaveMerchant() {
      if (run && run.secret && run.secret.keys && run.floor === 2) {
        const mk = run.secret.keys.merchant;
        if (mk.state === 'offered') mk.state = 'missed';
      }
      closeModal();
      renderAll();
    }

    // Blackjack encounters
    function encounterBlackjackStandard() {
      if (run.chips < BUYIN_STANDARD) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('STANDARD', BUYIN_STANDARD);
    }

    function encounterBlackjackHigh() {
      if (run.chips < BUYIN_HIGH) { gameOver("You can't afford the buy-in."); return; }
      const hsKey = run.secret && run.secret.keys ? run.secret.keys.highStakes : null;
      const specialReward = (run.floor === 1 && hsKey && !hsKey.obtained && run.board.currentTileId === hsKey.tileId) ? 'KEY_HIGH' : null;
      startBlackjackMatch('HIGH_STAKES', BUYIN_HIGH, { specialReward });
    }

    function encounterBoss() {
      if (run.floor === 3 && run.loan.active && !run.loan.repaid) {
        gameOver("Debt unpaid. You cannot face the final boss.");
        return;
      }
      if (run.chips < BUYIN_BOSS) { gameOver("You can't afford the buy-in."); return; }
      startBossFight();
    }

    function startBossFight() {
      run.bossFight = {
        active: true,
        floor: run.floor,
        round: 1,
        maxRounds: 3,
        roundsRemaining: 3,
        maxHp: 100,
        hp: 100,
        phase: 1,
        targetLaneIdx: null,
        benchCarry: [],
        phase2Announced: false
      };
      logEvent('BOSS_FIGHT_START', {
        floor: run.floor,
        round: 1,
        maxRounds: 3,
        roundsRemaining: 3,
        hp: run.bossFight.hp,
        maxHp: run.bossFight.maxHp
      });
      startBossRound(1);
    }

    function startBossRound(roundIdx) {
      const bf = run.bossFight;
      if (!bf) return;
      bf.round = roundIdx;
      const buyIn = roundIdx === 1 ? BUYIN_BOSS : 0;
      startBlackjackMatch('BOSS', buyIn, {
        initialBench: bf.benchCarry || []
      });
      blackjackMatch.bossRound = bf.round;
      blackjackMatch.bossMaxRounds = bf.maxRounds;
      logEvent('BOSS_ROUND_START', {
        round: bf.round,
        maxRounds: bf.maxRounds,
        hp: bf.hp,
        maxHp: bf.maxHp,
        phase: bf.phase
      });
      if (bf.phase === 2 && !bf.phase2Announced) {
        bf.phase2Announced = true;
        showToast("Surveillance Online — Countermeasures active.");
        logEvent('BOSS_PHASE2_START', { hp: bf.hp, maxHp: bf.maxHp, round: bf.round });
      }
      if (bf.phase === 2) updateThreatTargetLane(true, 'round_start');
    }

    // =============================================
    // SLOT BLACKJACK ENGINE
    // =============================================
    function getTransferMultiplierLimits(type) {
      if (type === 'BOSS') return { min: 2, max: 5 };
      if (type === 'HIGH_STAKES') return { min: 1, max: 4 };
      return { min: 1, max: 3 };
    }

    function startBlackjackMatch(type, buyIn, options = {}) {
      clearDealerTimers();

      run.chips -= buyIn;
      run.matchSeq = safeNumber(run.matchSeq, 0) + 1;

      const playerDrawPile = shuffle(run.playerDeck.slice());

      // Dealer deck = standard 52 + random bench modifiers (2/4/6 by floor)
      const dealerBaseDeck = options.dealerDeckOverride ? options.dealerDeckOverride.slice() : makeStandardDeck52();
      const extraMods = options.dealerDeckOverride ? 0 : Math.max(0, Math.min(20, safeNumber(run.floor, 1) * 2)); // F1=2, F2=4, F3=6
      for (let i = 0; i < extraMods; i++) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        dealerBaseDeck.push({ type: 'MOD', delta });
      }
      const dealerDrawPile = shuffle(dealerBaseDeck.slice());

      // load tokens: base by floor + from bank
      const baseTokens = Math.max(1, safeNumber(run.floor, 1));
      const banked = run.bankedTokens || 0;
      const addFromBank = Math.min(banked, ACTION_TOKEN_MAX_BANKED);
      const tokensTotal = baseTokens + addFromBank;
      run.bankedTokens = Math.max(0, banked - addFromBank);

      blackjackMatch = {
        type,
        buyIn,
        matchSeq: run.matchSeq,
        npc: null,
        playerPositions: [],
        dealerPositions: [],
        playerDrawPile,
        dealerDrawPile,

        // NEW: dealer base deck + dealer bench
        dealerBaseDeck,
        dealerBench: [],

        drawnCard: null,
        turn: 'player',
        phase: 'betting',
        result: null,

        // Bench (player mods + normal cards)
        bench: options.initialBench ? options.initialBench.slice() : [],
        armedBenchIdx: null,

        // bonuses + transfers
        bonusAll21Awarded: false,
        bonusChipsEarned: 0,
        transferChipsNet: 0,
        transferMultiplier: null,
        transferMultiplierMin: null,
        transferMultiplierMax: null,
        transferMultiplierStage: 'player',
        transferRaiseOffer: null,
        callingProcChance: CALLING_PROC_CHANCE,
        spadePeekLanes: new Set(),
        lastCallingSuitPlay: null,
        scoreSeq: null,
        earningsSeq: null,
        procBanner: null,
        specialReward: options.specialReward || null,
        watcherTargetLaneIdx: null,
        traps: {
          player: Array(5).fill(0),
          dealer: Array(5).fill(0)
        },

        // Action tokens + action usage
        tokensTotal,
        tokensSpent: 0,
        usedActions: {},
        actionUsedThisTurn: false,
        actionSelectionInProgress: false,

        // Action effects state
        spyReveals: new Set(),
        dealerForcedLane: null,
        pending: null,
        rewardPending: false,
        winnerReward: null,
        exhaustion: null,
        burnedSleeveCards: [],

        metrics: {
          startedAtMs: performance.now(),
          turns: 0,
          playerDraws: 0,
          dealerDraws: 0,
          playerStands: 0,
          dealerStands: 0,
          playerBustsFinal: 0,
          dealerBustsFinal: 0,
          modifiersBenched: 0,
          benchModsToPlayer: 0,
          benchModsToDealer: 0,
          benchCardsPlaced: 0,
          actionsUsed: 0,

          // NEW: dealer bench tracking
          dealerModifiersBenched: 0,
          dealerBenchModsUsed: 0,

          initialDealComplete: false,
          laneCards: {
            playerTotal: Array(5).fill(0),
            dealerTotal: Array(5).fill(0),
            playerAfterInitial: Array(5).fill(0),
            dealerAfterInitial: Array(5).fill(0)
          }
        }
      };

      const limits = getTransferMultiplierLimits(type);
      blackjackMatch.transferMultiplier = limits.min;
      blackjackMatch.transferMultiplierMin = limits.min;
      blackjackMatch.transferMultiplierMax = limits.max;

      const currentTile = run.board.tiles[run.board.currentTileId];
      const npc = options.npcOverride || (currentTile ? currentTile.npc : null);
      blackjackMatch.npc = npc;
      let affinity = 'neutral';
      let edgeDelta = 0;
      let procChance = CALLING_PROC_CHANCE;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? 0.10 : (affinity === 'dissonant' ? -0.10 : 0);
        const edgeMod = Math.max(-0.12, Math.min(0.12, edgeDelta * 0.01));
        procChance = Math.max(0.10, Math.min(0.90, CALLING_PROC_CHANCE + affinityMod + edgeMod));
      }
      blackjackMatch.callingProcChance = procChance;
      blackjackMatch.affinity = affinity;
      blackjackMatch.edgeDelta = edgeDelta;

      logEvent('MATCH_START', {
        type,
        buyIn,
        matchSeq: blackjackMatch.matchSeq,
        baseTokens,
        tokensTotal,
        bankedTokensUsed: addFromBank,
        bankedTokensRemaining: run.bankedTokens,
        dealerExtraMods: extraMods,
        transferMultiplierMin: limits.min,
        transferMultiplierMax: limits.max,
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        callingProcChance: procChance,
        deckSnapshot: deckSnapshot()
      });

      run.ui.mode = 'BLACKJACK';

      // Initialize 5 positions each
      for (let i = 0; i < 5; i++) {
        blackjackMatch.playerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false,
          bonus21Awarded: false,
          lastPlayedCard: null,
          lastPlayedAttackValue: 0,
          attackFired: false
        });
        blackjackMatch.dealerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false,
          lastPlayedCard: null,
          lastPlayedAttackValue: 0,
          attackFired: false
        });
      }

      // Deal initial cards (modifiers never go into lane hands)
      for (let i = 0; i < 3; i++) {
        const okP = dealToPosition(blackjackMatch.playerPositions[i], blackjackMatch.playerDrawPile, run.playerDeck, 'player', i);
        if (!okP) { triggerDeckExhaustion('player', 'initial-deal'); return; }
        maybeAward21BonusForPlayerPos(i);

        const okD = dealToPosition(blackjackMatch.dealerPositions[i], blackjackMatch.dealerDrawPile, dealerBaseDeck, 'dealer', i);
        if (!okD) { triggerDeckExhaustion('dealer', 'initial-deal'); return; }
      }

      blackjackMatch.metrics.initialDealComplete = true;
      run.ui.mode = 'BLACKJACK';
      if (run.ui) run.ui.hudCollapsed = true;
      renderAll();
    }

    window.setTransferMultiplier = function(multiplier) {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'player') return;
      const min = blackjackMatch.transferMultiplierMin || 1;
      const max = blackjackMatch.transferMultiplierMax || 1;
      if (multiplier < min || multiplier > max) return;
      blackjackMatch.transferMultiplier = multiplier;
      blackjackMatch.transferMultiplierStage = 'dealer';
      resolveDealerTransferDecision();
    };

    function resolveDealerTransferDecision() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'dealer') return;
      const current = blackjackMatch.transferMultiplier || 1;
      const max = blackjackMatch.transferMultiplierMax || current;
      const canRaise = current < max;
      const willRaise = canRaise && Math.random() < 0.5;

      if (willRaise) {
        blackjackMatch.transferRaiseOffer = current + 1;
        blackjackMatch.transferMultiplierStage = 'response';
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'raise', offer: blackjackMatch.transferRaiseOffer });
      } else {
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'call' });
        finishTransferBetting();
      }
      renderBlackjack();
    }

    window.acceptTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      blackjackMatch.transferMultiplier = blackjackMatch.transferRaiseOffer || blackjackMatch.transferMultiplier;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'accept', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    window.declineTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'decline', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    function finishTransferBetting() {
      blackjackMatch.transferRaiseOffer = null;
      blackjackMatch.transferMultiplierStage = 'done';
      blackjackMatch.phase = 'playing';
      blackjackMatch.turn = 'player';
      renderBlackjack();
      showToast(`Transfer multiplier locked at x${blackjackMatch.transferMultiplier}`);
    }


    function drawCardFromPile(pile) {
      if (!pile || pile.length === 0) return null;
      return pile.pop();
    }

    // Draw until a NON-modifier is found. Any modifiers drawn are benched (player side).
// Draw until a NON-modifier is found.
// Player: any modifiers drawn are benched.
// Dealer: any modifiers drawn go to dealerBench (not revealed), then draw continues.
    function drawNonModifierCard(pile, fallbackDeck, side) {
      let safety = 0;
      while (safety++ < 300) {
        const fb = (side === 'dealer' && blackjackMatch && blackjackMatch.dealerBaseDeck)
          ? blackjackMatch.dealerBaseDeck
          : fallbackDeck;

        const c = drawCardFromPile(pile, fb);
        if (!c) return null;
        if (isModifier(c)) {
          if (blackjackMatch) {
            if (side === 'player') {
              benchPush(c, 'auto-bench');
              blackjackMatch.metrics.modifiersBenched += 1;
            } else if (side === 'dealer') {
              blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
              blackjackMatch.dealerBench.push(c);
              blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
              logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), source: 'dealer-draw' });
            }
          }
          continue;
        }
        return c;
      }
      return null;
    }


    function dealToPosition(pos, pile, fallbackDeck, side, laneIdx) {
      const a = drawNonModifierCard(pile, fallbackDeck, side);
      const b = drawNonModifierCard(pile, fallbackDeck, side);
      if (!a || !b) return false;
      pos.cards.push(a);
      pos.cards.push(b);
      pos.lastPlay = { kind: 'card', rank: b.rank, value: getStrikeValueFromCard(b) };
      onCardPlacedForAttack(pos, b);
      recordLaneCard(side, laneIdx, 1);
      recordLaneCard(side, laneIdx, 1);
      return true;
    }

    function getPositionTotal(pos) {
      const modSum = (pos.mods || []).reduce((a, b) => a + b, 0);
      const base = calcBestTotal(pos.cards, modSum);
      return safeNumber(base, 0);
    }

    function getStrikeValueFromCard(card) {
      if (!card || isModifier(card)) return 0;
      if (isFused(card)) {
        const options = getCardValueOptions(card);
        if (options.includes(11)) return 11;
        return options.length ? Math.min(10, Math.max(...options)) : 0;
      }
      if (card.rank === 'A') return 11;
      if (['J', 'Q', 'K'].includes(card.rank)) return 10;
      const n = Number(card.rank);
      return Number.isFinite(n) ? Math.min(10, n) : 0;
    }

    function getAttackValueFromCard(card) {
      if (!card) return 0;
      if (isModifier(card)) return Math.abs(safeNumber(card.delta, 0));
      return Math.min(11, Math.max(0, getStrikeValueFromCard(card)));
    }

    function onCardPlacedForAttack(pos, card) {
      if (!pos || !card) return;
      pos.lastPlayedCard = card;
      pos.lastPlayedAttackValue = getAttackValueFromCard(card);
    }

    function tryFireCloseAttack(attackerSide, laneIdx) {
      if (!blackjackMatch) return;
      const a = attackerSide === 'player' ? blackjackMatch.playerPositions[laneIdx] : blackjackMatch.dealerPositions[laneIdx];
      const d = attackerSide === 'player' ? blackjackMatch.dealerPositions[laneIdx] : blackjackMatch.playerPositions[laneIdx];
      if (!a || !d) return;
      if (a.attackFired) return;
      if (d.isComplete) return;
      const dmg = safeNumber(a.lastPlayedAttackValue, 0);
      if (!dmg) return;
      d.mods = d.mods || [];
      d.mods.push(-dmg);
      a.attackFired = true;
      if (!blackjackMatch.metrics) blackjackMatch.metrics = {};
      if (attackerSide === 'player') blackjackMatch.metrics.playerAttackDealt = safeNumber(blackjackMatch.metrics.playerAttackDealt, 0) + dmg;
      else blackjackMatch.metrics.dealerAttackDealt = safeNumber(blackjackMatch.metrics.dealerAttackDealt, 0) + dmg;
      logEvent('LANE_CLOSE_ATTACK', { attacker: attackerSide, lane: laneIdx + 1, damage: dmg, card: a.lastPlayedCard ? cardToString(a.lastPlayedCard) : null });
      showToast(`${attackerSide === 'player' ? 'Attack dealt' : 'Attack taken'}: lane #${laneIdx + 1} ${dmg}`);
    }

    function computeStrikeDeltaFromLastPlay(lastPlay) {
      if (!lastPlay) return 0;
      if (lastPlay.kind === 'mod') return -lastPlay.delta;
      if (lastPlay.kind === 'card') return -safeNumber(lastPlay.value, 0);
      return 0;
    }

    function applyLaneMod(side, laneIdx, delta) {
      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[laneIdx];
      if (!pos) return 'invalid';
      if (pos.isComplete) return 'closed';
      if (!pos.isOpen) {
        blackjackMatch.traps[side][laneIdx] += delta;
        return 'unopened';
      }
      pos.mods = pos.mods || [];
      pos.mods.push(delta);
      return 'open';
    }

    function tryTempoStrike(attackerSide, laneIdx, reason) {
      if (!blackjackMatch) return;
      const attackerPositions = attackerSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const targetSide = attackerSide === 'dealer' ? 'player' : 'dealer';
      const targetPositions = targetSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const attackerPos = attackerPositions[laneIdx];
      const targetPos = targetPositions[laneIdx];
      if (!attackerPos || !targetPos) return;
      if (!attackerPos.isComplete || attackerPos.isBust) return;

      const delta = computeStrikeDeltaFromLastPlay(attackerPos.lastPlay);
      if (!delta) return;

      if (targetPos.isComplete) {
        logEvent('TEMPO_STRIKE_BLOCKED', {
          attacker: attackerSide,
          lane: laneIdx + 1,
          delta,
          lastPlay: attackerPos.lastPlay,
          targetState: 'closed',
          trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
          reason
        });
        return;
      }

      const targetState = applyLaneMod(targetSide, laneIdx, delta);
      const eventType = (targetState === 'unopened') ? 'TEMPO_STRIKE_TRAP_SET' : 'TEMPO_STRIKE_APPLIED';
      logEvent(eventType, {
        attacker: attackerSide,
        lane: laneIdx + 1,
        delta,
        lastPlay: attackerPos.lastPlay,
        targetState,
        trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
        reason
      });
    }

    function bossUpdateTargetLane(force = false, reason = '') {
      const bf = run && run.bossFight;
      if (!bf || !bf.active || bf.phase !== 2) return;

      const current = bf.targetLaneIdx;
      if (!force && current !== null) {
        const curPos = blackjackMatch.playerPositions[current];
        if (curPos && curPos.isOpen && !curPos.isComplete) return;
      }

      let best = null;
      for (let i = 0; i < 5; i++) {
        const p = blackjackMatch.playerPositions[i];
        if (!p.isOpen || p.isComplete) continue;
        const t = getPositionTotal(p);
        const diff = (t <= 21) ? (21 - t) : (1000 + (t - 21));
        const score = diff * 100 - t;
        if (!best || score < best.score) best = { i, score, t, diff };
      }

      bf.targetLaneIdx = best ? best.i : null;
      logEvent('BOSS_TARGET_SET', { laneIdx: bf.targetLaneIdx, reason });
    }

    function watcherUpdateTargetLane(force = false, reason = '') {
      if (!blackjackMatch || blackjackMatch.type !== 'WATCHER') return;
      const current = blackjackMatch.watcherTargetLaneIdx;
      if (!force && current !== null) {
        const curPos = blackjackMatch.playerPositions[current];
        if (curPos && curPos.isOpen && !curPos.isComplete) return;
      }
      let best = null;
      for (let i = 0; i < 5; i++) {
        const p = blackjackMatch.playerPositions[i];
        if (!p.isOpen || p.isComplete) continue;
        const t = getPositionTotal(p);
        const diff = (t <= 21) ? (21 - t) : (1000 + (t - 21));
        const score = diff * 100 - t;
        if (!best || score < best.score) best = { i, score };
      }
      blackjackMatch.watcherTargetLaneIdx = best ? best.i : null;
      logEvent('WATCHER_TARGET_SET', { laneIdx: blackjackMatch.watcherTargetLaneIdx, reason });
    }

    function updateThreatTargetLane(force = false, reason = '') {
      if (run && run.bossFight && run.bossFight.active) return bossUpdateTargetLane(force, reason);
      if (blackjackMatch && blackjackMatch.type === 'WATCHER') return watcherUpdateTargetLane(force, reason);
    }

    function bossTryCountermeasure() {
      const bf = run && run.bossFight;
      if (!bf || !bf.active || bf.phase !== 2) return false;
      if (bf.targetLaneIdx === null) bossUpdateTargetLane(true, 'countermeasure_no_target');
      let targetIdx = bf.targetLaneIdx;
      let targetPos = (targetIdx !== null) ? blackjackMatch.playerPositions[targetIdx] : null;
      if (!targetPos || !targetPos.isOpen || targetPos.isComplete) {
        bossUpdateTargetLane(true, 'countermeasure_retarget');
        targetIdx = bf.targetLaneIdx;
        targetPos = (targetIdx !== null) ? blackjackMatch.playerPositions[targetIdx] : null;
      }
      if (!targetPos || !targetPos.isOpen || targetPos.isComplete) return false;

      const bench = blackjackMatch.dealerBench || [];
      if (!bench.length) return false;

      const laneIdx = targetIdx;
      const p = targetPos;
      const cur = getPositionTotal(p);

      let pick = 0;
      let bestScore = -Infinity;
      for (let i = 0; i < bench.length; i++) {
        const m = bench[i];
        if (!isModifier(m)) continue;
        const applied = -m.delta;
        const next = cur + applied;
        const bust = next > 21 ? 1 : 0;
        const away = (next <= 21) ? (21 - next) : (50 + (next - 21));
        const score = (bust ? 1000 : 0) - away;
        if (score > bestScore) { bestScore = score; pick = i; }
      }

      const mod = bench[pick];
      const appliedDelta = -mod.delta;
      const state = applyLaneMod('player', laneIdx, appliedDelta);
      if (state !== 'open') return false;

      bench.splice(pick, 1);

      logEvent('BOSS_COUNTERMEASURE', {
        lane: laneIdx + 1,
        dealerBenchMod: cardRef(mod),
        appliedDelta,
        targetState: state
      });
      showToast(`Countermeasure: Lane ${laneIdx + 1}`);
      return true;
    }

    function recordLaneCard(side, laneIdx, count = 1, afterInitial = null) {
      if (!blackjackMatch || !blackjackMatch.metrics || laneIdx === null || laneIdx === undefined) return;
      const laneCards = blackjackMatch.metrics.laneCards;
      if (!laneCards || laneIdx < 0 || laneIdx > 4) return;
      const isAfterInitial = afterInitial !== null ? afterInitial : !!blackjackMatch.metrics.initialDealComplete;
      if (side === 'dealer') {
        laneCards.dealerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.dealerAfterInitial[laneIdx] += count;
      } else {
        laneCards.playerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.playerAfterInitial[laneIdx] += count;
      }
    }

    // bust is finalized only at end-of-turn (or when explicitly closes a lane)
    function finalizeBusts(positions, side) {
      for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        if (!pos.isOpen) continue;
        if (pos.isComplete) continue;
        const total = getPositionTotal(pos);
        if (total > 21) {
          let crystalSaved = false;
          if (side === 'player') {
            const crystalIdx = (pos.cards || []).findIndex(c => c && c.sleeveId === 'CRYSTAL');
            if (crystalIdx >= 0) {
              const burned = pos.cards.splice(crystalIdx, 1)[0];
              blackjackMatch.burnedSleeveCards = blackjackMatch.burnedSleeveCards || [];
              blackjackMatch.burnedSleeveCards.push(burned);
              logEvent('CRYSTAL_SLEEVE_SAVE', { laneIdx: i + 1, card: cardToString(burned) });
              showToast(`Crystal Sleeve saved lane #${i + 1}`);
              crystalSaved = true;
              pos.isBust = false;
              pos.isComplete = false;
            }
          }

          if (!crystalSaved) {
            pos.isBust = true;
            pos.isComplete = true;
          } else if (getPositionTotal(pos) > 21) {
            pos.isBust = true;
            pos.isComplete = true;
          }
        }
      }
    }

    function countOpenPositions(positions) {
      return positions.filter(p => p.isOpen && !p.isComplete).length;
    }

    function anyOpenIncomplete(positions) {
      return positions.some(p => p.isOpen && !p.isComplete);
    }

    function openNextPosition(positions, pile, fallbackDeck, side) {
      for (let i = 0; i < 5; i++) {
        if (!positions[i].isOpen) {
          positions[i].isOpen = true;
          const ok = dealToPosition(positions[i], pile, fallbackDeck, side, i);
          if (!ok) {
            triggerDeckExhaustion(side, 'open-lane');
            return -1;
          }

          const trapDelta = blackjackMatch && blackjackMatch.traps ? blackjackMatch.traps[side][i] : 0;
          if (trapDelta) {
            positions[i].mods = positions[i].mods || [];
            positions[i].mods.push(trapDelta);
            blackjackMatch.traps[side][i] = 0;
            const attacker = side === 'dealer' ? 'player' : 'dealer';
            logEvent('TEMPO_STRIKE_TRAP_TRIGGERED', {
              attacker,
              lane: i + 1,
              delta: trapDelta,
              lastPlay: null,
              targetState: 'open',
              trapTotalAfter: blackjackMatch.traps[side][i]
            });
          }

          if (blackjackMatch && side === 'player') maybeAward21BonusForPlayerPos(i);
          return i;
        }
      }
      return -1;
    }

    function maintainOpenPositions(positions, pile, fallbackDeck, side) {
      while (countOpenPositions(positions) < 3) {
        const opened = openNextPosition(positions, pile, fallbackDeck, side);
        if (opened === -1) break;
      }
    }

    function triggerDeckExhaustion(side, reason) {
      if (!blackjackMatch || blackjackMatch.phase === 'resolved') return;
      blackjackMatch.exhaustion = { side, reason };
      logEvent('DECK_EXHAUSTION', { side, reason });
      const forcedOutcome = side === 'dealer' ? 'WIN' : 'LOSS';
      resolveMatch({ forcedOutcome, exhaustion: blackjackMatch.exhaustion });
    }

    function allPositionsComplete(positions) {
      return positions.every(p => p.isComplete);
    }

    // =============================================
    // BONUSES: +21 chips for any PLAYER position reaching total==21 (any way)
    // =============================================
    function maybeAward21BonusForPlayerPos(posIdx) {
      if (!blackjackMatch || !['playing', 'betting'].includes(blackjackMatch.phase)) return;
      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen) return;
      if (pos.bonus21Awarded) return;

      const total = getPositionTotal(pos);
      if (total === 21) {
        pos.bonus21Awarded = true;
        run.chips += BLACKJACK_21_REWARD;
        blackjackMatch.bonusChipsEarned += BLACKJACK_21_REWARD;

        logEvent('BONUS_21', { lane: posIdx + 1, amount: BLACKJACK_21_REWARD });

        renderHUD();
        showToast(`Blackjack! +${BLACKJACK_21_REWARD} chips`);

        if (!blackjackMatch.bonusAll21Awarded) {
          const all = blackjackMatch.playerPositions.every(p => p.bonus21Awarded);
          if (all) {
            blackjackMatch.bonusAll21Awarded = true;
            run.chips += ALL_FIVE_21_BONUS;
            blackjackMatch.bonusChipsEarned += ALL_FIVE_21_BONUS;

            logEvent('BONUS_ALL_FIVE', { amount: ALL_FIVE_21_BONUS });

            renderHUD();
            showToast(`All five! +${ALL_FIVE_21_BONUS} chips`);
          }
        }
      }
    }


    function flattenLaneForPatterns(laneCards) {
      const out = [];
      for (const c of laneCards || []) {
        if (!c) continue;
        if (isModifier(c) || isKeyCard(c)) continue;
        if (isFused(c)) {
          if (c.a && !isModifier(c.a) && !isKeyCard(c.a)) out.push({ rank: c.a.rank, suit: c.a.suit, parentUid: c.uid || null });
          if (c.b && !isModifier(c.b) && !isKeyCard(c.b)) out.push({ rank: c.b.rank, suit: c.b.suit, parentUid: c.uid || null });
          continue;
        }
        out.push({ rank: c.rank, suit: c.suit, parentUid: c.uid || null });
      }
      return out;
    }

    function detectLanePatterns(laneCards) {
      const atoms = flattenLaneForPatterns(laneCards);
      if (!atoms.length) return [];
      const byRank = new Map();
      const bySuit = new Map();
      for (const a of atoms) {
        if (!a.rank || !a.suit) continue;
        if (!byRank.has(a.rank)) byRank.set(a.rank, []);
        byRank.get(a.rank).push(a.parentUid);
        if (!bySuit.has(a.suit)) bySuit.set(a.suit, []);
        bySuit.get(a.suit).push(a.parentUid);
      }
      const uniqueUids = (arr) => Array.from(new Set((arr || []).filter(v => v !== null && v !== undefined)));
      const rankCounts = Array.from(byRank.entries()).map(([rank, uids]) => ({ rank, count: uids.length, cardUids: uniqueUids(uids) }));
      const pairRanks = rankCounts.filter(r => r.count >= 2);
      const trips = rankCounts.find(r => r.count >= 3);
      const quads = rankCounts.find(r => r.count >= 4);
      const flush = Array.from(bySuit.entries()).find(([, uids]) => uids.length >= 3);

      const values = Array.from(new Set(atoms.map(a => rankToValue(a.rank)).filter(v => v > 0)));
      if (values.includes(14)) values.push(1);
      const sorted = Array.from(new Set(values)).sort((a,b)=>a-b);
      let bestRun = [];
      let cur = [];
      for (const v of sorted) {
        if (!cur.length || v === cur[cur.length-1] + 1) cur.push(v);
        else cur = [v];
        if (cur.length > bestRun.length) bestRun = cur.slice();
      }
      const patterns=[];
      if (quads) patterns.push({ name:'Quads', delta:35, cardUids:quads.cardUids });
      if (trips && pairRanks.some(p => p.rank !== trips.rank)) patterns.push({ name:'Full House', delta:26, cardUids: uniqueUids([...trips.cardUids, ...pairRanks.filter(p=>p.rank!==trips.rank).flatMap(p=>p.cardUids)]) });
      if (trips) patterns.push({ name:'Trips', delta:18, cardUids:trips.cardUids });
      if (pairRanks.length >= 2) patterns.push({ name:'Two Pair', delta:14, cardUids: uniqueUids(pairRanks.slice(0,2).flatMap(p=>p.cardUids)) });
      if (pairRanks.length >= 1) patterns.push({ name:'Pair', delta:8, cardUids: pairRanks[0].cardUids });
      if (flush) patterns.push({ name:'Flush', delta:14, cardUids: uniqueUids(flush[1]) });
      if (bestRun.length >= 3) {
        const runVals = new Set(bestRun);
        const runUids = uniqueUids(atoms.filter(a => {
          const v = rankToValue(a.rank);
          return runVals.has(v) || (v === 14 && runVals.has(1));
        }).map(a => a.parentUid));
        patterns.push({ name:'Straight', delta:14, cardUids: runUids });
      }
      return patterns;
    }

    function buildKarmaBreakdown(positionResults, playerTotals) {
      const lanes = positionResults.map((result, idx) => {
        const isWin = result === 'player';
        const base = isWin ? safeNumber(playerTotals[idx], 0) : 0;
        const laneCards = blackjackMatch.playerPositions[idx].cards || [];
        const laneSize = laneCards.length || 1;
        const stamps = [];
        let stampTotal = 0;
        let stampUids = [];
        if (isWin) {
          laneCards.forEach(card => {
            const stampId = getCardStampId(card);
            if (!stampId) return;
            const def = getStampDef(stampId);
            const delta = getStampKarmaContribution(stampId, base, laneSize);
            stampTotal += delta;
            if (card && card.uid !== null && card.uid !== undefined) stampUids.push(card.uid);
            stamps.push({ stampId, name: def ? def.name : stampId, icon: def ? def.icon : '', delta, cardUid: card?.uid ?? null });
          });
        }
        const patterns = isWin ? detectLanePatterns(laneCards) : [];
        const patternTotal = patterns.reduce((sum, p) => sum + safeNumber(p.delta, 0), 0);
        const mods = blackjackMatch.playerPositions[idx].mods || [];
        const modsText = mods.length ? mods.map(m => (m > 0 ? `+${m}` : `${m}`)).join(' ') : '';
        return {
          idx, outcome: result, base,
          stamps, stampTotal,
          patterns, patternTotal,
          stampUids: Array.from(new Set(stampUids)),
          patternUids: Array.from(new Set(patterns.flatMap(p => p.cardUids || []))),
          modsText,
          laneTotal: base + stampTotal + patternTotal
        };
      });
      return { lanes };
    }

    function isResolutionAnimationActive() {
      return !!(blackjackMatch && ((blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active) || (blackjackMatch.earningsSeq && blackjackMatch.earningsSeq.active)));
    }

    function startEarningsSequence(parts, onDone) {
      if (!blackjackMatch) return;
      const steps = [];
      const push = (name, delta) => { if (safeNumber(delta, 0) !== 0) steps.push({ name, delta: safeNumber(delta, 0) }); };
      push('Payout', parts.payout || 0);
      push('Side Bet', parts.sideBet || 0);
      push('Rake', -(parts.rake || 0));
      push('Bonus', parts.bonus || 0);
      blackjackMatch.earningsSeq = { active: true, steps, idx: 0, accrued: 0, message: 'Earnings tally…', onDone };
      advanceEarningsSequence();
    }

    function advanceEarningsSequence() {
      if (!blackjackMatch || !blackjackMatch.earningsSeq || !blackjackMatch.earningsSeq.active) return;
      const es = blackjackMatch.earningsSeq;
      if (es.idx >= es.steps.length) {
        es.active = false;
        const cb = es.onDone;
        if (typeof cb === 'function') cb();
        renderAll();
        return;
      }
      const step = es.steps[es.idx++];
      es.accrued += step.delta;
      es.message = `${step.name}: ${step.delta >= 0 ? '+' : ''}${step.delta}`;
      renderAll();
      setTimeout(advanceEarningsSequence, 650);
    }

    function startScoreSequence(breakdown, extras, total, levelUpSummary = null) {
      if (!blackjackMatch) return;
      const steps = [];
      (breakdown.lanes || []).forEach(lane => {
        if (lane.base > 0) steps.push({ type: 'laneBase', lane, delta: lane.base, message: `Lane ${lane.idx + 1} win +${lane.base}`, cardUids: [] });
        if (lane.stampTotal > 0) steps.push({ type: 'laneStamps', lane, delta: lane.stampTotal, message: `Lane ${lane.idx + 1} stamps +${lane.stampTotal}`, cardUids: lane.stampUids || [] });
        if (lane.patternTotal > 0) steps.push({ type: 'lanePatterns', lane, delta: lane.patternTotal, message: `Lane ${lane.idx + 1} patterns +${lane.patternTotal}`, cardUids: lane.patternUids || [] });
      });
      for (const extra of (extras || [])) {
        if (safeNumber(extra.delta, 0) <= 0) continue;
        steps.push({ type: 'extra', lane: null, delta: safeNumber(extra.delta, 0), message: `${extra.name} +${extra.delta}`, cardUids: [] });
      }
      if (levelUpSummary && levelUpSummary.levelsGained > 0) {
        steps.push({ type: 'levelUp', lane: null, delta: 0, message: `Calling rank up ${levelUpSummary.fromRank} → ${levelUpSummary.toRank}`, cardUids: [] });
      }

      blackjackMatch.scoreSeq = {
        active: true,
        steps,
        stepIndex: 0,
        accrued: 0,
        total,
        focusLane: null,
        focusSide: null,
        focusCardUids: [],
        float: null,
        message: 'Karma tally…',
        speedMs: 1150,
        fastMs: 250,
        isFast: !!(run && run.ui && run.ui.karmaTallyFast)
      };
      advanceScoreSequence();
    }

    function finishScoreSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq) return;
      blackjackMatch.scoreSeq.active = false;
      blackjackMatch.scoreSeq.focusLane = null;
      blackjackMatch.scoreSeq.focusSide = null;
      blackjackMatch.scoreSeq.focusCardUids = [];
      blackjackMatch.scoreSeq.float = null;
      renderAll();
      if (blackjackMatch.pendingRewardStart) {
        blackjackMatch.pendingRewardStart = false;
        startWinnerRewardFlow();
      }
    }

    function advanceScoreSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq || !blackjackMatch.scoreSeq.active) return;
      const seq = blackjackMatch.scoreSeq;
      if (seq.stepIndex >= seq.steps.length) {
        finishScoreSequence();
        return;
      }
      const step = seq.steps[seq.stepIndex];
      seq.focusLane = step.lane ? step.lane.idx : null;
      seq.focusSide = step.lane ? 'player' : null;
      seq.focusCardUids = step.cardUids || [];
      seq.message = step.message || 'Karma tally…';
      if (step.delta > 0) {
        seq.accrued += step.delta;
        seq.float = {
          id: `${Date.now()}_${seq.stepIndex}`,
          laneIdx: step.lane ? step.lane.idx : null,
          side: step.lane ? 'player' : null,
          text: `+${step.delta}`,
          kind: step.type
        };
      } else {
        seq.float = null;
      }
      seq.stepIndex += 1;
      renderAll();
      const delay = seq.isFast ? seq.fastMs : seq.speedMs;
      setTimeout(advanceScoreSequence, delay);
    }

    window.skipScoreSequence = function() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq || !blackjackMatch.scoreSeq.active) return;
      blackjackMatch.scoreSeq.isFast = true;
    };

    // =============================================
    // BENCH
    // =============================================
    window.armBench = function(i) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      blackjackMatch.armedBenchIdx = (blackjackMatch.armedBenchIdx === i) ? null : i;
      renderBlackjack();
    };

    window.applyBenchTo = function(side, posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;

      const mod = blackjackMatch.bench[bi];
      if (!mod || !isModifier(mod)) return;

      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      pos.mods = pos.mods || [];
      pos.mods.push(mod.delta);
      pos.lastPlay = { kind: 'mod', delta: mod.delta };
      onCardPlacedForAttack(pos, mod);

      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      if (side === 'player') blackjackMatch.metrics.benchModsToPlayer += 1;
      else blackjackMatch.metrics.benchModsToDealer += 1;

      logEvent('BENCH_APPLY', { card: cardToString(mod), cardUid: mod.uid || null, cardRef: cardRef(mod), side, lane: posIdx + 1, delta: mod.delta });

      if (side === 'player') maybeAward21BonusForPlayerPos(posIdx);

      renderAll();
      showToast(`Played ${cardToString(mod)} to ${side} #${posIdx + 1}`);
    };

    function handleCallingSuitOnPlayerCardPlaced(placedCard, laneIdx, onComplete) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return false;
      if (!run || !run.callingCard) return false;
      if (!isStandardCard(placedCard)) return false;

      const stampId = getCardStampId(placedCard);
      const proxySuit = stampId === 'PROXY_SUIT';
      const matchesCalling = placedCard.suit === run.callingCard.suit || proxySuit;
      const procMult = stampId === 'DEJA_VU' ? 2 : 1;
      const effectiveSuit = proxySuit ? run.callingCard.suit : placedCard.suit;

      if (!matchesCalling) {
        blackjackMatch.lastCallingSuitPlay = null;
        return false;
      }

      const procced = Math.random() < blackjackMatch.callingProcChance;
      blackjackMatch.lastCallingSuitPlay = {
        laneIdx,
        suit: effectiveSuit,
        procced,
        card: placedCard,
        procMult
      };

      if (!procced) return false;

      if (effectiveSuit === '♦') {
        const bonus = DIAMOND_BONUS_CHIPS * procMult;
        run.chips += bonus;
        blackjackMatch.bonusChipsEarned += bonus;
        logEvent('CALLING_PROC_DIAMOND', {
          laneIdx: laneIdx + 1,
          amount: bonus,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        renderHUD();
        showToast(`+${bonus} chips (Wealth)`);
        showProcBanner({ suit: '♦', title: 'Calling Proc · Wealth', desc: `+${bonus} chips awarded` });
        return false;
      }

      if (effectiveSuit === '♠') {
        blackjackMatch.spadePeekLanes.add(laneIdx);
        logEvent('CALLING_PROC_SPADES', {
          laneIdx: laneIdx + 1,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        showToast(`Intel: Revealed Dealer lane #${laneIdx + 1}`);
        showProcBanner({ suit: '♠', title: 'Calling Proc · Intel', desc: `Dealer lane #${laneIdx + 1} revealed` });
        renderBlackjack();
        return false;
      }

      if (effectiveSuit === '♣') {
        const dPos = blackjackMatch.dealerPositions[laneIdx];
        if (!dPos || !dPos.isOpen || dPos.isComplete) {
          logEvent('CALLING_PROC_CLUBS', {
            laneIdx: laneIdx + 1,
            delta: null,
            blocked: true,
            callingCard: run.callingCard,
            playedCard: placedCard,
            multiplier: procMult
          });
          return false;
        }

        showModal('Power Proc', `
          <p class="modal-text">Choose effect on Dealer lane #${laneIdx + 1}.</p>
          <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
            <button class="modal-btn" onclick="applyCallingClubs(${laneIdx}, 1)">+1</button>
            <button class="modal-btn danger" onclick="applyCallingClubs(${laneIdx}, -1)">-1</button>
          </div>
        `, []);

        window.applyCallingClubs = function(targetIdx, delta) {
          const target = blackjackMatch.dealerPositions[targetIdx];
          if (target && target.isOpen && !target.isComplete) {
            target.mods = target.mods || [];
            for (let i = 0; i < procMult; i++) target.mods.push(delta);
            logEvent('CALLING_PROC_CLUBS', {
              laneIdx: targetIdx + 1,
              delta,
              callingCard: run.callingCard,
              playedCard: placedCard,
              multiplier: procMult
            });
            showToast(`Power: Dealer lane #${targetIdx + 1} ${delta > 0 ? '+1' : '-1'}`);
          }
          closeModal();
          delete window.applyCallingClubs;
          renderAll();
          onComplete();
        };
        return true;
      }

      return false;
    }

    window.playerPlaceBenchCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;
      const c = blackjackMatch.bench[bi];
      if (!c || isModifier(c)) return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      pos.cards.push(c);
      pos.lastPlay = { kind: 'card', rank: c.rank, value: getStrikeValueFromCard(c) };
      onCardPlacedForAttack(pos, c);
      recordLaneCard('player', posIdx);
      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      blackjackMatch.metrics.benchCardsPlaced += 1;
      logEvent('BENCH_PLACE', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'bench_place');
      const deferred = handleCallingSuitOnPlayerCardPlaced(c, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };

    // =============================================
    // PLAYER TURN: drawing places modifiers into bench automatically
    // =============================================
    window.playerDrawCard = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;
      if (countOpenPositions(blackjackMatch.playerPositions) === 0) return;

      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'draw');
          return;
        }
        if (isModifier(c)) {
          benchPush(c, 'player-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)}`);
          continue;
        }
        if (c && c.sleeveId === 'BLUE') {
          benchPush(c, 'blue-sleeve');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'blue-sleeve' });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)} (Blue Sleeve)`);
          continue;
        }
        blackjackMatch.drawnCard = c;
        blackjackMatch.metrics.playerDraws += 1;
        logEvent('PLAYER_DRAW', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
        renderBlackjack();
        return;
      }

      triggerDeckExhaustion('player', 'draw');
    };

    window.playerPlaceCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (!blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      const placed = blackjackMatch.drawnCard;
      pos.cards.push(placed);
      pos.lastPlay = { kind: 'card', rank: placed.rank, value: getStrikeValueFromCard(placed) };
      onCardPlacedForAttack(pos, placed);
      recordLaneCard('player', posIdx);
      blackjackMatch.drawnCard = null;

      logEvent('PLAYER_PLACE', { card: cardToString(placed), cardUid: placed.uid || null, cardRef: cardRef(placed), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_place');

      // Apply pending splitDecision dealer gift (after player placement)
      if (blackjackMatch.pending && blackjackMatch.pending.type === 'splitDecision') {
        const gift = blackjackMatch.pending.dealerGiftCard;
        blackjackMatch.pending = null;
        dealerPlaceOneCard(gift, true);
      }

      const deferred = handleCallingSuitOnPlayerCardPlaced(placed, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };

    window.playerStand = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      tryFireCloseAttack('player', posIdx);
      pos.isComplete = true;

      // If they close while >21, it is a bust now (closure reveals score)
      const total = getPositionTotal(pos);
      pos.isBust = total > 21;

      blackjackMatch.metrics.playerStands += 1;

      logEvent('PLAYER_STAND', { lane: posIdx + 1, total, bust: pos.isBust });


      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_stand');

      if (checkMatchEnd()) return;

      if (countOpenPositions(blackjackMatch.playerPositions) === 0) {
        endPlayerTurn();
        return;
      }

      renderBlackjack();
    };

    window.playerEndTurn = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;

      for (let i = 0; i < 5; i++) {
        const pos = blackjackMatch.playerPositions[i];
        if (!pos || !pos.isOpen || pos.isComplete) continue;
        tryFireCloseAttack('player', i);
        pos.isComplete = true;
        const total = getPositionTotal(pos);
        pos.isBust = total > 21;
        blackjackMatch.metrics.playerStands += 1;
        logEvent('PLAYER_STAND', { lane: i + 1, total, bust: pos.isBust, source: 'CLOSE_END' });
      }

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_end_turn_close');
      if (checkMatchEnd()) return;
      endPlayerTurn();
    };

    function endPlayerTurn() {
      blackjackMatch.metrics.turns += 1;

      // Finalize busts at end of player's turn (per spec)
      const preBust = blackjackMatch.playerPositions.map(p => !!p.isBust);
      finalizeBusts(blackjackMatch.playerPositions, 'player');
      updateThreatTargetLane(false, 'bust_finalize');

      const lastPlay = blackjackMatch.lastCallingSuitPlay;
      if (lastPlay && lastPlay.procced && lastPlay.suit === '♥') {
        const newlyBusted = blackjackMatch.playerPositions
          .map((p, idx) => ({ p, idx }))
          .filter(({ p, idx }) => !preBust[idx] && p.isBust);

        const triageCount = Math.max(1, safeNumber(lastPlay.procMult, 1));
        let remaining = triageCount;

        while (newlyBusted.length && remaining > 0) {
          let targetIdx = newlyBusted.findIndex(n => n.idx === lastPlay.laneIdx);
          if (targetIdx === -1) targetIdx = 0;
          const target = newlyBusted.splice(targetIdx, 1)[0];
          const pos = target.p;
          const discarded = pos.cards.pop();
          pos.isBust = false;
          pos.isComplete = false;
          logEvent('CALLING_PROC_HEARTS_TRIAGE', {
            laneIdx: target.idx + 1,
            discardedCard: cardToString(discarded),
            callingCard: run.callingCard,
            playedCard: lastPlay.card,
            multiplier: triageCount
          });
          showToast(`Health: Triage saved lane #${target.idx + 1}`);
          showProcBanner({ suit: '♥', title: 'Calling Proc · Triage', desc: `Recovered lane #${target.idx + 1}` });
          remaining -= 1;
        }
      }
      blackjackMatch.lastCallingSuitPlay = null;

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');

      if (checkMatchEnd()) return;

      blackjackMatch.turn = 'dealer';
      renderBlackjack();

      clearDealerTimers();
      dealerTimerA = setTimeout(dealerTurn, 800);
    }

    // =============================================
    // DEALER AI + placement helpers
    // =============================================
function dealerRiskPenalty(total) {
  if (total <= 11) return 0;          // explicitly prefers <=11 (e.g. 11 over 12)
  if (total === 12) return 2.2;
  if (total === 13) return 1.8;
  if (total === 14) return 1.5;
  if (total === 15) return 1.2;
  if (total === 16) return 1.0;
  if (total === 17) return 0.55;
  if (total === 18) return 0.30;
  if (total === 19) return 0.18;
  if (total === 20) return 0.10;
  return 0; // 21
}

function estimatePlayerTargetForLane(idx, diff) {
  const pPos = blackjackMatch.playerPositions[idx];
  if (!pPos) return 18;

  const pTotal = getPositionTotal(pPos);
  const pComplete = !!pPos.isComplete;
  const pBust = !!pPos.isBust || (pComplete && pTotal > 21);

  if (pBust) return 0;
  if (pComplete) return Math.min(21, pTotal);

  // Incomplete lanes: heuristic expectation
  if (diff === 'easy') return Math.min(21, pTotal);
  if (diff === 'medium') return Math.min(21, Math.max(pTotal, 17));

  // hard: assumes player pushes safely to ~17-18 when low
  if (pTotal <= 11) return 18;
  if (pTotal <= 14) return 18;
  if (pTotal <= 16) return 17;
  return Math.min(21, pTotal);
}

function dealerLaneScore(idx, total, diff) {
  if (total > 21) return -10000 - total;

  const target = estimatePlayerTargetForLane(idx, diff);

  // If player is (known or assumed) busted, just don't bust; prefer safer totals (<=11)
  if (target === 0) {
    return 120 + (total <= 11 ? (11 - Math.abs(11 - total)) : 0) - dealerRiskPenalty(total) * 12;
  }

  const winNeed = Math.min(21, target + 1);
  const winBonus = (total >= winNeed) ? 140 : 0;
  const closeBonus = (total === 21) ? 260 : (total === 20) ? 90 : (total === 19) ? 45 : 0;
  const pushPenalty = (total === target) ? 14 : 0;

  const risk = dealerRiskPenalty(total) * 12;

  return total + winBonus + closeBonus - risk - pushPenalty;
}

    function dealerPlaceOneCard(card, fromAction = false) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      if (run.bossFight && run.bossFight.active && run.bossFight.phase === 2) {
        bossTryCountermeasure();
      }
      if (blackjackMatch.type === 'WATCHER') {
        updateThreatTargetLane(false, 'dealer_turn_start');
      }

      const open = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (open.length === 0) return;

      // Forced lane (Forced Play action)
      let targetIdx = -1;
      const forced = blackjackMatch.dealerForcedLane;
      if (forced !== null && forced !== undefined) {
        const fp = blackjackMatch.dealerPositions[forced];
        if (fp && fp.isOpen && !fp.isComplete) targetIdx = forced;
        blackjackMatch.dealerForcedLane = null;
      }

      // If not forced, choose by marginal improvement (and some randomness on Easy)
      if (targetIdx === -1) {
        const scored = open.map(({ pos, idx }) => {
          const before = getPositionTotal(pos);
          const beforeScore = dealerLaneScore(idx, before, diff);

          const simulated = { cards: [...pos.cards, card], mods: pos.mods || [] };
          const after = getPositionTotal(simulated);
          const afterScore = dealerLaneScore(idx, after, diff);

          return { idx, before, after, delta: (afterScore - beforeScore), afterScore };
        }).sort((a, b) => b.delta - a.delta);

        if (diff === 'easy') {
          // Easy: pick among top 2 if they exist, weighted by being "not awful"
          const top = scored.slice(0, Math.min(2, scored.length));
          top.sort((a, b) => b.afterScore - a.afterScore);
          targetIdx = (top.length === 1) ? top[0].idx : (Math.random() < 0.55 ? top[0].idx : top[1].idx);
        } else {
          // Medium/Hard: best delta, but if all negative, choose least bad afterScore
          if (scored[0].delta >= 0) targetIdx = scored[0].idx;
          else targetIdx = scored.sort((a, b) => b.afterScore - a.afterScore)[0].idx;
        }
      }

      if (targetIdx >= 0) {
        blackjackMatch.dealerPositions[targetIdx].cards.push(card);
        blackjackMatch.dealerPositions[targetIdx].lastPlay = { kind: 'card', rank: card.rank, value: getStrikeValueFromCard(card) };
        onCardPlacedForAttack(blackjackMatch.dealerPositions[targetIdx], card);
        recordLaneCard('dealer', targetIdx);
        if (blackjackMatch.spadePeekLanes) blackjackMatch.spadePeekLanes.delete(targetIdx);

        blackjackMatch.metrics.dealerDraws += 1;

        if (fromAction) {
          renderBlackjack();
          showToast(`Dealer played ${cardToString(card)}`);
        }
      }
    }


function dealerDrawPlayableCard() {
  // draw until non-mod; mods go to dealerBench
  let safety = 0;
  while (safety++ < 300) {
    const fb = (blackjackMatch && blackjackMatch.dealerBaseDeck) ? blackjackMatch.dealerBaseDeck : makeStandardDeck52();
    const c = drawCardFromPile(blackjackMatch.dealerDrawPile, fb);
    if (!c) return null;
    if (isModifier(c)) {
      blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
      blackjackMatch.dealerBench.push(c);
      blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
      logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'dealer-turn-draw' });
      continue;
    }
    return c;
  }
  return null;
}

function dealerApplyBenchMod(bestMove) {
  const { modIdx, laneIdx, modCard, reason } = bestMove;
  const pos = blackjackMatch.dealerPositions[laneIdx];
  if (!pos || !pos.isOpen || pos.isComplete) return false;

  pos.mods = pos.mods || [];
  pos.mods.push(modCard.delta);
  pos.lastPlay = { kind: 'mod', delta: modCard.delta };
  onCardPlacedForAttack(pos, modCard);

  blackjackMatch.dealerBench.splice(modIdx, 1);
  blackjackMatch.metrics.dealerBenchModsUsed = safeNumber(blackjackMatch.metrics.dealerBenchModsUsed, 0) + 1;

  logEvent('DEALER_BENCH_APPLY', { card: cardToString(modCard), cardUid: modCard.uid || null, cardRef: cardRef(modCard), lane: laneIdx + 1, delta: modCard.delta, reason });
  return true;
}

function dealerFindBestBenchMove(diff, phase) {
  const bench = blackjackMatch.dealerBench || [];
  if (!bench.length) return null;

  const open = blackjackMatch.dealerPositions
    .map((p, i) => ({ pos: p, idx: i }))
    .filter(d => d.pos.isOpen && !d.pos.isComplete);

  if (!open.length) return null;

  let best = null;

  for (let mi = 0; mi < bench.length; mi++) {
    const m = bench[mi];
    if (!isModifier(m)) continue;

    for (const { pos, idx } of open) {
      const before = getPositionTotal(pos);
      const after = getPositionTotal({ cards: pos.cards, mods: [...(pos.mods || []), m.delta] });

      // Phase rules:
      // - salvage: prioritize fixing would-be busts (before>21 -> after<=21)
      // - strategic: only play if it *improves* lane score (no forced plays)
      const beforeScore = dealerLaneScore(idx, before, diff);
      const afterScore = dealerLaneScore(idx, after, diff);
      const gain = afterScore - beforeScore;

      if (phase === 'salvage') {
        const fixesBust = (before > 21 && after <= 21);
        if (!fixesBust && gain <= 0) continue;
      } else {
        if (gain <= 0) continue;
      }

      // Prefer “closer to 21” but still safe; risk penalty encodes 11>12 preference.
      const move = {
        modIdx: mi,
        laneIdx: idx,
        modCard: m,
        gain,
        reason: (phase === 'salvage') ? 'salvage' : 'strategic'
      };

      if (!best || move.gain > best.gain) best = move;
    }
  }

  return best;
}

function dealerShouldStandLane(idx, diff) {
  const dPos = blackjackMatch.dealerPositions[idx];
  if (!dPos || !dPos.isOpen || dPos.isComplete) return false;

  const total = getPositionTotal(dPos);
  if (total > 21) return false;

  const pPos = blackjackMatch.playerPositions[idx];
  const pTotal = pPos ? getPositionTotal(pPos) : 0;
  const pComplete = !!(pPos && pPos.isComplete);
  const pBustKnown = !!(pPos && pPos.isComplete && (pPos.isBust || pTotal > 21));

  // If player lane is definitively busted, lock it in (hard/medium); easy sometimes dithers.
  if (pBustKnown) {
    if (diff === 'easy') return (total >= 12) || (Math.random() < 0.25);
    return true;
  }

  // If player lane is complete (known target)
  if (pComplete) {
    if (total > pTotal && total >= 13) return true;
    if (diff === 'hard') return total >= 19;
    return total >= 17; // medium/easy baseline
  }

  // Player lane incomplete: estimate and choose
  const target = estimatePlayerTargetForLane(idx, diff);

  if (diff === 'easy') {
    return (total >= 16 && Math.random() < 0.70) || total >= 19;
  }
  if (diff === 'medium') {
    if (total >= 17) return true;
    if (total >= 15 && total >= target + 2) return true;
    return false;
  }

  // hard
  if (total >= 19) return true;
  if (total >= 17 && total >= target + 1) return true;
  if (total >= 15 && total >= target + 3) return true;
  return false;
}

function dealerStandPhase(diff, maxPasses = 6) {
  let passes = 0;
  let changed = true;

  while (changed && passes++ < maxPasses) {
    changed = false;

    for (let i = 0; i < 5; i++) {
      const pos = blackjackMatch.dealerPositions[i];
      if (!pos.isOpen || pos.isComplete) continue;

      if (dealerShouldStandLane(i, diff)) {
        tryFireCloseAttack('dealer', i);
        pos.isComplete = true;
        pos.isBust = (getPositionTotal(pos) > 21);
        blackjackMatch.metrics.dealerStands += 1;
        changed = true;


        // Keep 3 open lanes
        const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');
      }
    }
  }
}

    function dealerTurn() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      if (blackjackMatch.type === 'WATCHER') {
        updateThreatTargetLane(true, 'watcher_turn_start');
        const idx = blackjackMatch.watcherTargetLaneIdx;
        if (idx !== null && idx !== undefined && blackjackMatch.dealerForcedLane == null) {
          blackjackMatch.dealerForcedLane = idx;
        }
      }

      // 1) Strategic bench use (no forced plays; only if improves)
      const benchBudget = (diff === 'hard') ? 2 : (diff === 'medium') ? 1 : (Math.random() < 0.35 ? 1 : 0);
      for (let k = 0; k < benchBudget; k++) {
        const move = dealerFindBestBenchMove(diff, 'strategic');
        if (!move) break;
        dealerApplyBenchMod(move);
      }

      // 2) Standing decisions (dynamic)
      dealerStandPhase(diff);

      renderBlackjack();
      if (checkMatchEnd()) return;

      // 3) Draw + place one card (mods drawn become dealer bench)
      const openPositions = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (openPositions.length === 0) {
        endDealerTurn();
        return;
      }

      clearDealerTimers();
      dealerTimerB = setTimeout(() => {
        const card = dealerDrawPlayableCard();
        if (!card) {
          triggerDeckExhaustion('dealer', 'draw');
          return;
        }
        dealerPlaceOneCard(card);

        // 4) Salvage: if any lanes would bust at end-of-turn, try negatives first
        const salvageBudget = (diff === 'hard') ? 2 : 1;
        for (let k = 0; k < salvageBudget; k++) {
          const move = dealerFindBestBenchMove(diff, 'salvage');
          if (!move) break;
          dealerApplyBenchMod(move);
        }

        // Optional final stand pass (locks in “already winning” lanes)
        if (diff !== 'easy') dealerStandPhase(diff, 2);

        endDealerTurn();
      }, 600);
    }

    function endDealerTurn() {
      // Finalize busts at end of dealer turn
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');
      updateThreatTargetLane(false, 'bust_finalize');

      const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
      maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');

      if (checkMatchEnd()) return;

      blackjackMatch.turn = 'player';
      blackjackMatch.actionUsedThisTurn = false;
      blackjackMatch.actionSelectionInProgress = false;
      renderBlackjack();
    }


    function checkMatchEnd() {
      const playerDone = allPositionsComplete(blackjackMatch.playerPositions);
      const dealerDone = allPositionsComplete(blackjackMatch.dealerPositions);

      if (playerDone && dealerDone) {
        resolveMatch();
        return true;
      }

      if (playerDone && !dealerDone && blackjackMatch.turn === 'player') {
        blackjackMatch.turn = 'dealer';
        renderBlackjack();
        clearDealerTimers();
        dealerTimerA = setTimeout(dealerTurn, 800);
        return true;
      }

      return false;
    }

    function resolveMatch(options = {}) {
      blackjackMatch.phase = 'resolved';
      clearDealerTimers();

      // defensive finalize
      finalizeBusts(blackjackMatch.playerPositions, 'player');
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');

      let playerWins = 0;
      let dealerWins = 0;
      const positionResults = [];
      let transferNet = 0;

      const playerTotals = [];
      const dealerTotals = [];
      const playerBusts = [];
      const dealerBusts = [];

      for (let i = 0; i < 5; i++) {
        const pPos = blackjackMatch.playerPositions[i];
        const dPos = blackjackMatch.dealerPositions[i];

        const pTotal = getPositionTotal(pPos);
        const dTotal = getPositionTotal(dPos);
        const pBust = !!pPos.isBust;
        const dBust = !!dPos.isBust;

        playerTotals.push(pTotal);
        dealerTotals.push(dTotal);
        playerBusts.push(pBust);
        dealerBusts.push(dBust);

        let result;
        if (!pBust && (dBust || pTotal > dTotal)) {
          playerWins++;
          result = 'player';
        } else if (!dBust && (pBust || dTotal > pTotal)) {
          dealerWins++;
          result = 'dealer';
        } else {
          result = 'push';
        }
        positionResults.push(result);

        // Transfers
        if ((pBust && dBust) || (!pBust && !dBust && pTotal === dTotal)) continue;

        if (!pBust && dBust) transferNet += pTotal;
        else if (pBust && !dBust) transferNet -= dTotal;
        else if (!pBust && !dBust) {
          const diff = Math.abs(pTotal - dTotal);
          transferNet += (pTotal > dTotal) ? diff : -diff;
        }
      }

      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      transferNet *= transferMultiplier;

      let outcome;
      let payout;
      if (playerWins > dealerWins) {
        outcome = 'WIN';
        payout = blackjackMatch.buyIn * 2;
      } else if (dealerWins > playerWins) {
        outcome = 'LOSS';
        payout = 0;
      } else {
        outcome = 'TIE';
        payout = blackjackMatch.buyIn;
      }

      const bf = run && run.bossFight;
      const isBossRound = blackjackMatch.type === 'BOSS' && bf && bf.active;

      // Boss tie = loss (only for legacy single-round boss fights)
      if (!isBossRound && blackjackMatch.type === 'BOSS' && outcome === 'TIE') {
        outcome = 'LOSS';
        payout = 0;
      }

      if (options && options.forcedOutcome) {
        outcome = options.forcedOutcome;
        if (outcome === 'WIN') payout = blackjackMatch.buyIn * 2;
        else if (outcome === 'LOSS') payout = 0;
        else payout = blackjackMatch.buyIn;
      }

      blackjackMatch.transferChipsNet = transferNet;
      let bossDefeatedNow = false;

      if (isBossRound && outcome === 'WIN') {
        const laneDamage = positionResults.reduce((sum, r, i) => sum + (r === 'player' ? playerTotals[i] : 0), 0);
        const lanesWon = playerWins;
        const tm = blackjackMatch.transferMultiplier || 1;
        const bonusDamage = Math.min(5, Math.round(Math.min(5, lanesWon) * ((tm - 1) / 4)));
        const totalDamage = laneDamage + bonusDamage;
        const hpBefore = bf.hp;
        bf.hp = Math.max(0, bf.hp - totalDamage);
        bossDefeatedNow = bf.hp === 0;

        blackjackMatch.bossDamage = {
          laneDamage,
          bonusDamage,
          totalDamage,
          hpBefore,
          hpAfter: bf.hp,
          lanesWon,
          transferMultiplier: tm
        };

        logEvent('BOSS_DAMAGE', blackjackMatch.bossDamage);
      }

      if (isBossRound && bf.phase === 1 && bf.hp > 0 && bf.hp <= bf.maxHp / 2) {
        bf.phase = 2;
        bf.targetLaneIdx = null;
      }

      let goldBonusTotal = 0;
      for (let i = 0; i < 5; i++) {
        const pPos = blackjackMatch.playerPositions[i];
        const hasGold = (pPos.cards || []).some(c => c && c.sleeveId === 'GOLD');
        if (hasGold) {
          const amount = safeNumber(playerTotals[i], 0);
          goldBonusTotal += amount;
          logEvent('GOLD_SLEEVE_BONUS', { laneIdx: i + 1, amount });
        }
      }
      if (goldBonusTotal > 0) {
        run.chips = safeNumber(run.chips) + goldBonusTotal;
        blackjackMatch.bonusChipsEarned += goldBonusTotal;
      }

      const callingRankBefore = run.callingCard ? run.callingCard.rank : null;
      const karmaBreakdown = buildKarmaBreakdown(positionResults, playerTotals);
      const karmaLaneGain = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.laneTotal, 0);
      const karmaStampTotal = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.stampTotal, 0);
      const karmaPatternTotal = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.patternTotal, 0);
      const karmaExtras = [];

      if (outcome === 'WIN') {
        const decisiveMap = { 2: 10, 3: 25, 4: 45, 5: 70 };
        const decisive = decisiveMap[playerWins] || 0;
        if (decisive > 0) karmaExtras.push({ name: 'Decisive Win', delta: decisive, kind: 'decisive' });

        run.karmaWinStreak = safeNumber(run.karmaWinStreak, 0) + 1;
        const s = run.karmaWinStreak;
        let streakBonus = 0;
        if (s >= 5) streakBonus = 75;
        else if (s === 4) streakBonus = 50;
        else if (s === 3) streakBonus = 30;
        else if (s === 2) streakBonus = 15;
        if (streakBonus > 0) karmaExtras.push({ name: `Win Streak x${s}`, delta: streakBonus, kind: 'streak' });

        if (safeNumber(blackjackMatch.metrics.playerBustsFinal, 0) === 0) {
          karmaExtras.push({ name: 'No Bust Win', delta: 20, kind: 'clean' });
        }

        const twentyOneWins = positionResults.reduce((n, r, i) => n + ((r === 'player' && safeNumber(playerTotals[i], 0) === 21) ? 1 : 0), 0);
        const exact21Bonus = Math.min(50, twentyOneWins * 10);
        if (exact21Bonus > 0) karmaExtras.push({ name: '21-on-Win', delta: exact21Bonus, kind: 'twentyone' });
      } else {
        run.karmaWinStreak = 0;
      }

      if (outcome === 'WIN') {
        if (isBossRound) {
          const roundWeight = Math.max(1, (bf.maxRounds - bf.round + 1));
          const lanesWon = playerWins;
          const bonusDamage = blackjackMatch.bossDamage ? blackjackMatch.bossDamage.bonusDamage : 0;
          const bossWinBonus = (25 * roundWeight) + (10 * lanesWon) + (5 * bonusDamage);
          if (bossWinBonus > 0) karmaExtras.push({ name: 'Boss Win Bonus', delta: bossWinBonus, kind: 'boss_win' });
          if (bossDefeatedNow) {
            karmaExtras.push({ name: 'Boss Defeat Bonus', delta: 50 * roundWeight, kind: 'boss_defeat' });
          }
        } else {
          const baseBonus = blackjackMatch.type === 'STANDARD' ? 50 : 100;
          const standardWinBonus = baseBonus * transferMultiplier;
          if (standardWinBonus > 0) karmaExtras.push({ name: 'Match Win Bonus', delta: standardWinBonus, kind: 'match_win' });
        }
      }

      const karmaExtraTotal = karmaExtras.reduce((sum, e) => sum + safeNumber(e.delta, 0), 0);
      const karmaGained = karmaLaneGain + karmaExtraTotal;
      run.karma = Math.max(0, safeNumber(run.karma, 0) + karmaGained);
      const levelUpSummary = maybeLevelUpCallingCardFromKarma();
      const callingRankAfter = run.callingCard ? run.callingCard.rank : null;

      blackjackMatch.result = {
        outcome,
        payout,
        playerWins,
        dealerWins,
        positionResults,
        transferMultiplier,
        exhaustion: options.exhaustion || null,
        karmaGained,
        karmaBreakdown: { ...karmaBreakdown, extras: karmaExtras, total: karmaGained }
      };

      // finalize bust counts for match metrics
      blackjackMatch.metrics.playerBustsFinal = blackjackMatch.playerPositions.filter(p => p.isBust).length;
      blackjackMatch.metrics.dealerBustsFinal = blackjackMatch.dealerPositions.filter(p => p.isBust).length;

      const burnCards = [];
      blackjackMatch.playerPositions.forEach(pos => {
        (pos.cards || []).forEach(card => {
          if (getCardStampId(card) === 'BURN_AFTER_READING') burnCards.push(card);
        });
      });
      const burnedSleeves = blackjackMatch.burnedSleeveCards || [];
      if (burnCards.length || burnedSleeves.length) {
        const burnSet = new Set([...burnCards, ...burnedSleeves]);
        run.playerDeck = run.playerDeck.filter(card => isKeyCard(card) || !burnSet.has(card));
        recordDeckSnapshot('BURN_AFTER_READING');
      }
      if (burnCards.length) {
        logEvent('BURN_AFTER_READING', {
          count: burnCards.length,
          cards: burnCards.map(cardToString),
          cardUids: burnCards.map(card => card.uid || null),
          cardRefs: burnCards.map(cardRef)
        });
      }

      // House rake applies to positive net results (payout + transfer) only
const grossWin = payout + transferNet;
const rakeRate = getHouseRakeRate(run.floor);
const rake = (grossWin > 0 && rakeRate > 0) ? Math.floor(grossWin * rakeRate) : 0;

blackjackMatch.result.rake = rake;
blackjackMatch.result.rakeRate = rakeRate;

run.chips = safeNumber(run.chips) + payout + transferNet - rake;

      const durationMs = Math.round(performance.now() - blackjackMatch.metrics.startedAtMs);

      logEvent('MATCH_END', {
        type: blackjackMatch.type,
        outcome,
        matchSeq: blackjackMatch.matchSeq,
        buyIn: blackjackMatch.buyIn,
        payout,
        playerWins,
        dealerWins,
        transferNet,
        transferMultiplier,
        rake,
        rakeRate,
        bonusChips: blackjackMatch.bonusChipsEarned || 0,
        karmaGained,
        callingRankBefore,
        callingRankAfter,
        levelsGained: levelUpSummary ? levelUpSummary.levelsGained : 0,
        karmaLaneGain,
        karmaStampTotal,
        karmaPatternTotal,
        karmaExtraTotal,
        karmaExtras,
        exhaustion: options.exhaustion || null,
        durationMs,
        lanes: {
          playerTotals, dealerTotals,
          playerBusts, dealerBusts,
          laneWinners: positionResults
        },
        metrics: { ...blackjackMatch.metrics },
        laneCards: blackjackMatch.metrics.laneCards,
        deckSnapshot: deckSnapshot()
      });

      if (karmaGained > 0) {
        logEvent('KARMA_GAIN', { amount: karmaGained, total: run.karma, laneKarma: karmaLaneGain, stampKarma: karmaStampTotal, patternKarma: karmaPatternTotal, extraKarma: karmaExtraTotal });
      }

      const bonus = blackjackMatch.bonusChipsEarned || 0;
      startEarningsSequence({ payout, sideBet: transferNet, rake, bonus }, () => startScoreSequence(karmaBreakdown, karmaExtras, karmaGained, levelUpSummary));

      renderAll();

      if (transferNet !== 0) showToast(`Side bet result: ${transferNet > 0 ? '+' : ''}${transferNet} chips`);

      // Winner reward flow (only if WIN)
      if (blackjackMatch.result.outcome === 'WIN') {
        if (isBossRound) {
          if (bossDefeatedNow) {
            blackjackMatch.rewardPending = true;
            blackjackMatch.pendingRewardStart = true;
            if (!isResolutionAnimationActive()) {
              blackjackMatch.pendingRewardStart = false;
              startWinnerRewardFlow();
            }
          }
        } else {
          blackjackMatch.rewardPending = true;
          blackjackMatch.pendingRewardStart = true;
          if (!isResolutionAnimationActive()) {
            blackjackMatch.pendingRewardStart = false;
            startWinnerRewardFlow();
          }
        }
      }
    }

    // =============================================
    // WINNER REWARD FLOW (after a WIN)
    // =============================================
    function startWinnerRewardFlow() {
      if (blackjackMatch.specialReward === 'KEY_HIGH') {
        const key = makeKeyCard('HIGH_STAKES');
        assignUid(key);
        run.playerDeck.push(key);
        if (run.secret && run.secret.keys) run.secret.keys.highStakes.obtained = true;
        logEvent('KEYCARD_OBTAINED', { source: 'HIGH_STAKES', card: cardRef(key) });
        recordDeckSnapshot('KEYCARD_HIGH_STAKES');
        blackjackMatch.rewardPending = false;
        blackjackMatch.winnerReward = null;
        showToast('You won a star keycard.');
        return;
      }
      if (blackjackMatch.type === 'BOSS' && run.floor === 3 && run.secret && run.secret.keys && !run.secret.keys.boss.obtained) {
        const key = makeKeyCard('BOSS');
        assignUid(key);
        run.playerDeck.push(key);
        run.secret.keys.boss.obtained = true;
        logEvent('KEYCARD_OBTAINED', { source: 'BOSS', card: cardRef(key) });
        recordDeckSnapshot('KEYCARD_BOSS');
        blackjackMatch.rewardPending = false;
        blackjackMatch.winnerReward = null;
        showToast('The boss dropped a star keycard.');
        return;
      }
      if (blackjackMatch.type === 'BOSS') {
        startBossFusionRewardFlow();
        return;
      }
      blackjackMatch.winnerReward = { stage: 'mode', mode: null, candidates: [], selected: null };
      showWinnerRewardModeModal();
    }

    function startBossFusionRewardFlow() {
      blackjackMatch.winnerReward = { stage: 'pick', mode: 'fuse', candidates: [], selected: [] };
      const eligible = run.playerDeck
        .map((c, i) => ({ card: c, index: i }))
        .filter(d => isStandardCard(d.card));

      const picks = shuffle(eligible).slice(0, 5);
      blackjackMatch.winnerReward.candidates = picks;
      blackjackMatch.winnerReward.selected = [];

      showBossFusionModal();
    }

    function showBossFusionModal() {
      const wr = blackjackMatch.winnerReward;
      const candidates = wr.candidates || [];
      const selected = wr.selected || [];
      const canFuse = candidates.length >= 2;

      const body = `
        <p class="modal-text">Boss reward: pick two cards to fuse (or choose none).</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected.includes(idx) ? 'selected' : '';
              return `
                <div class="removal-card-option ${sel}" onclick="selectFusionCard(${idx})">
                  ${renderCard(d.card, false)}
                </div>
              `;
            }).join('')}
          </div>
        </div>
        ${canFuse ? '' : '<p class="modal-text" style="color:var(--text-muted); text-align:center;">Not enough eligible cards to fuse.</p>'}
      `;

      showModal('Fuse Cards', body, [
        { text: 'Confirm Fusion', primary: true, disabled: !canFuse || selected.length !== 2, action: confirmFusionReward },
        { text: 'Choose None', action: () => finishFusionReward(null) }
      ]);
    }

    window.selectFusionCard = function(idx) {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      const selected = wr.selected || [];
      if (selected.includes(idx)) {
        wr.selected = selected.filter(i => i !== idx);
      } else if (selected.length < 2) {
        wr.selected = [...selected, idx];
      }
      showBossFusionModal();
    };

    function confirmFusionReward() {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      if (!wr.selected || wr.selected.length !== 2) return;
      const picks = wr.selected.map(i => wr.candidates[i]).filter(Boolean);
      if (picks.length !== 2) return;
      finishFusionReward(picks);
    }

    function finishFusionReward(picks) {
      if (!blackjackMatch) return;
      if (picks && picks.length === 2) {
        const [a, b] = picks;
        const sorted = [a.index, b.index].sort((x, y) => y - x);
        const cardA = run.playerDeck[a.index];
        const cardB = run.playerDeck[b.index];
        sorted.forEach(idx => run.playerDeck.splice(idx, 1));
        const fused = { uid: null, type: 'FUSE', a: cardA, b: cardB };
        assignUid(fused);
        run.playerDeck.push(fused);
        logEvent('WINNER_REWARD_FUSE', {
          cards: [cardToString(cardA), cardToString(cardB)],
          cardUids: [cardA?.uid || null, cardB?.uid || null],
          cardRefs: [cardRef(cardA), cardRef(cardB)],
          fused: `${cardToString(cardA)}/${cardToString(cardB)}`,
          deckSnapshot: deckSnapshot()
        });
        recordDeckSnapshot('REWARD_FUSE');
        showToast(`Fused ${cardToString(cardA)} + ${cardToString(cardB)}`);
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: 'fuse' });
        showToast('Fusion skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;
      closeModal();
      renderAll();
    }

    function showWinnerRewardModeModal() {
      showModal('Winner Reward', `
        <p class="modal-text">You won the match. Choose a deck reward:</p>
        <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:12px;">
          <button class="modal-btn danger" onclick="chooseWinnerRewardMode('remove')">Remove</button>
          <button class="modal-btn" onclick="chooseWinnerRewardMode('duplicate')">Duplicate</button>
        </div>
        <p class="modal-text" style="margin-top:14px; color:var(--text-muted); text-align:center;">You will see 5 random cards and may pick one or choose none.</p>
      `, [
        { text: 'Skip', action: () => { finishWinnerReward(null, null); } }
      ]);
    }

    window.chooseWinnerRewardMode = function(mode) {
      if (!blackjackMatch || blackjackMatch.phase !== 'resolved') return;
      blackjackMatch.winnerReward.mode = mode;
      blackjackMatch.winnerReward.stage = 'pick';

      const eligibleIdxs = run.playerDeck.map((c,i)=>({c,i})).filter(d => !isKeyCard(d.c)).map(d=>d.i);
      const picks = shuffle(eligibleIdxs).slice(0, Math.min(5, eligibleIdxs.length));
      blackjackMatch.winnerReward.candidates = picks.map(i => ({ index: i, card: run.playerDeck[i] }));
      blackjackMatch.winnerReward.selected = null;

      logEvent('WINNER_REWARD_MODE', { mode });

      showWinnerRewardPickModal();
    };

    function showWinnerRewardPickModal() {
      const wr = blackjackMatch.winnerReward;
      const mode = wr.mode;

      const title = mode === 'remove' ? 'Remove a Card' : 'Duplicate a Card';
      const sub = mode === 'remove'
        ? 'Select a card to remove (one copy).'
        : 'Select a card to duplicate (add one copy).';

      const candidates = wr.candidates;
      const selected = wr.selected;

      const body = `
        <p class="modal-text">${sub}</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected === idx ? 'selected' : '';
            return `
              <div class="removal-card-option ${sel}" onclick="selectWinnerRewardCard(${idx})">
                  ${renderCard(d.card, false)}
              </div>
            `;
            }).join('')}
          </div>
        </div>
      `;

      showModal(title, body, [
        { text: 'Confirm', primary: true, disabled: selected === null, action: confirmWinnerReward },
        { text: 'Choose None', action: () => finishWinnerReward(mode, null) }
      ]);
    }

    window.selectWinnerRewardCard = function(idx) {
      blackjackMatch.winnerReward.selected = idx;
      showWinnerRewardPickModal();
    };

    function confirmWinnerReward() {
      const wr = blackjackMatch.winnerReward;
      if (wr.selected === null) return;
      const d = wr.candidates[wr.selected];
      finishWinnerReward(wr.mode, d);
    }

    function finishWinnerReward(mode, pickData) {
      if (!blackjackMatch) return;

      if (mode && pickData) {
        if (mode === 'remove') {
          const removed = run.playerDeck[pickData.index];
          if (!removed || isKeyCard(removed)) { showToast('Cannot remove keycards'); return; }
          run.playerDeck.splice(pickData.index, 1);
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(removed), cardUid: removed?.uid || null, cardRef: cardRef(removed), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_REMOVE');
          showToast(`Removed ${cardToString(removed)}`);
        } else if (mode === 'duplicate') {
          const c = run.playerDeck[pickData.index];
          if (!c || isKeyCard(c)) { showToast('Cannot duplicate keycards'); return; }
          if (c) {
            const clone = cloneCardWithNewUid(c);
            assignUid(clone);
            run.playerDeck.push(clone);
          }
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(c), cardUid: c?.uid || null, cardRef: cardRef(c), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_DUPLICATE');
          showToast(`Duplicated ${cardToString(c)}`);
        }
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: mode || null });
        showToast('Reward skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;

      closeModal();
      renderAll();
    }

    // =============================================
    // ACTION TOKENS + ACTION PICKER
    // =============================================
    function isPlayerActionContextOK(m) {
      return !!m && m.phase === 'playing' && m.turn === 'player';
    }

    function tokensRemaining() {
      if (!blackjackMatch) return 0;
      return Math.max(0, (blackjackMatch.tokensTotal || 0) - (blackjackMatch.tokensSpent || 0));
    }

    function canClickToken() {
      if (!blackjackMatch) return false;
      if (!isPlayerActionContextOK(blackjackMatch)) return false;
      if (blackjackMatch.actionUsedThisTurn) return false;
      if (blackjackMatch.actionSelectionInProgress) return false;
      if (tokensRemaining() <= 0) return false;
      if (!run.ownedActions || run.ownedActions.length === 0) return false;
      if (blackjackMatch.drawnCard) return false;
      return true;
    }

    window.onActionTokenClick = function() {
      if (!canClickToken()) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'ACTION_PICKER' });

      renderBlackjack();
      openActionPickerModal();
    };

    window.useActionFromBar = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (!run.ownedActions || !run.ownedActions.includes(actionId)) return;

      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.actionSelectionInProgress) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (blackjackMatch.usedActions && blackjackMatch.usedActions[actionId]) return;

      if (tokensRemaining() <= 0) { showToast('No tokens left'); return; }
      if (def.isUsable && !def.isUsable(blackjackMatch)) { showToast('Action unavailable'); return; }

      blackjackMatch.tokensSpent = safeNumber(blackjackMatch.tokensSpent, 0) + 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'COCKTAIL', actionId, via: 'ACTION_BAR' });
      renderAll();

      try {
        def.activate();
      } catch (e) {
        blackjackMatch.actionSelectionInProgress = false;
        renderAll();
        console.error(e);
        showToast('Action failed');
      }
    };

    function openActionPickerModal() {
      const owned = run.ownedActions || [];
      const used = blackjackMatch.usedActions || {};

      const listHtml = owned.map(id => {
        const def = ACTIONS[id];
        const alreadyUsed = !!used[id];
        const usable = def && def.isUsable(blackjackMatch);
        const disabled = alreadyUsed || !usable;

        const statusText = alreadyUsed ? 'USED' : (!usable ? 'UNAVAILABLE' : 'READY');
        const statusColor = alreadyUsed ? 'var(--text-muted)' : (!usable ? 'var(--accent-red)' : 'var(--accent-green)');

        return `
          <div class="action-row ${disabled ? 'disabled' : ''}">
            <div class="action-row-left">
              <div class="action-row-title">${def ? def.name : id}</div>
              <div class="action-row-desc">${def ? def.desc : ''}</div>
              <div class="action-row-desc" style="margin-top:6px; color:${statusColor}; font-weight:800;">${statusText}</div>
            </div>
            <div class="action-row-right">
              <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="attemptUseAction('${id}')">Use</button>
            </div>
          </div>
        `;
      }).join('');

      const body = `
        <p class="modal-text">Choose one action to perform. This selection consumes your token even if you cancel.</p>
        <div class="action-list">${listHtml || '<p class="modal-text">No actions unlocked.</p>'}</div>
      `;

      showModal('Actions', body, [
        {
          text: 'Cancel',
          action: () => {
            blackjackMatch.actionSelectionInProgress = false;
            closeModal();
            renderAll();
          }
        }
      ]);
    }

    window.attemptUseAction = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing' || blackjackMatch.turn !== 'player') return;
      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.usedActions[actionId]) {
        showToast('Already used this match');
        return;
      }
      if (!def.isUsable(blackjackMatch)) {
        showToast('Not usable right now');
        return;
      }

      def.activate();
    };

    function markActionUsed(actionId) {
      blackjackMatch.usedActions[actionId] = true;
      blackjackMatch.actionSelectionInProgress = false;

      blackjackMatch.metrics.actionsUsed += 1;

      const def = ACTIONS[actionId];
      logEvent('ACTION_USED', {
        actionId,
        actionName: def ? def.name : actionId,
        tokensRemaining: tokensRemaining()
      });
    }

    // =============================================
    // ACTION IMPLEMENTATIONS
    // =============================================
    function drawPlayableToHandOrBench() {
      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'action-draw');
          return null;
        }
        if (isModifier(c)) {
          benchPush(c, 'action-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          continue;
        }
        return c;
      }
      return null;
    }

    function pickDealerLaneModal(title, text, onPick) {
      const options = blackjackMatch.dealerPositions
        .map((p, i) => ({ p, i }))
        .filter(x => x.p.isOpen && !x.p.isComplete);

      if (!options.length) {
        showToast('No valid lanes');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      const btns = options.map(o => ({
        text: `Lane #${o.i + 1}`,
        action: () => onPick(o.i)
      }));

      btns.push({
        text: 'Cancel',
        action: () => {
          blackjackMatch.actionSelectionInProgress = false;
          closeModal();
          renderAll();
        }
      });

      showModal(title, `<p class="modal-text">${text}</p>`, btns);
    }

    function pickPlayerRevivalLaneModal(title, text, eligible, onPick) {
      const btns = eligible.map(i => ({
        text: `Lane #${i + 1}`,
        action: () => onPick(i)
      }));
      btns.push({
        text: 'Cancel',
        action: () => {
          blackjackMatch.actionSelectionInProgress = false;
          closeModal();
          renderAll();
        }
      });

      showModal(title, `<p class="modal-text">${text}</p>`, btns);
    }

    // Eligible revival lanes: any "closed" = isOpen && isComplete (stood OR busted)
    function getEligibleRevivalLanes(m) {
      const eligible = [];
      for (let i = 0; i < 5; i++) {
        const p = m.playerPositions[i];
        if (p && p.isOpen && p.isComplete) eligible.push(i);
      }
      return eligible;
    }

    // Split Decision
    function activateSplitDecision() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      showModal('Split Decision', `
        <p class="modal-text">Choose a card to play. The other card will be played by the Dealer immediately after your placement.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSplitDecision(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSplitDecision(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        { text: 'Cancel', action: () => { blackjackMatch.actionSelectionInProgress = false; closeModal(); renderAll(); } }
      ]);

      window.chooseSplitDecision = function(choiceIdx) {
        const playerCard = choiceIdx === 0 ? a : b;
        const dealerCard = choiceIdx === 0 ? b : a;

        blackjackMatch.drawnCard = playerCard;
        blackjackMatch.pending = { type: 'splitDecision', dealerGiftCard: dealerCard };

        markActionUsed('splitDecision');
        closeModal();
        renderAll();
        showToast('Place your chosen card');
      };
    }

    // Second Opinion
    function activateSecondOpinion() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      showModal('Second Opinion', `
        <p class="modal-text">Choose a card to play. The other will be discarded.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSecondOpinion(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSecondOpinion(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        { text: 'Cancel', action: () => { blackjackMatch.actionSelectionInProgress = false; closeModal(); renderAll(); } }
      ]);

      window.chooseSecondOpinion = function(choiceIdx) {
        const chosen = choiceIdx === 0 ? a : b;
        blackjackMatch.drawnCard = chosen;

        markActionUsed('secondOpinion');
        closeModal();
        renderAll();
        showToast('Place your chosen card');
      };
    }

    // Benched (ends turn)
    function activateBenched() {
      const c = drawPlayableToHandOrBench();
      if (!c) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }
      benchPush(c, 'action-benched');

      markActionUsed('benched');
      closeModal();
      renderAll();
      showToast(`Benched ${cardToString(c)}`);
      endPlayerTurn();
    }

    // Spy Network
    function activateSpyGlass() {
      for (let i = 0; i < 5; i++) blackjackMatch.spyReveals.add(i);
      markActionUsed('spyGlass');
      closeModal();
      renderAll();
      showToast('Revealed all Dealer lanes');
    }

    // Forced Play
    function activateForcedPlay() {
      pickDealerLaneModal('Forced Play', 'Choose a Dealer lane. The Dealer\'s next placed card must go there if still valid.', (idx) => {
        blackjackMatch.dealerForcedLane = idx;
        markActionUsed('forcedPlay');
        closeModal();
        renderAll();
        showToast(`Forced next Dealer play into lane #${idx + 1}`);
      });
    }

    // Revival
    function activateRevival() {
      const eligible = getEligibleRevivalLanes(blackjackMatch);
      pickPlayerRevivalLaneModal(
        'Revival',
        'Choose any of your closed lanes (stood or busted) to reopen.',
        eligible,
        (idx) => {
          const pos = blackjackMatch.playerPositions[idx];
          pos.isComplete = false;
          pos.isBust = false;
          markActionUsed('revival');
          closeModal();
          renderAll();
          showToast(`Reopened lane #${idx + 1}`);
        }
      );
    }

    // Find My Card (ends turn)
    function activateFindMyCard() {
      const pile = blackjackMatch.playerDrawPile;
      const scanN = Math.min(10, pile.length);
      let foundIndexFromEnd = -1;

      for (let k = 0; k < scanN; k++) {
        const idx = pile.length - 1 - k;
        const c = pile[idx];
        if (isModifier(c)) { foundIndexFromEnd = idx; break; }
      }

      if (foundIndexFromEnd >= 0) {
        const mod = pile.splice(foundIndexFromEnd, 1)[0];
        benchPush(mod, 'action-findMyCard');
        blackjackMatch.metrics.modifiersBenched += 1;
        showToast(`Found ${cardToString(mod)} (benched)`);
      } else {
        showToast('No modifier found');
      }

      markActionUsed('findMyCard');
      closeModal();
      renderAll();
      endPlayerTurn();
    }

    // Closer
    function activateCloser() {
      pickDealerLaneModal('Closer', 'Choose a Dealer lane to close immediately.', (idx) => {
        const pos = blackjackMatch.dealerPositions[idx];
        pos.isComplete = true;
        pos.isBust = getPositionTotal(pos) > 21;
        blackjackMatch.metrics.dealerStands += 1;

        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, makeStandardDeck52(), 'dealer');

        markActionUsed('closer');
        closeModal();
        renderAll();
        showToast(`Closed Dealer lane #${idx + 1}`);
      });
    }

    function shouldStartWatcher() {
      const keyCount = (run.playerDeck || []).filter(isKeyCard).length;
      const callingRank = run.callingCard ? rankToValue(run.callingCard.rank) : 0;
      return keyCount >= 3 && callingRank >= 10;
    }

    function startWatcherEncounter() {
      showModal('A New Opponent', `
        <p class="modal-text">"I've been watching. Your progress is... impressive."</p>
      `, [{
        text: 'Face The Watcher',
        primary: true,
        action: () => {
          closeModal();
          const watcherCard = run.callingCard ? { ...run.callingCard } : { rank: 'A', suit: '♠' };
          startBlackjackMatch('WATCHER', 0, {
            npcOverride: { name: 'The Watcher', callingCard: watcherCard },
            dealerDeckOverride: cloneDeck(run.playerDeck),
            enableTargeting: true
          });
          blackjackMatch.watcherTargetLaneIdx = null;
          updateThreatTargetLane(true, 'watcher_start');
          logEvent('WATCHER_START', { deckSize: run.playerDeck.length });
        }
      }]);
    }

    // =============================================
    // CONTINUE / END CONDITIONS
    // =============================================
    window.blackjackContinue = function() {
      clearDealerTimers();

      if (blackjackMatch.rewardPending) {
        showToast('Resolve winner reward first');
        return;
      }

      const result = blackjackMatch.result;

      if (blackjackMatch.type === 'WATCHER') {
        const win = result && result.outcome === 'WIN';
        logEvent(win ? 'WATCHER_CLEARED' : 'WATCHER_FAILED', { floor: run.floor });

        blackjackMatch = null;

        if (win) victory();
        else gameOver('You were outplayed by The Watcher.');

        return;
      }

      if (blackjackMatch.type === 'BOSS' && run.bossFight && run.bossFight.active) {
        const bf = run.bossFight;
        if (bf.hp <= 0) {
          logEvent('BOSS_FIGHT_DEFEATED', { floor: run.floor, round: bf.round, maxRounds: bf.maxRounds });
          run.bossWins = safeNumber(run.bossWins, 0) + 1;
          run.bossFight = null;
          logEvent('BOSS_CLEARED', { floor: run.floor, bossWins: run.bossWins, benchCapacity: getBenchCapacity() });
          showToast(`Boss cleared. Bench capacity is now ${getBenchCapacity()}.`);
          if (run.floor < 3) {
            blackjackMatch = null;
            initFloor(run.floor + 1);
            showToast(`Floor ${run.floor} begins!`);
          } else {
            blackjackMatch = null;
            if (shouldStartWatcher()) startWatcherEncounter();
            else victory();
          }
          return;
        }

        bf.benchCarry = (blackjackMatch.bench || []).slice();
        bf.roundsRemaining = Math.max(0, safeNumber(bf.roundsRemaining, bf.maxRounds) - 1);
        if (bf.roundsRemaining <= 0 && bf.hp > 0) {
          gameOver("Time expired before boss HP was depleted.");
          return;
        }
        if (bf.round < bf.maxRounds) {
          startBossRound(bf.round + 1);
          renderAll();
        } else {
          logEvent('BOSS_FIGHT_FAILED', { floor: run.floor, round: bf.round, maxRounds: bf.maxRounds, hp: bf.hp });
          gameOver("The boss withstands the assault.");
        }
        return;
      }

      if (blackjackMatch.type === 'BOSS') {
        if (result.outcome === 'WIN') {
          run.bossWins = safeNumber(run.bossWins, 0) + 1;
          logEvent('BOSS_CLEARED', { floor: run.floor, bossWins: run.bossWins, benchCapacity: getBenchCapacity() });
          showToast(`Boss cleared. Bench capacity is now ${getBenchCapacity()}.`);
          if (run.floor < 3) {
            blackjackMatch = null;
            initFloor(run.floor + 1);
            showToast(`Floor ${run.floor} begins!`);
          } else {
            blackjackMatch = null;
            if (shouldStartWatcher()) startWatcherEncounter();
            else victory();
          }
        } else {
          gameOver("You lost to the boss.");
        }
      } else {
        blackjackMatch = null;
        run.ui.mode = 'BOARD';
        renderAll();
      }
    };

    function gameOver(message) {
      clearDealerTimers();
      run.ui.mode = 'GAMEOVER';
      run.ui.message = message;
      logEvent('GAME_END', { result: 'GAMEOVER', message });
      finalizeRunLog({ outcome: 'loss', message });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    function victory() {
      clearDealerTimers();
      run.ui.mode = 'VICTORY';
      logEvent('GAME_END', { result: 'VICTORY' });
      finalizeRunLog({ outcome: 'win', message: null });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    // =============================================
    // UI RENDERING
    // =============================================
    function getHudTokensValue(){
      if (blackjackMatch && blackjackMatch.phase === 'playing') {
        const total = safeNumber(blackjackMatch.tokensTotal, 0);
        const spent = safeNumber(blackjackMatch.tokensSpent, 0);
        return Math.max(0, total - spent);
      }
      return safeNumber(run && run.bankedTokens, 0);
    }

    function syncHudOffset(){
      const hud = document.getElementById('hud');
      if (!hud) return;
      const h = hud.offsetHeight || 70;
      document.documentElement.style.setProperty('--hud-offset', `${h}px`);
    }

    window.toggleHud = function(){
      if (!run || !run.ui) return;
      run.ui.hudCollapsed = !run.ui.hudCollapsed;
      renderHUD();
      requestAnimationFrame(syncHudOffset);
    };

    window.addEventListener('resize', () => {
      if (run && run.ui && window.innerWidth <= 520) run.ui.hudCollapsed = true;
      syncHudOffset();
    });

    function renderAll() {
      renderHUD();
      renderBoard();
      renderBlackjack();
      renderEndScreen();
    }

    function renderHUD() {
      const hud = document.getElementById('hud');
      const chips = safeNumber(run.chips, 0);
      const loanStatus = run.loan.active ? (run.loan.repaid ? 'Repaid' : `Owed: ${LOAN_REPAY}`) : 'None';
      const canRepay = run.loan.active && !run.loan.repaid && chips >= LOAN_REPAY;
      const rankInfo = getCallingRankInfo();
      const pulseClass = (run.ui && safeNumber(run.ui.callingRankPulseUntil, 0) > Date.now()) ? 'calling-rank-pulse' : '';
      const callingText = run.callingCard ? `${run.callingCard.rank}${run.callingCard.suit}` : '—';
      const rankLine = rankInfo
        ? (rankInfo.isMax ? `Rank ${rankInfo.rank} · MAX` : `Rank ${rankInfo.current.rank} → ${rankInfo.next.rank}`)
        : 'Rank —';
      const toNext = rankInfo ? (rankInfo.isMax ? 'Max rank reached' : `${rankInfo.toNext} karma to next rank`) : '';
      const prog = rankInfo ? Math.round(rankInfo.progress * 100) : 0;
      const collapsed = !!(run.ui && run.ui.hudCollapsed);
      const debtWarning = (run.loan.active && !run.loan.repaid)
        ? '<span class="hud-stat-label" style="color:var(--accent-red);">Debt!</span>'
        : '';

      hud.classList.toggle('hud-collapsed', collapsed);

      hud.innerHTML = `
        <div class="hud-primary">
          <div class="hud-primary-left">
            <div class="hud-stat">
              <span class="hud-stat-label">Floor</span>
              <span class="hud-stat-value">${run.floor}/3</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Chips</span>
              <span class="hud-stat-value chips">${chips}</span>
              ${debtWarning}
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Karma</span>
              <span class="hud-stat-value karma">${safeNumber(run.karma, 0)}</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Tokens</span>
              <span class="hud-stat-value tokens">${getHudTokensValue()}</span>
            </div>
          </div>

          <div class="hud-primary-right">
            <button class="hud-icon-btn" title="Home" onclick="showStartScreen()">🏠</button>
            <button class="hud-icon-btn" title="Deck Viewer" onclick="openDeckViewer()">🃏</button>
            <button class="hud-icon-btn" title="Rules" onclick="openRulesPanel()">📖</button>
            <button class="hud-icon-btn" title="${collapsed ? 'Expand HUD' : 'Collapse HUD'}" onclick="toggleHud()">${collapsed ? '▾' : '▴'}</button>
          </div>
        </div>

        <div class="hud-secondary">
          <div class="hud-left">
            <div class="hud-stat">
              <span class="hud-stat-label">Player</span>
              <span class="hud-stat-value">${escapeHtml(run.playerName || '—')}</span>
            </div>
            <div class="hud-bank">
              <div class="hud-stat-label">Bank</div>
              <div class="hud-bank-main">Chips ${chips}</div>
              <div class="hud-bank-sub">Rake ${Math.round(getHouseRakeRate(run.floor) * 100)}% · Debt ${escapeHtml(loanStatus)}</div>
            </div>
            <div class="hud-calling ${pulseClass}">
              <div class="hud-calling-row">
                <span class="hud-stat-label">Calling Card</span>
                <span class="hud-calling-main">${callingText}</span>
              </div>
              <div class="hud-calling-row">
                <span class="hud-calling-sub">Karma ${safeNumber(run.karma, 0)}</span>
                <span class="hud-calling-sub">${rankLine}</span>
              </div>
              <div class="xpbar"><div class="xpbar-fill" style="width:${prog}%"></div></div>
              <div class="xpbar-text">${escapeHtml(toNext)}</div>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Deck</span>
              <span class="hud-stat-value">${run.playerDeck.length}</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Bench</span>
              <span class="hud-stat-value">${getBenchCapacity()}</span>
            </div>
          </div>

          <div class="hud-center">
            <button class="hud-icon-btn" title="Run Log" onclick="openLogPanel('stats')">📋</button>
            <button class="hud-icon-btn" title="Settings" onclick="openSettingsPanel()">⚙️</button>
            <button class="hud-icon-btn" title="Feedback" onclick="openFeedbackModal()">📝</button>
          </div>

          <div class="hud-right">
            ${run.loan.active && !run.loan.repaid ? `
              <button class="hud-btn success" ${canRepay ? '' : 'disabled'} onclick="repayLoan()">Repay ${LOAN_REPAY}</button>
            ` : ''}
            <button class="hud-btn danger" onclick="confirmReset()">Reset Run</button>
          </div>
        </div>
      `;

      requestAnimationFrame(syncHudOffset);
    }

    window.repayLoan = function() {
      const chips = safeNumber(run.chips);
      if (!run.loan.active || run.loan.repaid || chips < LOAN_REPAY) return;
      run.chips = chips - LOAN_REPAY;
      run.loan.repaid = true;
      logEvent('LOAN_REPAID', { amount: LOAN_REPAY });
      renderAll();
      showToast('Debt repaid!');
    };

    window.confirmReset = function() {
      showConfirmDialog('Are you sure you want to reset your run?', () => {
        clearPlayerName();
        initRun();
        showToast('New run started!');
      });
    };

    function renderBoard() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BOARD' && run.ui.mode !== 'INTRO') {
        boardView.classList.add('hidden');
        return;
      }

      boardView.classList.remove('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.add('hidden');

      if (run.ui.mode === 'INTRO') {
        renderIntro();
        return;
      }

      const available = getAvailableMoves();
      const isStarting = run.board.currentTileId === null;

      const instructions = isStarting
        ? 'Choose a starting tile from the bottom row'
        : 'Move to an available tile (gold outline)';

      let svg = `<svg id="boardSvg" viewBox="0 0 400 460" width="400" height="460">`;

      if (run.board.path.length > 1) {
        const pathPoints = run.board.path.map(id => run.board.tiles[id].center.join(',')).join(' ');
        svg += `<polyline class="path-line" points="${pathPoints}"/>`;
      }

      for (const tile of run.board.tiles) {
        const isVisited = run.board.visited.has(tile.id);
        const isCurrent = run.board.currentTileId === tile.id;
        const isAvailable = available.includes(tile.id);

        let tileClass = 'hex-tile';
        if (isVisited) tileClass += ' visited';
        if (isCurrent) tileClass += ' current';
        if (isAvailable) tileClass += ' available';
        if (run.secret && run.secret.keys && run.secret.keys.highStakes.hinted
          && !run.secret.keys.highStakes.obtained
          && tile.id === run.secret.keys.highStakes.tileId) tileClass += ' key-roller';

        const clickHandler = isAvailable ? `onclick="onTileClick(${tile.id})"` : '';
        let subLabel = '';
        if (tile.npc && tile.npc.callingCard) {
          const calling = `${tile.npc.callingCard.rank}${tile.npc.callingCard.suit}`;
          const affinity = run.callingCard ? getAffinity(run.callingCard.suit, tile.npc.callingCard.suit) : null;
          const affIcon = affinity ? ` ${affinityIcon(affinity)}` : '';
          subLabel = `<text class="hex-sub" x="${tile.center[0]}" y="${tile.center[1] + 12}">${calling}${affIcon}</text>`;
        }

        svg += `
          <g class="${tileClass}" ${clickHandler}>
            <path class="hex-bg" d="${tile.svgPath}" fill="${tile.color}" stroke="#1a2436" stroke-width="2"/>
            <text class="hex-label" x="${tile.center[0]}" y="${tile.center[1]}">${tile.label}</text>
            ${subLabel}
          </g>
        `;
      }

      svg += '</svg>';

      boardView.innerHTML = `
        <div class="board-instructions">${instructions}</div>
        ${svg}
      `;
    }

    function renderIntro() {
      const boardView = document.getElementById('boardView');
      const step = run.intro?.step || 'name';
      const name = run.intro?.name || '';

      const suitDescriptions = {
        '♥': 'Hearts — Triage: When a Calling Proc triggers, any newly busted lane can discard its last card.',
        '♠': 'Spades — Spyglass: Calling Proc reveals one dealer lane’s hidden total for the match.',
        '♦': 'Diamonds — Dividend: Calling Proc grants +26 chips (scaled by proc multiplier).',
        '♣': 'Clubs — Pressure: Calling Proc lets you apply +1 or -1 to a dealer lane total.'
      };

      let body = '';
      if (step === 'name') {
        body = `
          <div class="intro-panel">
            <div class="intro-title">Project 63: The Tower</div>
            <div class="intro-text">
              A casino with no address. A ledger that records more than debt. Each floor is a story — each table a test.
            </div>
            <div class="intro-text">Declare your name, choose your Calling Card, and step inside.</div>
            <input class="intro-input" id="introNameInput" placeholder="Enter your name" value="${escapeHtml(name)}"/>
            <div class="intro-actions">
              <button class="modal-btn" onclick="introRandomName()">Random Name</button>
              <button class="modal-btn success" onclick="introSetName()">Continue</button>
            </div>
          </div>
        `;
      } else if (step === 'suit') {
        body = `
          <div class="intro-panel">
            <div class="intro-title">Choose Your Calling Suit</div>
            <div class="intro-text">Each suit shapes your Calling Proc.</div>
            <div class="intro-suits">
              ${['♥','♠','♦','♣'].map(suit => `
                <button class="modal-btn intro-suit-btn" onclick="introChooseSuit('${suit}')">
                  <div style="font-weight:800; font-size:16px;">${suit}</div>
                  <div style="color:var(--text-secondary); font-size:12px; margin-top:4px;">${suitDescriptions[suit]}</div>
                </button>
              `).join('')}
            </div>
          </div>
        `;
      } else {
        const card = run.callingCard || run.intro?.callingCard;
        body = `
          <div class="intro-panel">
            <div class="intro-title">Your Calling Card</div>
            <div class="intro-text">Entering the Tower as ${escapeHtml(run.playerName || 'Unknown')}.</div>
            <div class="intro-large-card">${card ? renderCard(card, false, 'intro-large-card') : ''}</div>
            <div class="intro-actions">
              <button class="modal-btn success" onclick="introEnterTower()">Enter the Tower</button>
            </div>
          </div>
        `;
      }

      boardView.innerHTML = body;
    }

    window.introSetName = function() {
      const input = document.getElementById('introNameInput');
      const raw = input ? input.value : '';
      const cleaned = raw.trim();
      const name = cleaned || `Player ${Math.floor(Math.random() * 900 + 100)}`;
      run.playerName = name;
      run.intro.name = name;
      run.intro.step = 'suit';
      savePlayerName(name);
      if (gameLog && gameLog.player) gameLog.player.name = name;
      renderAll();
    };

    window.introRandomName = function() {
      const names = ['Nova', 'Jinx', 'Rook', 'Mara', 'Vega', 'Ash', 'Cy', 'Quinn', 'Sable', 'Riven'];
      const pick = names[Math.floor(Math.random() * names.length)];
      const input = document.getElementById('introNameInput');
      if (input) input.value = pick;
    };

    window.introChooseSuit = function(suit) {
      run.callingCard = { rank: '2', suit };
      run.callingCardChosenSuit = suit;
      run.intro.suit = suit;
      run.intro.callingCard = { ...run.callingCard };
      run.intro.step = 'reveal';
      renderAll();
    };

    window.introEnterTower = function() {
      logEvent('CALLING_CARD_SET', { callingCard: run.callingCard });
      logEvent('GAME_START', {
        startingChips: STARTING_CHIPS,
        deckSize: run.playerDeck.length,
        deckSnapshot: deckSnapshot(),
        settings: getSettingsSnapshot(),
        playerName: run.playerName || ''
      });
      if (gameLog) {
        gameLog.initialState = {
          chips: run.chips,
          karma: run.karma,
          floor: run.floor,
          callingCard: { ...run.callingCard },
          deckSnapshot: deckSnapshot()
        };
        if (gameLog.player) gameLog.player.name = run.playerName || '';
      }
      recordDeckSnapshot('GAME_START');
      run.ui.mode = 'BOARD';
      run.intro = null;
      initFloor(1);
    };

    window.onTileClick = function(tileId) {
      const available = getAvailableMoves();
      if (available.includes(tileId)) enterTile(tileId);
    };

    function renderCard(card, faceDown=false, extraClass='') {
      const cls = ['playing-card', extraClass, faceDown ? 'face-down' : cardCssClass(card)].filter(Boolean).join(' ');
      const text = faceDown ? '' : cardToString(card);
      const stampId = !faceDown ? getCardStampId(card) : null;
      const stampDef = stampId ? getStampDef(stampId) : null;
      const sleeveId = !faceDown && card ? card.sleeveId : null;
      const dataAttrs = [
        `data-card-label="${text}"`,
        `data-card-type="${isModifier(card) ? 'MOD' : (isFused(card) ? 'FUSE' : (isKeyCard(card) ? 'KEY' : 'STANDARD'))}"`,
        card && card.rank ? `data-card-rank="${card.rank}"` : '',
        card && card.suit ? `data-card-suit="${card.suit}"` : '',
        stampId ? `data-card-stamp="${stampId}"` : '',
        sleeveId ? `data-card-sleeve="${sleeveId}"` : '',
        card && card.uid !== undefined && card.uid !== null ? `data-card-uid="${card.uid}"` : ''
      ].filter(Boolean).join(' ');
      const stampIcon = (stampDef && stampDef.icon) ? `<div class="stamp-icon">${stampDef.icon}</div>` : '';
      return `<div class="${cls}" ${dataAttrs}>${text}${stampIcon}</div>`;
    }

    function setupCardTooltip() {
      const tooltip = document.getElementById('cardTooltip');
      if (!tooltip) return;

      let activeCard = null;
      let longPressTimer = null;

      const buildTooltipHtml = (cardEl) => {
        const ds = cardEl.dataset || {};
        const label = ds.cardLabel || 'Card';
        const type = ds.cardType || '';
        const stamp = ds.cardStamp ? getStampDef(ds.cardStamp) : null;
        const sleeve = ds.cardSleeve ? getSleeveDef(ds.cardSleeve) : null;
        const lines = [];

        if (type && type !== 'STANDARD') lines.push(`${type} card`);
        if (stamp) lines.push(`Stamp: ${stamp.name} — ${stamp.desc}`);
        if (sleeve) lines.push(`Sleeve: ${sleeve.name} — ${sleeve.desc}`);

        return `
          <div class="tooltip-title">${label}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (cardEl, x, y) => {
        if (!cardEl || !cardEl.dataset || !cardEl.dataset.cardLabel) return;
        tooltip.innerHTML = buildTooltipHtml(cardEl);
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeCard = cardEl;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeCard = null;
      };

      document.addEventListener('mouseover', (e) => {
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        showTooltip(cardEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (activeCard && !e.relatedTarget?.closest('.playing-card')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!activeCard) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        longPressTimer = setTimeout(() => showTooltip(cardEl, e.clientX, e.clientY), 450);
      });

      document.addEventListener('pointerup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('pointercancel', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.playing-card')) hideTooltip();
      });
    }

    function setupActionTooltip() {
      const tooltip = document.getElementById('actionTooltip');
      if (!tooltip) return;

      let activeChip = null;
      let longPressTimer = null;

      const buildTooltipHtml = (chipEl) => {
        const ds = chipEl.dataset || {};
        const title = ds.ttTitle || 'Action';
        const rawLines = ds.ttLines || '';
        const lines = rawLines ? rawLines.split('|').map(line => line.trim()).filter(Boolean) : [];
        return `
          <div class="tooltip-title">${title}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (chipEl, x, y) => {
        if (!chipEl) return;
        tooltip.innerHTML = buildTooltipHtml(chipEl);
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeChip = chipEl;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeChip = null;
      };

      document.addEventListener('mouseover', (e) => {
        const chipEl = e.target.closest('.action-chip');
        if (!chipEl) return;
        showTooltip(chipEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (activeChip && !e.relatedTarget?.closest('.action-chip')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!activeChip) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        const chipEl = e.target.closest('.action-chip');
        if (!chipEl) return;
        longPressTimer = setTimeout(() => showTooltip(chipEl, e.clientX, e.clientY), 450);
      });

      document.addEventListener('pointerup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('pointercancel', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.action-chip')) hideTooltip();
      });
    }

    function posState(pos) {
      if (!pos.isOpen) return 'closed';
      if (pos.isComplete) return pos.isBust ? 'bust' : 'stand';
      return 'open';
    }

    function stateBadge(state) {
      return `<div class="bj-state ${state}">${state}</div>`;
    }

    function renderPosition(pos, idx, side, isResolved, laneWinner) {
  const state = posState(pos);
  const total = getPositionTotal(pos);

  // Spy Network should always override visibility for that lane
  const spy = (side === 'dealer')
    && blackjackMatch
    && blackjackMatch.spyReveals
    && blackjackMatch.spyReveals.has(idx);
  const spadeReveal = (side === 'dealer')
    && blackjackMatch
    && blackjackMatch.spadePeekLanes
    && blackjackMatch.spadePeekLanes.has(idx);

  // NEW: totals + hole-card reveal behavior for dealer
  // - if revealTotalsOnClose: reveal when lane closes (stood/bust)
  // - else: reveal only when match resolves
  const revealTotalsOnClose = (uiSettings && uiSettings.revealTotalsOnClose) !== false;
  const showDealerTotal = spy || spadeReveal || isResolved || (revealTotalsOnClose && pos.isComplete);

  const showTotal = (side === 'player') ? true : showDealerTotal;
  const canReveal = (side === 'player') ? true : showDealerTotal;
  const totalText = showTotal ? `${total}` : '??';
  const totalBustVisual = canReveal && total > 21 ? 'bust' : '';

  // Hole card reveals when we reveal totals (or via spy, or on match resolve)
  const revealHole = (side === 'dealer') ? showDealerTotal : true;

  const displayState = (state === 'bust' && !canReveal) ? 'stand' : state;
  let cls = `bj-position ${displayState}`;
  if (blackjackMatch && blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active
    && blackjackMatch.scoreSeq.focusLane === idx
    && blackjackMatch.scoreSeq.focusSide === side) {
    cls += ' score-flash';
  }
  if (side === 'player' && run && run.bossFight && run.bossFight.active
    && run.bossFight.phase === 2 && run.bossFight.targetLaneIdx === idx) {
    cls += ' boss-target';
  }
  if (side === 'player' && blackjackMatch && blackjackMatch.type === 'WATCHER'
    && blackjackMatch.watcherTargetLaneIdx === idx) {
    cls += ' watcher-target';
  }
  if (displayState === 'open') cls += ' open';
  if (displayState === 'stand') cls += ' stand';
  if (displayState === 'bust') cls += ' bust';
  if (displayState === 'closed') cls += ' closed';

  if (isResolved) {
    if (laneWinner === side) cls += ' winner';
  }

  // NEW: Dealer cards: first card face-down unless revealed; others face-up
  const focusedUids = new Set((blackjackMatch && blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active && blackjackMatch.scoreSeq.focusLane === idx && blackjackMatch.scoreSeq.focusSide === side)
    ? (blackjackMatch.scoreSeq.focusCardUids || []) : []);
  const cardsHtml = (pos.cards || []).map((c, j) => {
    if (side === 'dealer') {
      const faceDown = (j === 0) && !revealHole;
      return renderCard(c, faceDown);
    }
    const popClass = focusedUids.has(c && c.uid) ? 'karma-pop' : '';
    return renderCard(c, false, popClass);
  }).join('');

  const mods = (pos.mods || []);
  const trapDelta = (!pos.isOpen && blackjackMatch && blackjackMatch.traps) ? blackjackMatch.traps[side][idx] : 0;
  const displayMods = mods.length ? mods : (trapDelta ? [trapDelta] : []);
  const modsText = displayMods.length ? displayMods.map(m => (m > 0 ? `+${m}` : `${m}`)).join(' ') : '';
  const modsLine = displayMods.length
    ? `<div class="bj-position-num" style="color: var(--accent-blue); font-weight:800;">MOD: ${modsText}</div>`
    : `<div class="bj-position-num">MOD: —</div>`;
  const f = blackjackMatch && blackjackMatch.scoreSeq ? blackjackMatch.scoreSeq.float : null;
  const floatHtml = (f && f.side === side && f.laneIdx === idx)
    ? `<div class="karma-float" data-float-id="${f.id}">${escapeHtml(f.text || '')}</div>`
    : '';

  return `
    <div class="${cls}" id="${side}_lane_${idx}">
      <div class="bj-position-num">${side.toUpperCase()} #${idx+1}</div>
      <div class="bj-cards">${cardsHtml}</div>
      <div class="bj-total ${totalBustVisual}">${totalText}</div>
      ${stateBadge(displayState)}
      ${modsLine}
      ${floatHtml}
      <div id="${side}_lane_actions_${idx}" style="display:flex; gap:6px; flex-wrap:wrap; justify-content:center;"></div>
    </div>
  `;
}


    function renderBlackjack() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BLACKJACK' || !blackjackMatch) {
        blackjackView.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.remove('hidden');
      endScreen.classList.add('hidden');

      const isResolved = blackjackMatch.phase === 'resolved';
      const result = blackjackMatch.result;
      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      const npc = blackjackMatch.npc;
      const affinity = blackjackMatch.affinity || 'neutral';
      const edgeDelta = blackjackMatch.edgeDelta || 0;
      const procPct = Math.round((blackjackMatch.callingProcChance || CALLING_PROC_CHANCE) * 100);
      const npcLine = npc
        ? `${npc.name} · ${cardToString(npc.callingCard)} · ${affinityIcon(affinity)} · Edge ${edgeDelta >= 0 ? '+' : ''}${edgeDelta} · Proc ${procPct}%`
        : `Dealer · Proc ${procPct}%`;

      const typeLabel = blackjackMatch.type === 'WATCHER' ? 'THE WATCHER' :
                        blackjackMatch.type === 'BOSS' ? 'BOSS BATTLE' :
                        blackjackMatch.type === 'HIGH_STAKES' ? 'HIGH STAKES' : 'STANDARD TABLE';

      const bossFight = run && run.bossFight;
      const isBossFight = blackjackMatch.type === 'BOSS' && bossFight && bossFight.active;
      const bossHpPct = isBossFight ? Math.max(0, Math.min(100, Math.round((bossFight.hp / bossFight.maxHp) * 100))) : 0;
      const bossPhaseClass = isBossFight && bossFight.phase === 2 ? 'boss-phase2' : '';
      const bossMeta = isBossFight ? `
        <div class="bj-status ${bossPhaseClass}">
          Round ${bossFight.round} / ${bossFight.maxRounds} · Time ${bossFight.roundsRemaining || 0} · HP ${bossFight.hp} / ${bossFight.maxHp}
          <div class="boss-hp ${bossPhaseClass}">
            <div class="boss-hp-fill" style="width:${bossHpPct}%"></div>
          </div>
        </div>
      ` : '';

      const watcherClass = blackjackMatch.type === 'WATCHER' ? ' watcher' : '';
      let html = `
        <div class="bj-header${watcherClass}">
          <div class="bj-title">${typeLabel}</div>
          <div class="bj-status">Buy-in: ${blackjackMatch.buyIn} chips · Side Bet x${transferMultiplier}</div>
          <div class="bj-status">${npcLine}</div>
          ${bossMeta}
        </div>
      `;
      if (blackjackMatch.procBanner) {
        html += `<div class="proc-banner"><div class="proc-banner-title">${escapeHtml(blackjackMatch.procBanner.suit || '')} ${escapeHtml(blackjackMatch.procBanner.title || 'Calling Proc')}</div><div class="proc-banner-desc">${escapeHtml(blackjackMatch.procBanner.desc || '')}</div></div>`;
      }

      // Dealer + Player positions
      const laneWinners = (isResolved && result) ? result.positionResults : ['push','push','push','push','push'];

      html += `
        <div class="bj-board ${(blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active) ? 'scoring-mode' : ''}">
          <div class="bj-side">
            <div class="bj-side-label">${npc ? `${npc.name} · ${cardToString(npc.callingCard)}` : 'Dealer'}</div>
            <div class="bj-positions">
              ${blackjackMatch.dealerPositions.map((p, i) => renderPosition(p, i, 'dealer', isResolved, laneWinners[i])).join('')}
            </div>
          </div>

          <div class="bj-side">
            <div class="bj-side-label">Player</div>
            <div class="bj-positions">
              ${blackjackMatch.playerPositions.map((p, i) => renderPosition(p, i, 'player', isResolved, laneWinners[i])).join('')}
            </div>
          </div>
        </div>
      `;

      // Controls / Result section
      if (isResolved && result) {
        const outcome = result.outcome;
        const titleCls = outcome === 'WIN' ? 'win' : (outcome === 'LOSS' ? 'lose' : 'tie');

        const transfer = blackjackMatch.transferChipsNet || 0;
        const bonus = blackjackMatch.bonusChipsEarned || 0;
        const payout = result.payout || 0;
        const rake = (result && result.rake) ? result.rake : 0;
        const rakeRate = (result && result.rakeRate) ? result.rakeRate : 0;

        const netFromEnd = payout + transfer - rake + bonus; // buy-in already paid earlier
        const netCls = netFromEnd > 0 ? 'positive' : (netFromEnd < 0 ? 'negative' : 'neutral');

        const rakeLine = rake > 0 ? ` · Rake: -${rake} (${Math.round(rakeRate * 100)}%)` : '';

        const rewardNote = blackjackMatch.rewardPending
          ? `<div class="bj-result-score" style="color:var(--accent-gold); font-weight:800;">Winner reward pending…</div>`
          : '';

        const exhaustionNote = result.exhaustion
          ? `<div class="bj-result-score" style="color:var(--accent-red); font-weight:800;">Deck exhaustion (${result.exhaustion.side})</div>`
          : '';

        const scoreSeq = blackjackMatch.scoreSeq;
        const earningsSeq = blackjackMatch.earningsSeq;
        const earningsNow = earningsSeq && earningsSeq.active ? earningsSeq.accrued : netFromEnd;
        const earningsLine = earningsSeq && earningsSeq.active
          ? `<div class="bj-result-score" style="color:var(--accent-blue); font-weight:800;">Earnings tally: ${escapeHtml(earningsSeq.message || '')}</div>`
          : '';
        const scoreLine = scoreSeq && scoreSeq.active
          ? `<div class="bj-result-score" style="color:var(--accent-blue); font-weight:800;">Karma tally: +${Math.max(0, scoreSeq.accrued)} / +${Math.max(0, scoreSeq.total)} · ${escapeHtml(scoreSeq.message || '')}</div>`
          : '';

        html += `
          <div class="bj-result">
            <div class="bj-result-title ${titleCls}">${outcome}</div>
            <div class="bj-result-score">
              Lanes: You ${result.playerWins} — Dealer ${result.dealerWins}<br/>
              Payout: ${payout} · Side Bet x${transferMultiplier}: ${transfer >= 0 ? '+' : ''}${transfer}${rakeLine} · Bonus: ${bonus}
            </div>
            <div class="bj-result-chips ${netCls}">
              Match Earnings: ${earningsNow >= 0 ? '+' : ''}${earningsNow}
            </div>
            ${rewardNote}
            ${exhaustionNote}
            ${earningsLine}
            <div class="bj-result-chips ${Math.max(0, (result.karmaGained || 0)) > 0 ? 'positive' : 'neutral'}">Karma Gained: +${Math.max(0, (scoreSeq && scoreSeq.active) ? scoreSeq.accrued : (result.karmaGained || 0))}</div>
            ${scoreLine}
            <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
              <button class="bj-btn" onclick="blackjackContinue()" ${blackjackMatch.rewardPending || isResolutionAnimationActive() ? 'disabled' : ''}>Continue</button>
              ${(scoreSeq && scoreSeq.active) ? '<button class="bj-btn" onclick="skipScoreSequence()">Skip Tally</button>' : ''}
            </div>
          </div>
        `;
      } else {
        if (blackjackMatch.phase === 'betting') {
          const stage = blackjackMatch.transferMultiplierStage;
          const min = blackjackMatch.transferMultiplierMin || 1;
          const max = blackjackMatch.transferMultiplierMax || 1;
          const options = Array.from({ length: max - min + 1 }, (_, i) => min + i);

          let betButtons = '';
          let betHint = '';

          if (stage === 'player') {
            betButtons = options.map(val => (
              `<button class="bj-btn" onclick="setTransferMultiplier(${val})">x${val}</button>`
            )).join('');
            betHint = 'Choose your side bet multiplier. Dealer can call or raise by +1.';
          } else if (stage === 'response' && blackjackMatch.transferRaiseOffer) {
            betButtons = `
              <button class="bj-btn success" onclick="acceptTransferRaise()">Accept x${blackjackMatch.transferRaiseOffer}</button>
              <button class="bj-btn danger" onclick="declineTransferRaise()">Decline</button>
            `;
            betHint = `Dealer raised side bet to x${blackjackMatch.transferRaiseOffer}. Accept or decline.`;
          } else {
            betButtons = `<button class="bj-btn" disabled>Waiting…</button>`;
            betHint = 'Dealer is deciding…';
          }

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">Side Bet Multiplier</div>
              <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
                <div class="bj-drawn-label">${betHint}</div>
              </div>
              <div class="bj-action-btns">
                ${betButtons}
              </div>
            </div>
          `;
        } else {
          const isPlayerTurn = blackjackMatch.turn === 'player';

          const drawn = blackjackMatch.drawnCard;
          const drawnHtml = drawn ? `
            <div class="bj-drawn-card">
              <div class="bj-drawn-label">Drawn:</div>
              ${renderCard(drawn, false)}
              <div class="bj-drawn-label" style="opacity:.9;">Place it into an open lane.</div>
            </div>
          ` : `
            <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
              <div class="bj-drawn-label">${isPlayerTurn ? 'No drawn card. Draw or use a bench card.' : 'Dealer is acting…'}</div>
            </div>
          `;

          // Action tokens UI
          const tokenTotal = blackjackMatch.tokensTotal || 0;
          const tokenSpent = blackjackMatch.tokensSpent || 0;
          const clickable = canClickToken();
          const owned = run.ownedActions || [];
          const canSpend = isPlayerTurn
            && blackjackMatch.phase === 'playing'
            && !blackjackMatch.actionUsedThisTurn
            && !blackjackMatch.actionSelectionInProgress
            && tokensRemaining() > 0;

          const tokensHtml = Array.from({ length: tokenTotal }, (_, i) => {
            const spent = i < tokenSpent;
            const locked = !spent && !clickable;
            const disabled = spent || (!clickable && !locked);
            const cls = spent ? 'token-icon spent' : (locked ? 'token-icon locked' : (disabled ? 'token-icon disabled' : 'token-icon'));
            const handler = (!spent && clickable) ? `onclick="onActionTokenClick()"` : '';
            return `<div class="${cls}" ${handler} title="${spent ? 'Spent' : (locked ? 'Locked' : (clickable ? 'Click to use an action token' : 'Unavailable'))}">${i+1}</div>`;
          }).join('');

          const actionsHtml = owned.length
            ? owned.map(id => {
              const def = ACTIONS[id];
              if (!def) return '';
              const already = blackjackMatch.usedActions && blackjackMatch.usedActions[id];
              const usable = !already && canSpend && (!def.isUsable || def.isUsable(blackjackMatch));
              const cls = already ? 'action-chip used' : (usable ? 'action-chip ready' : 'action-chip locked');
              const ttTitle = def.name;
              const ttLines = `${def.desc}|Costs 1 token · Once per match`;

              return `<button class="${cls}" ${usable ? `onclick="useActionFromBar('${id}')"` : 'disabled'}
                data-tt-title="${escapeHtml(ttTitle)}"
                data-tt-lines="${escapeHtml(ttLines)}">
                ${escapeHtml(def.name)} <span class="pill">1⚡</span>
              </button>`;
            }).join('')
            : `<div class="action-hint" style="padding:6px 2px;">No cocktails owned yet. Visit the Bartender.</div>`;

          // Bench UI
          const bench = blackjackMatch.bench || [];
          const armedIdx = blackjackMatch.armedBenchIdx;
          const armedCard = (armedIdx !== null && armedIdx !== undefined) ? bench[armedIdx] : null;
          const armedLabel = armedCard ? `Armed: ${cardToString(armedCard)}` : 'Arm a bench card';

          const benchHtml = `
            <div class="action-bar bench-bar">
              <div class="action-bar-title">Bench (${bench.length}/${getBenchCapacity()}) · ${armedLabel}</div>
              <div class="bench-cards">
                ${bench.length ? bench.map((c, i) => {
                  const ring = (armedIdx === i) ? 'bench-armed-ring' : '';
                  return `
                    <button class="bench-card-btn ${ring}" onclick="armBench(${i})" ${!isPlayerTurn ? 'disabled' : ''} title="Arm">
                      ${renderCard(c, false, 'bench')}
                    </button>
                  `;
                }).join('') : `<div class="action-hint" style="padding: 6px 2px;">Bench is empty.</div>`}
              </div>
              <div class="action-hint">
                ${armedCard
                  ? (isModifier(armedCard)
                    ? 'Armed modifier: apply to any open lane (player or dealer). Costs 1 token.'
                    : 'Armed card: place into any open player lane (ends your turn). Costs 1 token.')
                  : 'Modifiers drawn are benched automatically. Using the Bench costs 1 token.'}
              </div>
            </div>
          `;

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">${isPlayerTurn ? 'Your Turn' : 'Dealer Turn'}</div>

              ${drawnHtml}

              <div class="bj-action-btns">
                <button class="bj-btn" onclick="playerDrawCard()" ${(!isPlayerTurn || !!drawn || countOpenPositions(blackjackMatch.playerPositions) === 0) ? 'disabled' : ''}>Draw</button>
                <button class="bj-btn" onclick="playerEndTurn()" ${(!isPlayerTurn || !!drawn) ? 'disabled' : ''}>Close & End</button>
              </div>

              <div class="controls-row">
                <div class="action-bar">
                  <div class="action-bar-title">Tokens</div>
                  <div class="action-tokens">${tokensHtml || '<div class="action-hint">No tokens</div>'}</div>
                  <div class="action-hint">
                    Tokens power Bench plays and Cocktails.
                  </div>
                </div>
                <div class="action-bar">
                  <div class="action-bar-title">Actions</div>
                  <div class="action-chips">${actionsHtml}</div>
                  <div class="action-hint">Hover / long-press an action for details.</div>
                </div>
                ${benchHtml}
              </div>

              <div class="action-hint" style="max-width: 720px;">
                Tip: You can stand to close a lane immediately. Over-21 totals only bust at end of turn unless you close that lane.
              </div>
            </div>
          `;
        }
      }

      blackjackView.innerHTML = html;

      // After DOM is in, inject lane action buttons (keeps markup clean)
      injectLaneActionButtons();
    }

    function injectLaneActionButtons() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const isPlayerTurn = blackjackMatch.turn === 'player';
      const drawn = blackjackMatch.drawnCard;
      const benchTokenBlocked = !isPlayerTurn || blackjackMatch.actionUsedThisTurn || tokensRemaining() <= 0 || !!drawn;

      const bench = blackjackMatch.bench || [];
      const bi = blackjackMatch.armedBenchIdx;
      const armed = (bi !== null && bi !== undefined) ? bench[bi] : null;

      for (let i = 0; i < 5; i++) {
        const p = blackjackMatch.playerPositions[i];
        const d = blackjackMatch.dealerPositions[i];

        const pEl = document.getElementById(`player_lane_actions_${i}`);
        const dEl = document.getElementById(`dealer_lane_actions_${i}`);
        if (!pEl || !dEl) continue;

        // reset
        pEl.innerHTML = '';
        dEl.innerHTML = '';

        // PLAYER lane buttons
        if (isPlayerTurn && p.isOpen && !p.isComplete) {
          // place drawn card
          if (drawn) {
            const btn = document.createElement('button');
            btn.className = 'bj-btn place';
            btn.textContent = 'Place';
            btn.onclick = () => playerPlaceCard(i);
            pEl.appendChild(btn);
          } else {
            // stand
            const stand = document.createElement('button');
            stand.className = 'bj-btn stand-pos';
            stand.textContent = 'Stand';
            stand.onclick = () => playerStand(i);
            pEl.appendChild(stand);

            // bench placement/apply
            if (armed) {
              if (isModifier(armed)) {
                const apply = document.createElement('button');
                apply.className = 'bj-btn apply-mod';
                apply.textContent = 'Apply Mod';
                apply.disabled = benchTokenBlocked;
                apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
                apply.onclick = () => applyBenchTo('player', i);
                pEl.appendChild(apply);
              } else {
                const placeB = document.createElement('button');
                placeB.className = 'bj-btn place-bench';
                placeB.textContent = 'Place Bench';
                placeB.disabled = benchTokenBlocked;
                placeB.title = benchTokenBlocked ? 'Requires 1 token' : '';
                placeB.onclick = () => playerPlaceBenchCard(i);
                pEl.appendChild(placeB);
              }
            }
          }
        }

        // DEALER lane buttons (only bench modifier applies here)
        if (isPlayerTurn && !drawn && armed && isModifier(armed) && d.isOpen && !d.isComplete) {
          const apply = document.createElement('button');
          apply.className = 'bj-btn apply-mod';
          apply.textContent = 'Apply Mod';
          apply.disabled = benchTokenBlocked;
          apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
          apply.onclick = () => applyBenchTo('dealer', i);
          dEl.appendChild(apply);
        }
      }
    }

    function renderEndScreen() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'GAMEOVER' && run.ui.mode !== 'VICTORY') {
        endScreen.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.remove('hidden');

      const isVictory = run.ui.mode === 'VICTORY';
      const title = isVictory ? 'Victory' : 'Game Over';
      const titleCls = isVictory ? 'victory' : 'gameover';
      const msg = isVictory ? 'You cleared the tower.' : (run.ui.message || 'Your run has ended.');

      const events = (gameLog && gameLog.events) ? gameLog.events : [];
      const matches = events.filter(e => e && e.type === 'MATCH_END');
      const chipsSeries = matches.map(e => safeNumber(e.chips, 0));
      const karmaSeries = matches.map(e => safeNumber(e.ctx && e.ctx.karma, 0));
      const makeSpark = (vals, color) => {
        if (!vals.length) return '<svg class="sparkline" viewBox="0 0 300 120"></svg>';
        const min = Math.min(...vals), max = Math.max(...vals);
        const span = Math.max(1, max - min);
        const pts = vals.map((v, i) => `${(i/(Math.max(1, vals.length-1)))*300},${110-((v-min)/span)*100}`).join(' ');
        return `<svg class="sparkline" viewBox="0 0 300 120"><polyline points="${pts}" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/><line x1="0" y1="110" x2="300" y2="110" stroke="var(--border-color)"/></svg>`;
      };
      const summary = buildDeckSummary();
      const suitEntries = Object.entries(summary.bySuit || {}).filter(([k]) => ['♠','♥','♦','♣','★'].includes(k));
      const rankEntries = Object.entries(summary.byRank || {});
      const makeBars = (entries, color='var(--accent-blue)') => {
        const max = Math.max(1, ...entries.map(([,v]) => safeNumber(v,0)));
        return `<div class="bar-grid">${entries.map(([k,v]) => {
          const h = Math.round((safeNumber(v,0)/max)*84);
          return `<div class="bar-item"><div class="bar-col"><div class="bar-fill" style="height:${h}px; background:${color};"></div></div><div class="bar-label">${k} (${v})</div></div>`;
        }).join('')}</div>`;
      };

      endScreen.innerHTML = `
        <div class="end-screen">
          <div class="end-title ${titleCls}">${title}</div>
          <div class="end-message">${msg}</div>

          <div class="end-stats">
            <div class="end-stat">
              <div class="end-stat-value">${run.floor}</div>
              <div class="end-stat-label">Floor</div>
            </div>
            <div class="end-stat">
              <div class="end-stat-value">${safeNumber(run.chips)}</div>
              <div class="end-stat-label">Chips</div>
            </div>
            <div class="end-stat">
              <div class="end-stat-value">${run.playerDeck.length}</div>
              <div class="end-stat-label">Deck Size</div>
            </div>
            <div class="end-stat">
              <div class="end-stat-value">${safeNumber(run.karma)}</div>
              <div class="end-stat-label">Karma</div>
            </div>
          </div>

          <div class="end-chart-wrap">
            <div class="end-chart-card"><div class="end-chart-title">Chips Over Time</div>${makeSpark(chipsSeries, 'var(--accent-green)')}</div>
            <div class="end-chart-card"><div class="end-chart-title">Karma Over Time</div>${makeSpark(karmaSeries, 'var(--accent-purple)')}</div>
            <div class="end-chart-card"><div class="end-chart-title">Deck by Suit</div>${makeBars(suitEntries, 'var(--accent-gold)')}</div>
            <div class="end-chart-card"><div class="end-chart-title">Deck by Rank</div>${makeBars(rankEntries, 'var(--accent-blue)')}</div>
          </div>

          <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="bj-btn" onclick="openLogPanel('stats')">Open Run Log</button>
            <button class="bj-btn" onclick="openFeedbackModal()">Feedback</button>
            <button class="bj-btn" onclick="initRun()">New Run</button>
          </div>
        </div>
      `;
    }

    // =============================================
    // TILE RESOLUTION
    // =============================================
    function encounterBlackjackStandard() {
      if (run.chips < BUYIN_STANDARD) { gameOver("You can't afford the buy-in."); return; }
      startBlackjackMatch('STANDARD', BUYIN_STANDARD);
    }

    function encounterBlackjackHigh() {
      if (run.chips < BUYIN_HIGH) { gameOver("You can't afford the buy-in."); return; }
      const hsKey = run.secret && run.secret.keys ? run.secret.keys.highStakes : null;
      const specialReward = (run.floor === 1 && hsKey && !hsKey.obtained && run.board.currentTileId === hsKey.tileId) ? 'KEY_HIGH' : null;
      startBlackjackMatch('HIGH_STAKES', BUYIN_HIGH, { specialReward });
    }

    // =============================================
    // BOOT
    // =============================================
    (function boot() {
      // Try to keep last log available after refresh (doesn't overwrite current run)
      try {
        const saved = localStorage.getItem(LOG_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          if (parsed && parsed.sessionId && !gameLog) gameLog = parsed;
        }
      } catch (e) {}

      setupCardTooltip();
      setupActionTooltip();
      initStartPlasma();
      initRun();
      const c=document.getElementById('btnContinue'); if (c) c.onclick = () => { hideStartScreen(); renderAll(); };
      const n=document.getElementById('btnNewRun'); if (n) n.onclick = () => { initRun(); hideStartScreen(); };
      const r=document.getElementById('btnRules'); if (r) r.onclick = () => openRulesPanel();
      const st=document.getElementById('btnStats'); if (st) st.onclick = () => openLogPanel('stats');
      const se=document.getElementById('btnSettings'); if (se) se.onclick = () => openSettingsPanel();
      const fb=document.getElementById('btnFeedback'); if (fb) fb.onclick = () => openFeedbackModal();
      updateStartRunCard();
      showStartScreen();
      renderAll();
    })();
  </script>
</body>
</html>
