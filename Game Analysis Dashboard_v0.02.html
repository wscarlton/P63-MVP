<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project 63 — Run Analyzer (Single-File MVP+)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#121b2d;
      --panel2:#0f1728;
      --text:#e7eefc;
      --muted:#9cb0d4;
      --border:rgba(255,255,255,.10);
      --accent:#7dd3fc;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --chip:#1f2a44;
      --shadow: 0 12px 40px rgba(0,0,0,.40);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg, #071021 0%, #0b1220 60%, #071021 100%);
      color:var(--text); font-family:var(--sans);
    }
    header{
      padding:18px 16px;
      border-bottom:1px solid var(--border);
      background:rgba(10,16,30,.70);
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
    }
    .topbar{
      max-width:1200px; margin:0 auto;
      display:flex; gap:14px; align-items:center; justify-content:space-between;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .badge{
      width:34px; height:34px; border-radius:10px;
      background:radial-gradient(circle at 30% 30%, rgba(125,211,252,.9), rgba(59,130,246,.35) 60%, rgba(15,23,42,.6) 100%);
      border:1px solid rgba(255,255,255,.15);
      box-shadow: var(--shadow);
    }
    h1{font-size:15px; margin:0}
    .subtitle{font-size:12px; color:var(--muted); margin-top:2px}
    nav{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .tabbtn{
      border:1px solid var(--border);
      background:rgba(18,27,45,.65);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
      transition:transform .05s ease, background .15s ease;
    }
    .tabbtn:hover{background:rgba(31,42,68,.65)}
    .tabbtn:active{transform:translateY(1px)}
    .tabbtn.active{
      background:rgba(125,211,252,.14);
      border-color:rgba(125,211,252,.35);
    }

    main{max-width:1200px; margin:0 auto; padding:18px 16px 60px}
    .grid{ display:grid; gap:14px; }
    .cols2{grid-template-columns:repeat(2, minmax(0,1fr))}
    .cols3{grid-template-columns:repeat(3, minmax(0,1fr))}
    @media (max-width: 980px){
      .cols2,.cols3{grid-template-columns:1fr}
    }

    .card{
      background:rgba(18,27,45,.70);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      background:rgba(15,23,40,.45);
    }
    .cardTitle{font-size:13px; margin:0}
    .cardSub{font-size:12px; color:var(--muted); margin-top:4px}
    .cardBody{padding:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(31,42,68,.5);
      color:var(--text);
      font-size:12px;
    }
    .pill b{font-family:var(--mono); font-size:12px}
    .muted{color:var(--muted)}
    .btn{
      border:1px solid var(--border);
      background:rgba(31,42,68,.55);
      color:var(--text);
      padding:9px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
    }
    .btn:hover{background:rgba(31,42,68,.75)}
    .btn.danger{border-color:rgba(251,113,133,.35); background:rgba(251,113,133,.10)}
    .btn.danger:hover{background:rgba(251,113,133,.15)}
    .btn.primary{border-color:rgba(125,211,252,.35); background:rgba(125,211,252,.12)}
    .btn.primary:hover{background:rgba(125,211,252,.16)}
    .btn.small{padding:6px 8px; font-size:11px; border-radius:9px}
    input, select, textarea{
      width:100%;
      background:rgba(10,16,30,.6);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 10px;
      border-radius:10px;
      font-size:12px;
      outline:none;
    }
    textarea{min-height:90px; resize:vertical; font-family:var(--mono); font-size:11px}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    .field{display:flex; flex-direction:column; gap:6px}
    .split{ display:grid; grid-template-columns: 1.4fr .9fr; gap:14px; }
    @media (max-width:980px){.split{grid-template-columns:1fr}}
    .dropzone{
      border:1px dashed rgba(125,211,252,.35);
      background:rgba(125,211,252,.06);
      border-radius:var(--radius);
      padding:14px;
      text-align:center;
      color:var(--muted);
    }
    .dropzone.dragover{background:rgba(125,211,252,.12)}
    canvas{width:100%; height:260px; display:block; background:rgba(10,16,30,.25); border:1px solid var(--border); border-radius:12px}
    .tableWrap{overflow:auto; border-radius:12px; border:1px solid var(--border)}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.08); text-align:left; white-space:nowrap}
    th{background:rgba(15,23,40,.45); color:var(--muted); font-weight:600}
    tr:hover td{background:rgba(125,211,252,.06)}
    .kpiGrid{
      display:grid; grid-template-columns:repeat(6, minmax(0,1fr)); gap:10px;
    }
    @media (max-width:980px){.kpiGrid{grid-template-columns:repeat(2, minmax(0,1fr))}}
    .kpi{
      background:rgba(10,16,30,.35);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
    }
    .kpi .label{font-size:11px; color:var(--muted)}
    .kpi .value{font-size:14px; font-family:var(--mono); margin-top:6px}
    .hint{font-size:12px; color:var(--muted); line-height:1.45}
    .warnBox{
      border:1px solid rgba(251,191,36,.35);
      background:rgba(251,191,36,.10);
      border-radius:12px;
      padding:10px;
      color:rgba(255,255,255,.9);
      font-size:12px;
    }
    .goodBox{
      border:1px solid rgba(52,211,153,.35);
      background:rgba(52,211,153,.10);
      border-radius:12px;
      padding:10px;
      color:rgba(255,255,255,.9);
      font-size:12px;
    }
    .badBox{
      border:1px solid rgba(251,113,133,.35);
      background:rgba(251,113,133,.10);
      border-radius:12px;
      padding:10px;
      color:rgba(255,255,255,.9);
      font-size:12px;
    }

    dialog{
      border:none;
      border-radius:16px;
      background:rgba(18,27,45,.95);
      color:var(--text);
      width:min(760px, 92vw);
      box-shadow: var(--shadow);
      padding:0;
    }
    dialog::backdrop{background:rgba(0,0,0,.55)}
    .dlgHead{padding:14px 14px 10px; border-bottom:1px solid var(--border); background:rgba(15,23,40,.5)}
    .dlgBody{padding:14px}
    .dlgFoot{padding:12px 14px; border-top:1px solid var(--border); display:flex; justify-content:flex-end; gap:10px}
    .mono{font-family:var(--mono)}
    .tiny{font-size:11px}
    .divider{height:1px; background:rgba(255,255,255,.10); margin:10px 0;}
    .preBox{
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      padding: 10px;
      min-height: 180px;
      max-height: 420px;
      overflow: auto;
    }
  </style>
</head>
<body>
<header>
  <div class="topbar">
    <div class="brand">
      <div class="badge" aria-hidden="true"></div>
      <div>
        <h1>Project 63 — Run Analyzer</h1>
        <div class="subtitle">MVP+ • Run outcome • Per-floor rollups • Dual-axis deck chart • Compare runs</div>
      </div>
    </div>
    <nav>
      <button class="tabbtn active" data-tab="importTab">Import</button>
      <button class="tabbtn" data-tab="dashboardTab">Dashboard</button>
      <button class="tabbtn" data-tab="runsTab">Runs</button>
      <button class="tabbtn" data-tab="feedbackTab">Feedback</button>
      <button class="tabbtn" data-tab="configsTab">Configs</button>
      <button class="tabbtn" data-tab="settingsTab">Settings</button>
    </nav>
  </div>
</header>

<main>
  <!-- IMPORT -->
  <section id="importTab" class="tab">
    <div class="split">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Import Logs</div>
            <div class="cardSub">Drop JSON files or use the file picker. Tag + assign configs so runs are filterable.</div>
          </div>
        </div>
        <div class="cardBody">
          <div class="grid" style="gap:12px">
            <div class="dropzone" id="dropzone">
              <div style="font-size:13px; color:var(--text); margin-bottom:6px;">Drag & drop JSON logs here</div>
              <div class="tiny">or choose files below</div>
            </div>

            <div class="row">
              <input type="file" id="fileInput" accept=".json,application/json" multiple />
              <button class="btn primary" id="btnImport">Import Selected</button>
            </div>

            <div class="grid cols2">
              <div class="field">
                <label>Assign Config Profile</label>
                <select id="importConfigSelect"></select>
                <div class="tiny muted">Config profiles let you segment balance setups.</div>
              </div>
              <div class="field">
                <label>Tags (comma-separated)</label>
                <input id="importTags" placeholder="e.g., v0.9, merchantCap=5, bonus21=50" />
              </div>
            </div>

            <div class="grid cols2">
              <div class="field">
                <label>Notes (applied to all imported runs)</label>
                <input id="importNotes" placeholder="Quick context: what changed in this build?" />
              </div>
              <div class="field">
                <label>Storage Mode</label>
                <select id="importStorageMode">
                  <option value="full">Full Raw Log (bigger, best future analysis)</option>
                  <option value="summary">Summary Only (smaller, scalable)</option>
                </select>
                <div class="tiny muted">LocalStorage is limited. Summary-only helps scale.</div>
              </div>
            </div>

            <div class="warnBox tiny" id="importWarn" style="display:none"></div>

            <div>
              <div class="tiny muted">Recently imported:</div>
              <div id="importResults" class="tiny" style="margin-top:6px; line-height:1.5"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Quick Actions</div>
            <div class="cardSub">Export/import your analyzer DB, or clear local data.</div>
          </div>
        </div>
        <div class="cardBody">
          <div class="grid" style="gap:10px">
            <button class="btn" id="btnExportDB">Export DB (JSON)</button>
            <div class="row">
              <input type="file" id="dbImportInput" accept=".json,application/json" />
              <button class="btn" id="btnImportDB">Import DB</button>
            </div>
            <button class="btn danger" id="btnClearDB">Clear All Local Data</button>
            <div class="hint">
              Data is stored in <span class="mono">localStorage</span> on this device/browser only.
              Export regularly if you’re collecting lots of runs.
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- DASHBOARD -->
  <section id="dashboardTab" class="tab" style="display:none">
    <div class="card">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Run Dashboard</div>
          <div class="cardSub" id="dashSub">Select a run from Runs tab or after import.</div>
        </div>
        <div class="row">
          <button class="btn small" id="btnEditRun">Edit meta</button>
          <button class="btn small danger" id="btnDeleteRun">Delete run</button>
        </div>
      </div>
      <div class="cardBody">
        <div id="dashOverview"></div>
        <div class="divider"></div>
        <div id="dashHeader"></div>
        <details id="settingsSnapshot" style="margin-top:10px">
          <summary class="tiny muted" style="cursor:pointer">Settings Snapshot</summary>
          <div id="settingsSnapshotBody" class="hint" style="margin-top:8px"></div>
        </details>
        <div id="dashWarnings" style="margin-top:10px"></div>
      </div>
    </div>

    <div class="grid cols2" style="margin-top:14px">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Playstyle Fingerprint</div>
            <div class="cardSub">Radar + archetype classification with transparent drivers.</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartFingerprint"></canvas>
          <div id="fingerprintMeta" style="margin-top:10px"></div>
          <div id="fingerprintNotes" class="tiny muted" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Progression: Karma / Calling / Tokens</div>
            <div class="cardSub">Karma + calling rank + tokens at match start (chips overlay optional).</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartProgression"></canvas>
          <div class="tiny muted" id="progressionCaption" style="margin-top:8px"></div>
        </div>
      </div>
    </div>

    <!-- Per-floor summary -->
    <div class="card" style="margin-top:14px">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Per-Floor Summary</div>
          <div class="cardSub">Match + lane + economy + deck deltas by floor (this is your balance table).</div>
        </div>
        <div class="row">
          <button class="btn small" id="btnExportFloorCSV">Export Floor Summary CSV</button>
        </div>
      </div>
      <div class="cardBody">
        <div class="tableWrap">
          <table id="floorTable"></table>
        </div>
      </div>
    </div>

    <div class="grid cols2" style="margin-top:14px">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Chips Over Time</div>
            <div class="cardSub">Markers: Loan, Merchant, Boss match starts (if present).</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartChips"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Profit Per Match</div>
            <div class="cardSub">Profit = payout − buy-in + bonus + transfer.</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartProfit"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Deck Evolution</div>
            <div class="cardSub">Dual y-axis: Deck size (left) and Mod count (right).</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartDeck"></canvas>
          <div class="tiny muted" style="margin-top:8px">Solid: deckSize • Dashed: modCount</div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Deck Identity (End-of-run)</div>
            <div class="cardSub">Suit and rank distribution + modifier density.</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartDeckSuit"></canvas>
          <canvas id="chartDeckRank" style="margin-top:10px"></canvas>
          <div class="tiny muted" id="deckIdentityMeta" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Outcome Rates</div>
            <div class="cardSub" id="ratesSub">Segmented outcomes + bust/21. Toggle lane vs match outcomes.</div>
          </div>
          <div class="row">
            <select id="segmentMode" style="width:auto">
              <option value="tableType">By Table Type</option>
              <option value="floor">By Floor</option>
            </select>
            <select id="outcomeBasis" style="width:auto">
              <option value="lane">Lane outcomes</option>
              <option value="match">Match outcomes</option>
            </select>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartRates"></canvas>
          <div class="tiny muted" id="ratesCaption" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Totals Distribution</div>
            <div class="cardSub">Histogram of final totals (player vs dealer) across lanes.</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartTotals"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Economy Sinks</div>
            <div class="cardSub">Where chips are spent (largest negative deltas by category).</div>
          </div>
        </div>
        <div class="cardBody">
          <canvas id="chartSinks"></canvas>
        </div>
      </div>
    </div>

    <div class="grid cols2" style="margin-top:14px">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Insights</div>
            <div class="cardSub">Deterministic tuning notes (consistent across runs/configs).</div>
          </div>
        </div>
        <div class="cardBody">
          <div id="insightsBox"></div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Key Moments</div>
            <div class="cardSub">Notable swings, firsts, and boss outcomes.</div>
          </div>
        </div>
        <div class="cardBody">
          <div id="keyMomentsList" class="tiny"></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Drilldown Tables</div>
          <div class="cardSub">Spot-check correctness and edge cases quickly.</div>
        </div>
        <div class="row">
          <button class="btn small" id="btnExportMatchesCSV">Export Matches CSV</button>
          <button class="btn small" id="btnExportLanesCSV">Export Lanes CSV</button>
        </div>
      </div>
      <div class="cardBody">
        <details open>
          <summary class="tiny muted" style="cursor:pointer">Match table</summary>
          <div class="tableWrap" style="margin-top:10px">
            <table id="matchTable"></table>
          </div>
        </details>
        <details style="margin-top:10px">
          <summary class="tiny muted" style="cursor:pointer">Lane table</summary>
          <div class="tableWrap" style="margin-top:10px">
            <table id="laneTable"></table>
          </div>
        </details>
      </div>
    </div>
  </section>

  <!-- RUNS -->
  <section id="runsTab" class="tab" style="display:none">
    <div class="card">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Run Library</div>
          <div class="cardSub">Filter by config/tags. Open a run, or compare two runs.</div>
        </div>
      </div>
      <div class="cardBody">
        <div class="grid cols3">
          <div class="field">
            <label>Config</label>
            <select id="filterConfig"></select>
          </div>
          <div class="field">
            <label>Tag contains</label>
            <input id="filterTag" placeholder="e.g., merchantRemoveCost" />
          </div>
          <div class="field">
            <label>Search (notes / filename / session)</label>
            <input id="filterSearch" placeholder="type to filter..." />
          </div>
          <div class="field">
            <label>Archetype</label>
            <select id="filterArchetype">
              <option value="all">All archetypes</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px; justify-content:space-between">
          <div class="tiny muted" id="runsCount"></div>
          <div class="row">
            <button class="btn small" id="btnRecomputeAll">Recompute summaries</button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="grid cols2">
          <div class="card" style="background:rgba(10,16,30,.25); box-shadow:none">
            <div class="cardHeader">
              <div>
                <div class="cardTitle">Compare Runs</div>
                <div class="cardSub">Pick A and B to see KPI deltas (fast balance iteration).</div>
              </div>
            </div>
            <div class="cardBody">
              <div class="grid cols2">
                <div class="field">
                  <label>Run A</label>
                  <select id="cmpA"></select>
                </div>
                <div class="field">
                  <label>Run B</label>
                  <select id="cmpB"></select>
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <button class="btn primary" id="btnCompare">Compare</button>
                <button class="btn" id="btnSwapCompare">Swap</button>
              </div>
              <div id="compareOut" style="margin-top:10px"></div>
            </div>
          </div>

          <div class="hint">
            <b>Tip:</b> configs are your experimental “buckets.” When you tweak merchant pricing, bonus rules, boss rules, etc.,
            create a new config profile and assign runs to it. Then compare runs within the same bucket to isolate variance.
          </div>
        </div>

        <div class="tableWrap" style="margin-top:12px">
          <table id="runsTable"></table>
        </div>
      </div>
    </div>
  </section>

  <!-- FEEDBACK -->
  <section id="feedbackTab" class="tab" style="display:none">
    <div class="card">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Feedback</div>
          <div class="cardSub">Comments and bug notes captured during playtests. Export includes all runs.</div>
        </div>
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <input id="fbSearch" placeholder="Search runId, file, tags, notes, comments, bugs…" style="min-width:320px" />
          <label class="tiny" style="display:flex; align-items:center; gap:6px">
            <input type="checkbox" id="fbOnlyWithText" checked />
            Only runs with feedback
          </label>
          <button class="btn small primary" id="btnExportFeedbackCSV">Export Feedback CSV</button>
        </div>
      </div>

      <div class="cardBody">
        <div class="tiny muted" id="fbSummary" style="margin-bottom:10px"></div>
        <div class="tableWrap">
          <table id="feedbackTable"></table>
        </div>
        <div class="tiny muted" id="fbWarn" style="margin-top:10px; display:none"></div>
      </div>
    </div>
  </section>


  <!-- CONFIGS -->
  <section id="configsTab" class="tab" style="display:none">
    <div class="split">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Config Profiles</div>
            <div class="cardSub">Name balance setups and store key settings for filtering.</div>
          </div>
          <button class="btn small primary" id="btnNewConfig">New Config</button>
        </div>
        <div class="cardBody">
          <div class="tableWrap">
            <table id="configsTable"></table>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Config Editor</div>
            <div class="cardSub">Simple key/value object (no schema enforcement in MVP).</div>
          </div>
        </div>
        <div class="cardBody">
          <div class="grid" style="gap:10px">
            <div class="field">
              <label>Name</label>
              <input id="cfgName" placeholder="e.g., v0.9 baseline" />
            </div>
            <div class="field">
              <label>Fields (JSON object)</label>
              <textarea id="cfgFields" placeholder='{"bonus21Amount":50,"merchantRemoveCost":50}'></textarea>
              <div class="tiny muted">Keep this small and stable so filters stay meaningful.</div>
            </div>
            <div class="row">
              <button class="btn primary" id="btnSaveConfig">Save Config</button>
              <button class="btn danger" id="btnDeleteConfig">Delete Config</button>
              <div class="tiny muted" id="cfgEditorHint"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SETTINGS -->
  <section id="settingsTab" class="tab" style="display:none">
    <div class="card">
      <div class="cardHeader">
        <div>
          <div class="cardTitle">Insight Thresholds</div>
          <div class="cardSub">Tune the analyzer’s deterministic messages without changing code.</div>
        </div>
      </div>
      <div class="cardBody">
        <div class="grid cols3">
          <div class="field">
            <label>Bonus dominance threshold</label>
            <input id="setBonusDom" type="number" step="0.01" min="0" max="1" />
            <div class="tiny muted">bonusTotal / matchProfitTotal (e.g., 0.25)</div>
          </div>
          <div class="field">
            <label>Merchant dominance threshold</label>
            <input id="setMerchantDom" type="number" step="0.01" min="0" max="1" />
            <div class="tiny muted">merchantSpend / totalSpend (e.g., 0.60)</div>
          </div>
          <div class="field">
            <label>Solved-state 21 rate</label>
            <input id="setSolved21" type="number" step="0.01" min="0" max="1" />
            <div class="tiny muted">e.g., 0.45</div>
          </div>
          <div class="field">
            <label>Solved-state bust rate</label>
            <input id="setSolvedBust" type="number" step="0.01" min="0" max="1" />
            <div class="tiny muted">e.g., 0.12</div>
          </div>
          <div class="field">
            <label>Early cliff risk (chipsLow fraction)</label>
            <input id="setCliffFrac" type="number" step="0.01" min="0" max="1" />
            <div class="tiny muted">chipsLow / startChips (e.g., 0.40)</div>
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="btnSaveSettings">Save Settings</button>
          <div class="tiny muted" id="settingsHint"></div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- Edit Run Modal -->
<dialog id="editRunDlg">
  <div class="dlgHead">
    <div class="cardTitle">Edit Run Meta</div>
    <div class="tiny muted">Tags/config/notes help segment balance experiments.</div>
  </div>
  <div class="dlgBody">
    <div class="grid cols2">
      <div class="field">
        <label>Config Profile</label>
        <select id="editRunConfig"></select>
      </div>
      <div class="field">
        <label>Tags (comma-separated)</label>
        <input id="editRunTags" />
      </div>
    </div>
    <div class="field" style="margin-top:10px">
      <label>Notes</label>
      <input id="editRunNotes" />
    </div>
    <div class="tiny muted" id="editRunInfo" style="margin-top:10px"></div>
  </div>
  <div class="dlgFoot">
    <button class="btn" id="btnCancelEditRun">Cancel</button>
    <button class="btn primary" id="btnSaveEditRun">Save</button>
  </div>
</dialog>

<dialog id="dlgFeedbackView" class="dlg">
  <div class="dlgHead">
    <div>
      <div class="dlgTitle" id="fbDlgTitle">Feedback</div>
      <div class="tiny muted" id="fbDlgMeta"></div>
    </div>
    <div class="row">
      <button class="btn small" id="btnCloseFeedbackDlg">Close</button>
    </div>
  </div>
  <div class="dlgBody">
    <div class="grid cols2" style="gap:12px">
      <div>
        <div class="tiny muted" style="margin-bottom:6px">Comments</div>
        <pre id="fbDlgComments" class="preBox"></pre>
      </div>
      <div>
        <div class="tiny muted" style="margin-bottom:6px">Bugs</div>
        <pre id="fbDlgBugs" class="preBox"></pre>
      </div>
    </div>
  </div>
</dialog>

<script>
/* =========================================================
   Project 63 Run Analyzer — Single-file MVP+
   ========================================================= */

const DB_KEY = "P63_ANALYZER_DB_V1";

const defaultSettings = {
  bonusDominance: 0.25,
  merchantDominance: 0.60,
  solved21Rate: 0.45,
  solvedBustRate: 0.12,
  earlyCliffFrac: 0.40
};

let DB = loadDB();
let currentRunId = null;
let currentConfigId = null;
const feedbackCache = {}; // runId -> feedback summary

function loadDB(){
  try{
    const raw = localStorage.getItem(DB_KEY);
    if(!raw){
      return {
        version: 1,
        runs: {},
        configs: {
          "cfg_default": {
            configId:"cfg_default",
            name:"(No config)",
            createdAtISO:new Date().toISOString(),
            fields:{}
          }
        },
        settings: {...defaultSettings}
      };
    }
    const obj = JSON.parse(raw);
    if(!obj.settings) obj.settings = {...defaultSettings};
    if(!obj.configs || Object.keys(obj.configs).length===0){
      obj.configs = {
        "cfg_default": {
          configId:"cfg_default",
          name:"(No config)",
          createdAtISO:new Date().toISOString(),
          fields:{}
        }
      };
    }
    return obj;
  }catch(e){
    console.warn("DB load failed, resetting", e);
    return {
      version:1,
      runs:{},
      configs:{
        "cfg_default": {
          configId:"cfg_default",
          name:"(No config)",
          createdAtISO:new Date().toISOString(),
          fields:{}
        }
      },
      settings:{...defaultSettings}
    };
  }
}
function saveDB(){
  localStorage.setItem(DB_KEY, JSON.stringify(DB));
}
function uid(prefix="id"){
  return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function fmt(n){
  if(n===null || n===undefined || Number.isNaN(n)) return "—";
  if(typeof n === "number"){
    return n.toLocaleString(undefined, {maximumFractionDigits:2});
  }
  return String(n);
}
function pct(x){
  if(x===null || x===undefined || Number.isNaN(x)) return "—";
  return (x*100).toFixed(1) + "%";
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function safeParseJSON(text){
  try{ return {ok:true, value: JSON.parse(text)}; }
  catch(e){ return {ok:false, error: e}; }
}
function toISO(ts){
  try{
    const d = new Date(ts);
    if(Number.isNaN(d.getTime())) return String(ts);
    return d.toISOString();
  }catch{ return String(ts); }
}
function normText(s){
  if(s===null || s===undefined) return "";
  return String(s).replace(/\r\n/g,"\n").trim();
}
function extractFeedbackSummary(log){
  const fb = log && typeof log==="object" ? (log.feedback || null) : null;
  const comments = normText(fb?.comments);
  const bugs = normText(fb?.bugs);
  const updatedAtISO = fb?.updatedAt ? toISO(fb.updatedAt) : null;

  const events = Array.isArray(log?.events) ? log.events : [];
  const fbEvents = events.filter(e=>e && e.type==="FEEDBACK_UPDATED");
  const updatesCount =
    (log?.stats && typeof log.stats.feedbackUpdates==="number") ? log.stats.feedbackUpdates :
    (fbEvents.length || null);

  let lastUpdateISO = null;
  if(fbEvents.length){
    const last = fbEvents.reduce((acc,e)=>{
      const t = new Date(e.ts||0).getTime();
      const a = new Date(acc.ts||0).getTime();
      return t>a ? e : acc;
    }, fbEvents[0]);
    lastUpdateISO = last?.ts ? toISO(last.ts) : null;
  }

  const hasText = !!(comments || bugs);

  return { comments, bugs, updatedAtISO, updatesCount, lastUpdateISO, hasText };
}
function escapeHTML(str){
  return String(str ?? "").replace(/[&<>"']/g, m=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}
function normalizeOutcome(o){
  if(o===null || o===undefined) return null;
  const s = String(o).toUpperCase();
  if(s==="WIN" || s.includes("PLAYER")) return "WIN";
  if(s==="LOSS" || s.includes("DEALER")) return "LOSS";
  if(s==="PUSH" || s==="TIE" || s.includes("PUSH")) return "PUSH";
  return s;
}
function num(x){ return (typeof x==="number" && !Number.isNaN(x)) ? x : 0; }
function numOrNull(x){ return (typeof x==="number" && !Number.isNaN(x)) ? x : null; }
function sum(arr){ return arr.reduce((a,b)=>a+num(b),0); }
function avg(arr){
  const vals = arr.filter(v=>typeof v==="number" && !Number.isNaN(v));
  if(!vals.length) return null;
  return vals.reduce((a,b)=>a+b,0)/vals.length;
}
function stddev(arr){
  const vals = arr.filter(v=>typeof v==="number" && !Number.isNaN(v));
  if(vals.length<2) return null;
  const m = vals.reduce((a,b)=>a+b,0)/vals.length;
  const v = vals.reduce((a,b)=>a+Math.pow(b-m,2),0)/(vals.length-1);
  return Math.sqrt(v);
}
function firstNonNull(arr){
  for(const v of arr){ if(v!==null && v!==undefined) return v; }
  return null;
}
function lastNonNull(arr){
  for(let i=arr.length-1;i>=0;i--){
    const v = arr[i];
    if(v!==null && v!==undefined) return v;
  }
  return null;
}
function maxNum(arr){
  const vals = arr.filter(v=>typeof v==="number" && !Number.isNaN(v));
  if(!vals.length) return null;
  return Math.max(...vals);
}

/* =========================
   Tabs
   ========================= */
document.querySelectorAll(".tabbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>setTab(btn.dataset.tab));
});
function setTab(tabId){
  document.querySelectorAll(".tab").forEach(t=>t.style.display="none");
  document.getElementById(tabId).style.display="block";
  document.querySelectorAll(".tabbtn").forEach(b=>b.classList.toggle("active", b.dataset.tab===tabId));
  if(tabId==="runsTab") renderRunsTable();
  if(tabId==="configsTab") renderConfigs();
  if(tabId==="settingsTab") renderSettings();
  if(tabId==="dashboardTab" && currentRunId) renderDashboard(currentRunId);
  if(tabId==="feedbackTab") renderFeedbackTab();
}

/* =========================
   Import handlers
   ========================= */
const fileInput = document.getElementById("fileInput");
const dropzone = document.getElementById("dropzone");
const importResults = document.getElementById("importResults");
const importWarn = document.getElementById("importWarn");

dropzone.addEventListener("dragover", (e)=>{
  e.preventDefault();
  dropzone.classList.add("dragover");
});
dropzone.addEventListener("dragleave", ()=> dropzone.classList.remove("dragover"));
dropzone.addEventListener("drop", (e)=>{
  e.preventDefault();
  dropzone.classList.remove("dragover");
  const files = [...e.dataTransfer.files].filter(f => f.name.toLowerCase().endsWith(".json"));
  if(files.length===0){
    showImportWarn("No .json files detected in drop.");
    return;
  }
  fileInput.files = makeFileList(files);
});
function makeFileList(files){
  const dt = new DataTransfer();
  files.forEach(f => dt.items.add(f));
  return dt.files;
}
document.getElementById("btnImport").addEventListener("click", async ()=>{
  const files = [...fileInput.files || []];
  if(!files.length){
    showImportWarn("Choose one or more JSON logs first.");
    return;
  }
  showImportWarn(null);
  importResults.textContent = "Importing...";
  const cfgId = document.getElementById("importConfigSelect").value || "cfg_default";
  const tags = (document.getElementById("importTags").value || "").split(",").map(s=>s.trim()).filter(Boolean);
  const notes = document.getElementById("importNotes").value || "";
  const storageMode = document.getElementById("importStorageMode").value;

  const results = [];
  for(const file of files){
    const text = await file.text();
    const parsed = safeParseJSON(text);
    if(!parsed.ok){
      results.push(`❌ ${file.name}: invalid JSON (${parsed.error.message})`);
      continue;
    }
    const log = parsed.value;
    const runId = deriveRunId(log, file.name);
    const analysis = analyzeLog(log);

    const meta = {
      runId,
      importedAtISO: new Date().toISOString(),
      sourceFilename: file.name,
      sessionId: log.sessionId ?? null,
      startedAtISO: log.startedAt ? toISO(log.startedAt) : (analysis.summary?.startedAtISO ?? null),
      logVersion: log.logVersion ?? null,
      tags: [...tags],
      configId: cfgId,
      notes: notes
    };

    const configSnapshot = DB.configs[cfgId]?.fields ? JSON.parse(JSON.stringify(DB.configs[cfgId].fields)) : {};

    const runRec = {
      meta,
      configSnapshot,
      summary: analysis.summary,
      derived: storageMode==="summary" ? analysis.derived : null,
      rawLog: storageMode==="full" ? text : null
    };

    DB.runs[runId] = runRec;
    results.push(`✅ ${file.name}: imported as ${runId}`);
    currentRunId = runId;
  }
  saveDB();
  refreshConfigSelects();
  renderRunsTable();
  if(currentRunId){
    setTab("dashboardTab");
    renderDashboard(currentRunId);
  }
  importResults.innerHTML = results.map(r=>`<div>${escapeHTML(r)}</div>`).join("");
});
function showImportWarn(msg){
  if(!msg){ importWarn.style.display="none"; importWarn.textContent=""; return; }
  importWarn.style.display="block";
  importWarn.textContent = msg;
}
function deriveRunId(log, filename){
  if(log.sessionId) return String(log.sessionId);
  if(log.startedAt) return "run_" + String(log.startedAt).replace(/[^0-9a-z]/gi,"").slice(0,24);
  const n = (log.events && Array.isArray(log.events)) ? log.events.length : 0;
  return "run_" + filename.replace(/[^0-9a-z]/gi,"").slice(0,24) + "_" + n;
}

/* =========================
   Analysis core
   ========================= */

function categorizeSink(type, row){
  const t = String(type||"").toUpperCase();
  if(t.includes("MERCHANT_REMOVE")) return "Merchant removals";
  if(t.includes("MERCHANT_BUY")) return "Merchant buys";
  if(t.includes("MERCHANT_REROLL")) return "Merchant rerolls";
  if(t.includes("COCKTAIL")) return "Cocktails";
  if(t.includes("LOAN")) return "Loans/interest";
  if(t.includes("COLLECTOR_BUY")) return "Collector";
  if(t.includes("MODIFY_SERVICE_SELECT") || t.includes("MODIFY_APPLY")) return "Modify";
  if(t.includes("AUCTION_BID")) return "Auctions";
  if(t.includes("REST")) return "Rest/Heals";
  if(t.includes("MATCH_START")) return "Buy-ins";
  if(t.includes("MATCH_END")){
    const rake = row?.data?.rake;
    if(typeof rake==="number" && row?.deltaChips<0) return "Rake/House";
  }
  if(t.includes("BUYIN")) return "Buy-ins";
  return "Other";
}
function aggregateSinks(sinks){
  const out = {};
  sinks.forEach(s=>{
    const cat = s.category || "Other";
    out[cat] = (out[cat]||0) + s.delta; // negative
  });
  Object.keys(out).forEach(k=>{
    if(Math.abs(out[k])<1e-9) delete out[k];
  });
  return out;
}
function inferTableTypeFromMatchStart(eventRows, matchIndex){
  if(!matchIndex) return null;
  const ms = eventRows.find(r=>r.type==="MATCH_START" && r.matchIndex===matchIndex);
  return ms?.data?.type ?? null;
}
function grabDeckSnapshot(d){
  if(!d || typeof d!=="object") return null;
  if(d.deckSnapshot && typeof d.deckSnapshot==="object") return d.deckSnapshot;
  return null;
}
function buildDeckTimeline(deckHistory){
  if(!Array.isArray(deckHistory) || !deckHistory.length) return [];
  return deckHistory.map((entry, idx)=>{
    const s = (entry && typeof entry.summary==="object") ? entry.summary : {};
    return {
      idx,
      ts: entry.ts ?? null,
      floor: entry.floor ?? null,
      chips: entry.chips ?? null,
      karma: entry.karma ?? null,
      callingRankValue: entry.callingRankValue ?? null,
      reason: entry.reason ?? null,
      deckSize: s.deckSize ?? entry.deckSize ?? null,
      modCount: s.modCount ?? entry.modCount ?? null,
      fusedCount: s.fusedCount ?? entry.fusedCount ?? null,
      sleevedCount: s.sleevedCount ?? entry.sleevedCount ?? null,
      bySuit: s.bySuit ?? null,
      byRank: s.byRank ?? null,
      stampsByRank: s.stampsByRank ?? null,
      summary: s
    };
  });
}
function findRunEnd(eventRows){
  // authoritative: last event matching an end-ish type
  for(let i=eventRows.length-1;i>=0;i--){
    const r = eventRows[i];
    const t = String(r.type||"").toUpperCase();
    if(/RUN_END|GAME_OVER|VICTORY|DEFEAT|RUN_OVER|END_RUN/.test(t)){
      const d = r.data||{};
      const result = normalizeOutcome(d.result || d.outcome || (t.includes("VICTORY")?"WIN":t.includes("DEFEAT")||t.includes("GAME_OVER")?"LOSS":null));
      return {
        source:"EVENT",
        eventType:r.type,
        result: result || (t.includes("VICTORY")?"WIN":t.includes("DEFEAT")||t.includes("GAME_OVER")?"LOSS":"UNKNOWN"),
        reason: d.reason || d.cause || null,
        floor: r.floor ?? null,
        chips: r.chips ?? null,
        tableType: d.tableType || d.type || null,
        matchIndex: d.matchIndex ?? r.matchIndex ?? null
      };
    }
  }
  return null;
}
function getRunOutcomeFromTopLevel(log){
  const ro = log?.runOutcome;
  if(!ro || typeof ro!=="object") return null;
  const result = normalizeOutcome(ro.result || ro.outcome || ro.status);
  if(!result) return null;
  return {
    source:"LOG",
    eventType: ro.eventType || ro.type || null,
    result,
    reason: ro.reason || ro.cause || null,
    floor: ro.floor ?? null,
    chips: ro.chips ?? null,
    tableType: ro.tableType || ro.tileType || ro.type || null,
    matchIndex: ro.matchSeq ?? ro.matchIndex ?? null,
    message: ro.message || null
  };
}
function inferRunOutcome(summary, matches){
  // fallback inference when no RUN_END
  const endChips = summary.endChips;
  const lastMatch = matches.length ? matches[matches.length-1] : null;
  const lastBoss = [...matches].reverse().find(m=>String(m.tableType||"").toUpperCase()==="BOSS") || null;

  if(typeof endChips==="number" && endChips<=0){
    return {source:"INFER", result:"LOSS", reason:"BANKRUPT", floor: summary.floorsReached ?? lastMatch?.floor ?? null, chips:endChips,
            tableType:lastMatch?.tableType??null, matchIndex:lastMatch?.matchIndex??null};
  }
  if(lastBoss && normalizeOutcome(lastBoss.outcome)==="LOSS"){
    return {source:"INFER", result:"LOSS", reason:"BOSS_DEFEAT", floor:lastBoss.floor??null, chips:endChips??null, tableType:lastBoss.tableType??"BOSS", matchIndex:lastBoss.matchIndex??null};
  }
  if(lastBoss && normalizeOutcome(lastBoss.outcome)==="WIN"){
    return {source:"INFER", result:"WIN", reason:"BOSS_CLEARED", floor:lastBoss.floor??null, chips:endChips??null, tableType:lastBoss.tableType??"BOSS", matchIndex:lastBoss.matchIndex??null};
  }
  // if last event suggests cashout/quit
  return {source:"INFER", result:"UNKNOWN", reason:null, floor: summary.floorsReached ?? lastMatch?.floor ?? null, chips:endChips??null, tableType:lastMatch?.tableType??null, matchIndex:lastMatch?.matchIndex??null};
}

function analyzeLog(log){
  const warnings = [];
  const events = Array.isArray(log.events) ? log.events : [];
  if(!events.length){
    return {
      summary: { warnings:["No events[] in log or empty."] },
      derived: { events:[], matches:[], lanes:[], deck:[], sinks:[], floorSummary:[] }
    };
  }

  // Build event rows: carry-forward chips state so deltas are coherent
  const eventRows = [];
  let prevChipsState = null;
  let sawChipsCount = 0;
  let missingChipsCount = 0;

  let chipsPeak = -Infinity;
  let chipsLow = Infinity;

  let t0 = null;
  let matchIndex = 0;
  let inMatch = false;

  let firstLoanEventId = null;
  let firstMerchantEnterId = null;
  let bossMatchStartIds = [];

  let biggestDrop = {delta: 0, type:null, floor:null, idx:null, eventId:null};

  for(let i=0;i<events.length;i++){
    const e = events[i] || {};
    const chipsRaw = (typeof e.chips === "number") ? e.chips : null;
    if(chipsRaw===null) missingChipsCount++; else sawChipsCount++;

    // carry forward last known chips
    const chipsState = (chipsRaw!==null) ? chipsRaw : prevChipsState;
    const delta = (prevChipsState===null || chipsState===null) ? 0 : (chipsState - prevChipsState);

    if(chipsState!==null){
      chipsPeak = Math.max(chipsPeak, chipsState);
      chipsLow = Math.min(chipsLow, chipsState);
    }

    if(delta < biggestDrop.delta){
      biggestDrop = {delta, type:e.type||"UNKNOWN", floor:e.floor??null, idx:i, eventId:e.id??i};
    }

    const ts = e.ts ?? null;
    const t = ts ? new Date(ts).getTime() : null;
    if(t0===null && t!==null) t0 = t;
    const t_s = (t0!==null && t!==null) ? (t - t0)/1000 : i;

    if(e.type==="MATCH_START"){ matchIndex += 1; inMatch = true; }
    if(e.type==="MATCH_END"){ /* included in match */ }

    const row = {
      idx: i,
      id: e.id ?? i,
      ts: e.ts ?? null,
      t_s,
      floor: e.floor ?? null,
      type: e.type ?? "UNKNOWN",
      chipsRaw,
      chips: chipsState,
      deltaChips: delta,
      matchIndex: inMatch ? matchIndex : null,
      data: (typeof e.data==="object" && e.data) ? e.data : {}
    };

    if(!firstLoanEventId && row.type==="LOAN_TAKEN") firstLoanEventId = row.id;
    if(!firstMerchantEnterId && row.type==="MERCHANT_ENTER") firstMerchantEnterId = row.id;
    if(row.type==="MATCH_START" && String(row.data.type||"").toUpperCase()==="BOSS"){
      bossMatchStartIds.push(row.id);
    }

    if(e.type==="MATCH_END"){
      row.matchIndex = matchIndex;
      inMatch = false;
    }

    eventRows.push(row);
    prevChipsState = chipsState;
  }

  // warn if lots of missing chip fields
  const missFrac = (missingChipsCount / Math.max(1, missingChipsCount + sawChipsCount));
  if(missFrac > 0.20){
    warnings.push(`Many events are missing chips (${Math.round(missFrac*100)}%). Consider logging chips on every event for accurate sink attribution.`);
  }

  // Matches / lanes / deck / sinks
  const matches = [];
  const lanes = [];
  const deckPoints = [];
  const deckTimeline = buildDeckTimeline(log.deckHistory);
  const sinks = [];
  const actionsByMatch = new Map();

  const laneResolveRows = eventRows.filter(r=>r.type==="LANE_RESOLVE");
  const hasLaneResolve = laneResolveRows.length>0;

  // deck + sinks + actions
  for(const r of eventRows){
    const ds = grabDeckSnapshot(r.data);
    if(ds && (typeof ds.deckSize==="number" || typeof ds.modCount==="number")){
      deckPoints.push({
        eventId: r.id,
        idx: r.idx,
        floor: r.floor,
        type: r.type,
        deckSize: typeof ds.deckSize==="number" ? ds.deckSize : null,
        modCount: typeof ds.modCount==="number" ? ds.modCount : null
      });
    }
    if(r.deltaChips < 0){
      const cat = categorizeSink(r.type, r);
      sinks.push({eventId:r.id, idx:r.idx, floor:r.floor, type:r.type, category:cat, delta:r.deltaChips});
    }
    if(r.type==="ACTION_USED" && r.matchIndex){
      const a = (r.data && (r.data.actionId || r.data.actionName)) ? (r.data.actionId || r.data.actionName) : "action";
      if(!actionsByMatch.has(r.matchIndex)) actionsByMatch.set(r.matchIndex, []);
      actionsByMatch.get(r.matchIndex).push(String(a));
    }
  }

  // lane rows from LANE_RESOLVE if present
  if(hasLaneResolve){
    laneResolveRows.forEach(r=>{
      const d = r.data||{};
      const lane = d.lane ?? d.laneIndex ?? null;
      if(lane===null) return;
      lanes.push({
        matchIndex: r.matchIndex ?? null,
        floor: r.floor ?? null,
        tableType: inferTableTypeFromMatchStart(eventRows, r.matchIndex) ?? d.tableType ?? null,
        lane: Number(lane),
        playerTotal: d.playerTotal ?? null,
        dealerTotal: d.dealerTotal ?? null,
        playerBust: !!d.playerBust,
        dealerBust: !!d.dealerBust,
        outcome: normalizeOutcome(d.outcome ?? d.winner) ?? null,
        payoutDelta: d.payoutDelta ?? null,
        endedBy: d.endedBy ?? null
      });
    });
  }

  // parse matches from MATCH_START/MATCH_END
  let current = null;
  for(const r of eventRows){
    if(r.type==="MATCH_START"){
      const d = r.data||{};
      const ds = grabDeckSnapshot(d) || {};
      current = {
        matchIndex: r.matchIndex,
        startEventId: r.id,
        startIdx: r.idx,
        floor: r.floor,
        tableType: d.type ?? null,
        buyIn: d.buyIn ?? null,
        chipsAfterBuyIn: r.chips ?? null,
        deckSizeStart: ds.deckSize ?? null,
        modCountStart: ds.modCount ?? null,
        tokensTotal: d.tokensTotal ?? d.tokens ?? null,
        baseTokens: d.baseTokens ?? null,
        bankedTokensUsed: d.bankedTokensUsed ?? null,
        bankedTokensRemaining: d.bankedTokensRemaining ?? null,
        dealerExtraMods: d.dealerExtraMods ?? null,
        transferMultiplierMin: d.transferMultiplierMin ?? null,
        transferMultiplierMax: d.transferMultiplierMax ?? null,
        callingProcChance: d.callingProcChance ?? null,
        edgeDelta: d.edgeDelta ?? null,
        affinity: d.affinity ?? null,
        npcCallingCard: d.npcCallingCard ?? null
      };
    } else if(r.type==="MATCH_END" && current && r.matchIndex===current.matchIndex){
      const d = r.data||{};
      const ds = grabDeckSnapshot(d) || {};
      const metrics = (d.metrics && typeof d.metrics==="object") ? d.metrics : {};
      const lanesObj = (d.lanes && typeof d.lanes==="object") ? d.lanes : null;

      const payout = d.payout ?? null;
      const buyIn = d.buyIn ?? current.buyIn ?? null;
      const bonusChips = d.bonusChips ?? 0;
      const transferNet = d.transferNet ?? 0;
      const matchProfit = (num(payout)-num(buyIn)) + num(bonusChips) + num(transferNet);

      const actionsUsed = actionsByMatch.get(current.matchIndex) || [];

      const matchRow = {
        matchIndex: current.matchIndex,
        floor: current.floor,
        tableType: d.type ?? current.tableType,
        outcome: normalizeOutcome(d.outcome) ?? null,
        buyIn: buyIn,
        payout: payout,
        bonusChips: bonusChips,
        transferNet: transferNet,
        transferMultiplier: d.transferMultiplier ?? null,
        rake: d.rake ?? null,
        rakeRate: d.rakeRate ?? null,
        karmaGained: d.karmaGained ?? null,
        exhaustion: d.exhaustion ?? null,
        matchProfit: matchProfit,
        chipsAfter: r.chips ?? null,
        playerWins: d.playerWins ?? null,
        dealerWins: d.dealerWins ?? null,
        durationMs: d.durationMs ?? null,
        turns: metrics.turns ?? null,
        playerBustsFinal: metrics.playerBustsFinal ?? null,
        dealerBustsFinal: metrics.dealerBustsFinal ?? null,
        deckSizeStart: current.deckSizeStart,
        modCountStart: current.modCountStart,
        deckSizeEnd: ds.deckSize ?? null,
        modCountEnd: ds.modCount ?? null,
        actionsUsed: actionsUsed,
        tokensTotal: current.tokensTotal,
        baseTokens: current.baseTokens,
        bankedTokensUsed: current.bankedTokensUsed,
        bankedTokensRemaining: current.bankedTokensRemaining,
        dealerExtraMods: current.dealerExtraMods,
        transferMultiplierMin: current.transferMultiplierMin,
        transferMultiplierMax: current.transferMultiplierMax,
        callingProcChance: current.callingProcChance,
        edgeDelta: current.edgeDelta,
        affinity: current.affinity,
        npcCallingCard: current.npcCallingCard
      };

      matches.push(matchRow);

      // lanes from MATCH_END if no lane resolve
      if(!hasLaneResolve && lanesObj){
        const pt = lanesObj.playerTotals || null;
        const dt = lanesObj.dealerTotals || null;
        const pb = lanesObj.playerBusts || null;
        const db = lanesObj.dealerBusts || null;
        const winners = lanesObj.laneWinners || null;

        const L = Math.max(
          Array.isArray(pt) ? pt.length : 0,
          Array.isArray(dt) ? dt.length : 0,
          Array.isArray(pb) ? pb.length : 0,
          Array.isArray(db) ? db.length : 0,
          Array.isArray(winners) ? winners.length : 0
        );
        if(L===0){
          warnings.push(`Match ${current.matchIndex}: no lane arrays found.`);
        } else {
          for(let i=0;i<L;i++){
            lanes.push({
              matchIndex: current.matchIndex,
              floor: current.floor,
              tableType: matchRow.tableType,
              lane: i+1,
              playerTotal: Array.isArray(pt) ? pt[i] : null,
              dealerTotal: Array.isArray(dt) ? dt[i] : null,
              playerBust: Array.isArray(pb) ? !!pb[i] : null,
              dealerBust: Array.isArray(db) ? !!db[i] : null,
              outcome: normalizeOutcome(Array.isArray(winners) ? winners[i] : null),
              payoutDelta: null,
              endedBy: null
            });
          }
        }
      }

      current = null;
    }
  }

  // lane completeness check
  const lanesByMatch = {};
  lanes.forEach(l=>{
    const k = String(l.matchIndex);
    lanesByMatch[k] = (lanesByMatch[k]||0)+1;
  });
  matches.forEach(m=>{
    const n = lanesByMatch[String(m.matchIndex)] || 0;
    if(n && n!==5){
      warnings.push(`Match ${m.matchIndex}: lane rows = ${n} (expected 5).`);
    }
  });

  const startChips = firstNonNull(eventRows.map(r=>r.chips));
  const endChips = lastNonNull(eventRows.map(r=>r.chips));
  const netChips = (num(endChips) - num(startChips));

  const stats = log.stats && typeof log.stats==="object" ? log.stats : {};
  const floorsReached = stats.floorsReached ?? maxNum(eventRows.map(r=>r.floor)) ?? null;

  const wins = matches.filter(m=>m.outcome==="WIN").length;
  const losses = matches.filter(m=>m.outcome==="LOSS").length;
  const pushes = matches.filter(m=>m.outcome==="PUSH").length;

  const matchProfitTotal = sum(matches.map(m=>m.matchProfit));
  const bonusTotal = sum(matches.map(m=>num(m.bonusChips)));
  const bonusShare = matchProfitTotal !== 0 ? bonusTotal / matchProfitTotal : null;

  const sinkAgg = aggregateSinks(sinks);
  const totalSpend = sum(Object.values(sinkAgg).map(v=>Math.abs(v)));
  const merchantSpend = Math.abs((sinkAgg["Merchant removals"]||0) + (sinkAgg["Merchant buys"]||0) + (sinkAgg["Merchant rerolls"]||0));
  const merchantShare = totalSpend>0 ? (merchantSpend / totalSpend) : null;

  const laneN = lanes.length;
  const playerBustRate = laneN ? (lanes.filter(l=>l.playerBust===true).length / laneN) : null;
  const dealerBustRate = laneN ? (lanes.filter(l=>l.dealerBust===true).length / laneN) : null;
  const player21Rate = laneN ? (lanes.filter(l=>l.playerTotal===21).length / laneN) : null;
  const dealer21Rate = laneN ? (lanes.filter(l=>l.dealerTotal===21).length / laneN) : null;
  const avgPlayerTotal = avg(lanes.map(l=>numOrNull(l.playerTotal)));
  const avgDealerTotal = avg(lanes.map(l=>numOrNull(l.dealerTotal)));
  const avgPlayerTotalNoBust = avg(lanes.filter(l=>!l.playerBust).map(l=>numOrNull(l.playerTotal)));
  const avgDealerTotalNoBust = avg(lanes.filter(l=>!l.dealerBust).map(l=>numOrNull(l.dealerTotal)));

  const deckSeries = deckTimeline.length ? deckTimeline : deckPoints;
  const deckStart = deckSeries.length ? deckSeries[0] : null;
  const deckEnd = deckSeries.length ? deckSeries[deckSeries.length-1] : null;
  const modDensityEnd = (deckEnd && typeof deckEnd.modCount==="number" && typeof deckEnd.deckSize==="number" && deckEnd.deckSize>0)
    ? deckEnd.modCount / deckEnd.deckSize : null;

  // Run end semantics
  const runEndEvent = findRunEnd(eventRows);
  const runOutcome = getRunOutcomeFromTopLevel(log) ?? runEndEvent ?? inferRunOutcome({endChips, floorsReached}, matches);

  // Per-floor summary
  const floorSummary = buildFloorSummary(matches, lanes, deckSeries, sinks);

  // Keep marker ids for charts
  const runMarkers = {
    loanEventId: firstLoanEventId,
    merchantEnterId: firstMerchantEnterId,
    bossMatchStartIds
  };

  const settingsSnapshot = {
    revealTotalsOnClose: log?.settingsLatest?.revealTotalsOnClose ?? log?.settingsAtStart?.revealTotalsOnClose ?? null,
    opponentDifficulty: log?.settingsLatest?.opponentDifficulty ?? log?.settingsAtStart?.opponentDifficulty ?? null,
    rakeMode: log?.settingsLatest?.rakeMode ?? log?.settingsAtStart?.rakeMode ?? null,
    benchHardCap: log?.settingsLatest?.benchHardCap ?? log?.settingsAtStart?.benchHardCap ?? null,
    rulesContext: log?.rulesContext ?? null
  };
  const startState = log?.initialState ?? {};
  const endState = log?.finalState ?? {};
  const startKarma = startState.karma ?? deckSeries[0]?.karma ?? null;
  const endKarma = endState.karma ?? deckSeries[deckSeries.length-1]?.karma ?? null;
  const startCallingSuit = startState.callingCardSuit ?? startState.callingSuit ?? null;
  const endCallingSuit = endState.callingCardSuit ?? endState.callingSuit ?? null;
  const startCallingRank = startState.callingCardRank ?? startState.callingRank ?? null;
  const endCallingRank = endState.callingCardRank ?? endState.callingRank ?? null;

  const summary = {
    runId: deriveRunId(log, ""),
    sessionId: log.sessionId ?? null,
    startedAtISO: log.startedAt ? toISO(log.startedAt) : (eventRows[0]?.ts ?? null),
    logVersion: log.logVersion ?? null,
    floorsReached,
    matches: matches.length,
    wins, losses, pushes,
    startChips, endChips, netChips,
    chipsPeak: (stats.chipsPeak ?? chipsPeak),
    chipsLow: (stats.chipsLow ?? chipsLow),
    matchProfitTotal,
    profitStdDev: stddev(matches.map(m=>m.matchProfit)),
    bonusTotal,
    bonusShare,
    totalSpend,
    sinkAgg,
    merchantShare,
    playerBustRate,
    dealerBustRate,
    player21Rate,
    dealer21Rate,
    avgPlayerTotal,
    avgDealerTotal,
    avgPlayerTotalNoBust,
    avgDealerTotalNoBust,
    deckSizeStart: deckStart?.deckSize ?? null,
    deckSizeEnd: deckEnd?.deckSize ?? null,
    modCountEnd: deckEnd?.modCount ?? null,
    modDensityEnd,
    runOutcome,
    biggestDrop,
    markers: runMarkers,
    settings: settingsSnapshot,
    startKarma,
    endKarma,
    startCallingSuit,
    startCallingRank,
    endCallingSuit,
    endCallingRank,
    feedback: extractFeedbackSummary(log),
    warnings
  };

  const derived = {
    events: eventRows.map(r=>({
      idx:r.idx, id:r.id, ts:r.ts, t_s:r.t_s, floor:r.floor, type:r.type,
      chips:r.chips, chipsRaw:r.chipsRaw, deltaChips:r.deltaChips,
      matchIndex:r.matchIndex,
      tableType: r.data?.type ?? null
    })),
    matches,
    lanes,
    deck: deckSeries,
    deckTimeline,
    sinks,
    floorSummary
  };

  summary.playstyle = computePlaystyle(summary, derived);

  return {summary, derived};
}

function buildFloorSummary(matches, lanes, deckPoints, sinks){
  const floorsSet = new Set();
  matches.forEach(m=>{ if(m.floor!==null && m.floor!==undefined) floorsSet.add(String(m.floor)); });
  lanes.forEach(l=>{ if(l.floor!==null && l.floor!==undefined) floorsSet.add(String(l.floor)); });
  deckPoints.forEach(d=>{ if(d.floor!==null && d.floor!==undefined) floorsSet.add(String(d.floor)); });
  sinks.forEach(s=>{ if(s.floor!==null && s.floor!==undefined) floorsSet.add(String(s.floor)); });

  const floors = [...floorsSet].map(x=>Number(x)).filter(x=>!Number.isNaN(x)).sort((a,b)=>a-b);
  const rows = [];

  for(const f of floors){
    const mF = matches.filter(m=>m.floor===f);
    const lF = lanes.filter(l=>l.floor===f);
    const dF = deckPoints.filter(d=>d.floor===f);
    const sF = sinks.filter(s=>s.floor===f);

    const matchesN = mF.length;
    const matchWinRate = matchesN ? (mF.filter(m=>m.outcome==="WIN").length / matchesN) : null;
    const matchPushRate = matchesN ? (mF.filter(m=>m.outcome==="PUSH").length / matchesN) : null;
    const avgBuyIn = avg(mF.map(m=>numOrNull(m.buyIn)));
    const avgPayout = avg(mF.map(m=>numOrNull(m.payout)));
    const avgProfit = avg(mF.map(m=>numOrNull(m.matchProfit)));
    const profitSd = stddev(mF.map(m=>numOrNull(m.matchProfit)));

    // table mix
    const mix = {};
    mF.forEach(m=>{
      const k = String(m.tableType||"—");
      mix[k] = (mix[k]||0)+1;
    });
    const mixStr = Object.entries(mix)
      .sort((a,b)=>b[1]-a[1])
      .map(([k,v])=>`${k}:${Math.round((v/Math.max(1,matchesN))*100)}%`)
      .join(" ");

    // lane metrics
    const lanesN = lF.length;
    const laneWinRate = lanesN ? (lF.filter(l=>l.outcome==="WIN").length / lanesN) : null;
    const lanePushRate = lanesN ? (lF.filter(l=>l.outcome==="PUSH").length / lanesN) : null;
    const laneLossRate = lanesN ? (lF.filter(l=>l.outcome==="LOSS").length / lanesN) : null;
    const bustRate = lanesN ? (lF.filter(l=>l.playerBust===true).length / lanesN) : null;
    const rate21 = lanesN ? (lF.filter(l=>l.playerTotal===21).length / lanesN) : null;
    const avgPT = avg(lF.map(l=>numOrNull(l.playerTotal)));
    const avgDT = avg(lF.map(l=>numOrNull(l.dealerTotal)));
    const avgPTNoBust = avg(lF.filter(l=>!l.playerBust).map(l=>numOrNull(l.playerTotal)));
    const avgDTNoBust = avg(lF.filter(l=>!l.dealerBust).map(l=>numOrNull(l.dealerTotal)));
    const bustTotals = lF.filter(l=>l.playerBust && typeof l.playerTotal==="number").map(l=>l.playerTotal);
    const bustTotalAvg = avg(bustTotals);
    const swings = lF
      .filter(l=>typeof l.playerTotal==="number" && typeof l.dealerTotal==="number" && !l.playerBust && !l.dealerBust)
      .map(l=>l.playerTotal - l.dealerTotal);
    const avgSwing = avg(swings);

    // deck boundaries within floor
    const dStart = dF.length ? dF[0] : null;
    const dEnd = dF.length ? dF[dF.length-1] : null;
    const deckStart = dStart?.deckSize ?? null;
    const deckEnd = dEnd?.deckSize ?? null;
    const modsStart = dStart?.modCount ?? null;
    const modsEnd = dEnd?.modCount ?? null;
    const densStart = (typeof modsStart==="number" && typeof deckStart==="number" && deckStart>0) ? modsStart/deckStart : null;
    const densEnd = (typeof modsEnd==="number" && typeof deckEnd==="number" && deckEnd>0) ? modsEnd/deckEnd : null;

    // economy spend by floor
    const spend = {};
    sF.forEach(s=>{
      const k = s.category || "Other";
      spend[k] = (spend[k]||0) + s.delta; // negative
    });
    const topSpend = Object.entries(spend).sort((a,b)=>Math.abs(b[1])-Math.abs(a[1]))[0] || null;
    const topSpendStr = topSpend ? `${topSpend[0]} ${fmt(topSpend[1])}` : "—";

    rows.push({
      floor: f,
      matches: matchesN,
      matchWinRate,
      matchPushRate,
      avgBuyIn,
      avgPayout,
      avgProfit,
      profitSd,
      tableMix: mixStr || "—",
      lanes: lanesN,
      laneWinRate,
      lanePushRate,
      laneLossRate,
      bustRate,
      rate21,
      avgPlayerTotal: avgPT,
      avgDealerTotal: avgDT,
      avgPlayerTotalNoBust: avgPTNoBust,
      avgDealerTotalNoBust: avgDTNoBust,
      bustTotalAvg,
      avgSwing,
      deckStart,
      deckEnd,
      modsStart,
      modsEnd,
      modDensityStart: densStart,
      modDensityEnd: densEnd,
      topSpend: topSpendStr
    });
  }

  return rows;
}

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function normRange(v, lo, hi){
  if(v===null || v===undefined || Number.isNaN(v)) return 0;
  if(hi===lo) return 0;
  return clamp01((v - lo) / (hi - lo));
}
function countEvents(events, matcher){
  if(!events || !events.length) return 0;
  if(typeof matcher === "function") return events.filter(matcher).length;
  const m = String(matcher||"");
  return events.filter(e=>String(e.type||"").toUpperCase().includes(m)).length;
}
function herfindahl(obj){
  if(!obj || typeof obj!=="object") return null;
  const values = Object.values(obj).map(v=>Number(v)).filter(v=>!Number.isNaN(v));
  const total = values.reduce((a,b)=>a+b,0);
  if(!total) return null;
  return values.reduce((a,v)=> a + Math.pow(v/total,2), 0);
}

function computePlaystyle(summary, derived){
  const matches = derived.matches || [];
  const events = derived.events || [];
  const lanes = derived.lanes || [];
  const sinks = derived.sinks || [];
  const deckTimeline = derived.deckTimeline || [];

  const matchesN = Math.max(1, summary.matches || matches.length || 1);

  const highTables = matches.filter(m=>String(m.tableType||"").toUpperCase()==="HIGH_STAKES").length;
  const bossTables = matches.filter(m=>String(m.tableType||"").toUpperCase()==="BOSS").length;
  const tableIntensity = (0.65*highTables + 1.0*bossTables) / matchesN;

  const avgTransferMult = avg(matches.map(m=>numOrNull(m.transferMultiplier)));
  const highMultRate = matches.length ? matches.filter(m=>num(m.transferMultiplier)>=4).length / matches.length : 0;

  const tempoApplied = countEvents(events, "TEMPO_STRIKE_APPLIED");
  const tempoBlocked = countEvents(events, "TEMPO_STRIKE_BLOCKED");
  const tempoApplyRate = (tempoApplied + tempoBlocked) ? tempoApplied / (tempoApplied + tempoBlocked) : 0;

  const tokensSpent = countEvents(events, "TOKEN_SPENT");
  const actionsUsed = countEvents(events, "ACTION_USED");
  const tokensPerMatch = tokensSpent / matchesN;
  const actionsPerMatch = actionsUsed / matchesN;

  const callingProcs = events.filter(e=>String(e.type||"").startsWith("CALLING_PROC_")).length;
  const karmaGainEvents = countEvents(events, "KARMA_GAIN");
  const callingPerMatch = callingProcs / matchesN;

  const deckEdits = deckTimeline.length ? Math.max(0, deckTimeline.length-1) : 0;
  const deckEditsPerMatch = deckEdits / matchesN;
  const editReasons = deckTimeline.map(d=>String(d.reason||"").toUpperCase());
  const stampCount = editReasons.filter(r=>r==="STAMP_APPLY").length;
  const sleeveCount = editReasons.filter(r=>r==="SLEEVE_APPLY").length;
  const fuseCount = editReasons.filter(r=>r==="REWARD_FUSE").length;
  const duplicateCount = editReasons.filter(r=>r==="REWARD_DUPLICATE").length;

  const sinkAgg = summary.sinkAgg || {};
  const totalSpend = summary.totalSpend || 0;
  const merchantSpend = Math.abs((sinkAgg["Merchant removals"]||0) + (sinkAgg["Merchant buys"]||0) + (sinkAgg["Merchant rerolls"]||0));
  const collectorSpend = Math.abs(sinkAgg["Collector"]||0);
  const modifySpend = Math.abs(sinkAgg["Modify"]||0);
  const surgerySpendShare = totalSpend ? (merchantSpend + collectorSpend + modifySpend) / totalSpend : 0;

  const bustRate = summary.playerBustRate ?? (lanes.length ? lanes.filter(l=>l.playerBust).length / lanes.length : 0);
  const controlTotals = summary.avgPlayerTotalNoBust ?? summary.avgPlayerTotal ?? null;

  const deckEnd = deckTimeline.length ? deckTimeline[deckTimeline.length-1] : null;
  const suitHhi = herfindahl(deckEnd?.bySuit ?? deckEnd?.summary?.bySuit);
  const modDensity = summary.modDensityEnd ?? null;

  const risk = 100 * (
    0.45*clamp01(tableIntensity) +
    0.35*normRange(avgTransferMult, 1, 5) +
    0.20*normRange(summary.profitStdDev, 0, 200)
  );
  const pressure = 100 * (
    0.55*normRange(tempoApplied / matchesN, 0, 6) +
    0.25*normRange(actionsPerMatch, 0, 2) +
    0.20*normRange(tempoApplyRate, 0.2, 0.6)
  );
  const control = 100 * (
    0.5*(1 - normRange(bustRate, 0, 0.35)) +
    0.25*normRange(controlTotals, 17, 20) +
    0.25*normRange(modDensity, 0, 0.25)
  );
  const surgery = 100 * (
    0.5*normRange(deckEditsPerMatch, 0, 1.5) +
    0.25*normRange(surgerySpendShare, 0, 0.6) +
    0.25*normRange(merchantSpend / Math.max(1, totalSpend), 0, 0.6)
  );
  const engine = 100 * (
    0.45*normRange(stampCount + sleeveCount, 0, 6) +
    0.35*normRange(fuseCount + duplicateCount, 0, 6) +
    0.20*normRange(summary.player21Rate, 0.15, 0.65)
  );
  const karma = 100 * (
    0.6*normRange(callingPerMatch, 0, 3) +
    0.4*normRange(karmaGainEvents / matchesN, 0, 4)
  );
  const actions = 100 * (
    0.55*normRange(tokensPerMatch, 0, 2) +
    0.45*normRange(actionsPerMatch, 0, 1.5)
  );
  const economy = 100 * (
    0.6*normRange((summary.chipsLow||0) / Math.max(1, summary.startChips||1), 0.2, 0.8) +
    0.4*(1 - normRange(totalSpend / Math.max(1, Math.abs(summary.matchProfitTotal)||1), 0.5, 2))
  );

  const axes = { risk, pressure, control, surgery, engine, karma, actions, economy };
  const axes01 = Object.fromEntries(Object.entries(axes).map(([k,v])=>[k, clamp01(v/100)]));

  const archetypes = [
    {name:"The Surgeon", vec:{surgery:0.85, control:0.65, engine:0.4, economy:0.4}},
    {name:"The Saboteur", vec:{pressure:0.85, actions:0.7, risk:0.5}},
    {name:"The High Roller", vec:{risk:0.9, economy:0.2, control:0.2}},
    {name:"The Engine Builder", vec:{engine:0.9, control:0.45, surgery:0.35}},
    {name:"The Karma Chaser", vec:{karma:0.9, engine:0.5, control:0.35}},
    {name:"The Banker", vec:{economy:0.9, control:0.7, risk:0.1}}
  ];

  function cosineScore(vec){
    const keys = Object.keys(axes01);
    const a = keys.map(k=>axes01[k] ?? 0);
    const b = keys.map(k=>vec[k] ?? 0);
    const dot = a.reduce((s,v,i)=>s + v*b[i], 0);
    const magA = Math.sqrt(a.reduce((s,v)=>s+v*v, 0)) || 1;
    const magB = Math.sqrt(b.reduce((s,v)=>s+v*v, 0)) || 1;
    return dot / (magA * magB);
  }

  const scored = archetypes.map(a=>({name:a.name, score: cosineScore(a.vec)})).sort((a,b)=>b.score-a.score);
  const primary = scored[0] || {name:"Unknown", score:0};
  const secondary = scored[1] || {name:"None", score:0};
  const confidence = clamp01((primary.score - secondary.score) / 0.2);

  const drivers = [];
  if(callingProcs){
    drivers.push(`Calling procs: ${callingProcs} (~${(callingPerMatch).toFixed(2)}/match).`);
  }
  if(deckEdits){
    drivers.push(`Deck edits: ${deckEdits} (~${deckEditsPerMatch.toFixed(2)}/match).`);
  }
  if(typeof bustRate==="number"){
    drivers.push(`Bust rate: ${pct(bustRate)} • 21 rate: ${pct(summary.player21Rate)}.`);
  }
  if(highTables + bossTables){
    drivers.push(`High-stakes + boss share: ${Math.round(((highTables+bossTables)/matchesN)*100)}%.`);
  }
  if(tokensSpent){
    drivers.push(`Tokens spent: ${tokensSpent} (~${tokensPerMatch.toFixed(2)}/match).`);
  }

  const notes = generatePlayNotes({
    matchesN,
    tableIntensity,
    avgTransferMult,
    highMultRate,
    bustRate,
    deckEditsPerMatch,
    suitHhi,
    modDensity,
    tokensPerMatch,
    callingPerMatch,
    tempoAppliedPerMatch: tempoApplied / matchesN,
    tempoApplyRate
  });

  const features = {
    tableIntensity,
    nonStandardTableRate: (highTables + bossTables) / matchesN,
    bossRate: bossTables / matchesN,
    avgTransferMult,
    highMultRate,
    bustRate,
    tokensPerMatch,
    actionsPerMatch,
    deckEditsPerMatch,
    modDensityEnd: modDensity,
    suitHerfindahlEnd: suitHhi,
    callingPerMatch,
    tempoAppliedPerMatch: tempoApplied / matchesN,
    tempoApplyRate
  };

  const vector = [
    features.tableIntensity,
    features.nonStandardTableRate,
    features.bossRate,
    features.avgTransferMult,
    features.highMultRate,
    features.bustRate,
    features.tokensPerMatch,
    features.actionsPerMatch,
    features.deckEditsPerMatch,
    features.modDensityEnd,
    features.suitHerfindahlEnd,
    features.callingPerMatch,
    features.tempoAppliedPerMatch,
    features.tempoApplyRate
  ];

  return {
    axes,
    primary,
    secondary: secondary.score >= 0.55 ? secondary : {name:"None", score: secondary.score},
    confidence,
    drivers,
    notes,
    features,
    vector,
    archetypeScores: scored
  };
}

function generatePlayNotes(metrics){
  const notes = [];
  if(metrics.tableIntensity >= 0.55){
    notes.push({kind:"obs", text:"Preferred high-stakes routing (non-standard tables were frequent)."});
  }
  if(metrics.avgTransferMult >= 3.8 || metrics.highMultRate >= 0.4){
    notes.push({kind:"obs", text:"Leaned into big transfer bets; expects to win by margin."});
  }
  if(metrics.bustRate !== null && metrics.bustRate <= 0.06){
    notes.push({kind:"good", text:"Low bust profile; closes lanes conservatively."});
  }
  if(metrics.bustRate !== null && metrics.bustRate >= 0.18){
    notes.push({kind:"warn", text:"High bust profile; likely pushing totals or overextending."});
  }
  if(metrics.deckEditsPerMatch >= 1.0){
    notes.push({kind:"obs", text:"Heavy deck sculpting; run identity shaped by frequent edits."});
  }
  if(metrics.suitHhi !== null && metrics.suitHhi >= 0.30){
    notes.push({kind:"obs", text:"Deck concentrated into a suit plan (cohesion increased by endgame)."});
  }
  if(metrics.tokensPerMatch >= 1.3){
    notes.push({kind:"obs", text:"Resource-forward play: tokens used frequently to stabilize outcomes."});
  }
  if(metrics.callingPerMatch >= 1.2){
    notes.push({kind:"obs", text:"Calling procs were a frequent part of match wins."});
  }
  if(metrics.tempoAppliedPerMatch >= 3.0 && metrics.tempoApplyRate >= 0.45){
    notes.push({kind:"obs", text:"Tempo pressure was a meaningful part of match wins."});
  }
  return notes.slice(0,7);
}

/* =========================
   Charting (canvas)
   ========================= */
function setupCanvas(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return ctx;
}
function formatCompact(v){
  if(v===null || v===undefined || Number.isNaN(v)) return "—";
  if(Math.abs(v)>=1000000) return (v/1000000).toFixed(1)+"M";
  if(Math.abs(v)>=1000) return (v/1000).toFixed(1)+"k";
  return Math.round(v).toString();
}
function clearChart(ctx, w, h){ ctx.clearRect(0,0,w,h); }

function drawAxes(ctx, w, h, pad, xLabel, yLabel, yMin, yMax){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, h-pad);
  ctx.lineTo(w-pad, h-pad);
  ctx.stroke();

  const ticks = 4;
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
  for(let i=0;i<=ticks;i++){
    const t = i/ticks;
    const y = pad + (1-t)*(h-2*pad);
    const v = yMin + t*(yMax - yMin);
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(w-pad, y);
    ctx.stroke();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fillText(formatCompact(v), 6, y+4);
  }

  ctx.fillStyle = "rgba(255,255,255,0.55)";
  if(yLabel){
    ctx.save();
    ctx.translate(10, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }
  if(xLabel){
    ctx.fillText(xLabel, w/2 - ctx.measureText(xLabel).width/2, h-6);
  }
  ctx.restore();
}

function drawAxesDualY(ctx, w, h, pad, xLabel, yLabelL, yMinL, yMaxL, yLabelR, yMinR, yMaxR){
  drawAxes(ctx, w, h, pad, xLabel, yLabelL, yMinL, yMaxL);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  ctx.beginPath();
  ctx.moveTo(w-pad, pad);
  ctx.lineTo(w-pad, h-pad);
  ctx.stroke();

  const ticks = 4;
  ctx.fillStyle = "rgba(255,255,255,0.55)";
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
  for(let i=0;i<=ticks;i++){
    const t = i/ticks;
    const y = pad + (1-t)*(h-2*pad);
    const v = yMinR + t*(yMaxR - yMinR);
    ctx.fillText(formatCompact(v), w-pad+6, y+4);
  }
  if(yLabelR){
    ctx.save();
    ctx.translate(w-10, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabelR, 0, 0);
    ctx.restore();
  }
  ctx.restore();
}

function drawLineScaled(ctx, w, h, pad, xs, ys, yMin, yMax, strokeStyle, dash=null){
  ctx.save();
  if(dash) ctx.setLineDash(dash);
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const x = pad + xs[i]*(w-2*pad);
    const t = (ys[i]-yMin)/(yMax-yMin||1);
    const y = pad + (1-t)*(h-2*pad);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function drawMarkers(ctx, w, h, pad, xNorms, labels){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
  for(let i=0;i<xNorms.length;i++){
    const x = pad + xNorms[i]*(w-2*pad);
    ctx.beginPath();
    ctx.moveTo(x, pad);
    ctx.lineTo(x, h-pad);
    ctx.stroke();
    const txt = labels[i];
    ctx.save();
    ctx.translate(x+4, pad+10);
    ctx.rotate(Math.PI/2);
    ctx.fillText(txt, 0, 0);
    ctx.restore();
  }
  ctx.restore();
}

function drawBarChart(ctx, w, h, pad, values, labels, yMin, yMax){
  const n = values.length;
  const innerW = w-2*pad;
  const innerH = h-2*pad;
  const barW = innerW / Math.max(1,n);
  const zeroY = pad + (1-((0-yMin)/(yMax-yMin||1)))*innerH;

  ctx.save();
  ctx.fillStyle = "rgba(125,211,252,0.70)";
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;

  for(let i=0;i<n;i++){
    const v = values[i];
    const x = pad + i*barW + barW*0.12;
    const bw = barW*0.76;
    const y = pad + (1-((v-yMin)/(yMax-yMin||1)))*innerH;
    const top = Math.min(y, zeroY);
    const bottom = Math.max(y, zeroY);
    const bh = Math.max(1, bottom-top);

    ctx.fillRect(x, top, bw, bh);
    ctx.strokeRect(x, top, bw, bh);

    if(n<=14 || i%2===0){
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
      const lab = labels[i];
      ctx.fillText(lab, x, h-8);
      ctx.fillStyle = "rgba(125,211,252,0.70)";
    }
  }

  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.beginPath();
  ctx.moveTo(pad, zeroY);
  ctx.lineTo(w-pad, zeroY);
  ctx.stroke();

  ctx.restore();
}

function drawGroupedRates(ctx, w, h, pad, groups, series){
  drawAxes(ctx, w, h, pad, "", "Rate", 0, 1);

  ctx.save();
  const colors = [
    "rgba(125,211,252,0.72)",
    "rgba(52,211,153,0.65)",
    "rgba(251,191,36,0.65)",
    "rgba(251,113,133,0.65)",
    "rgba(255,255,255,0.35)"
  ];
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;

  const nG = groups.length;
  const nS = series.length;
  const innerW = w-2*pad, innerH = h-2*pad;
  const gW = innerW / Math.max(1,nG);
  const barW = gW / Math.max(1,nS+1);

  for(let gi=0;gi<nG;gi++){
    for(let si=0;si<nS;si++){
      const v = series[si].values[gi] ?? 0;
      const x = pad + gi*gW + si*barW + barW*0.15;
      const bw = barW*0.7;
      const y = pad + (1-v)*innerH;
      const bh = v*innerH;
      ctx.fillStyle = colors[si % colors.length];
      ctx.fillRect(x,y,bw,bh);
    }
    const gx = pad + gi*gW + gW*0.08;
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    const lab = groups[gi];
    ctx.fillText(lab.length>14 ? lab.slice(0,14)+"…" : lab, gx, h-8);
  }

  // legend
  let lx = pad, ly = pad-8;
  series.forEach((s, i)=>{
    ctx.fillStyle = colors[i % colors.length];
    ctx.fillRect(lx, ly, 10, 10);
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.fillText(s.name, lx+14, ly+10);
    lx += 14 + ctx.measureText(s.name).width + 14;
  });

  ctx.restore();
}

function drawHistogramOverlay(ctx, w, h, pad, valuesA, valuesB, minV, maxV){
  const bins = maxV-minV+1;
  const countsA = new Array(bins).fill(0);
  const countsB = new Array(bins).fill(0);

  valuesA.forEach(v=>{
    if(typeof v!=="number") return;
    const idx = Math.round(v) - minV;
    if(idx>=0 && idx<bins) countsA[idx]+=1;
  });
  valuesB.forEach(v=>{
    if(typeof v!=="number") return;
    const idx = Math.round(v) - minV;
    if(idx>=0 && idx<bins) countsB[idx]+=1;
  });
  const maxCount = Math.max(...countsA, ...countsB, 1);

  drawAxes(ctx, w, h, pad, "Total", "Count", 0, maxCount);

  const innerW = w-2*pad, innerH = h-2*pad;
  const bw = innerW / bins;

  ctx.save();
  for(let i=0;i<bins;i++){
    const a = countsA[i], b = countsB[i];
    const x = pad + i*bw;

    const ah = (a/maxCount)*innerH;
    ctx.fillStyle = "rgba(125,211,252,0.55)";
    ctx.fillRect(x+bw*0.10, pad + (innerH-ah), bw*0.38, ah);

    const bh = (b/maxCount)*innerH;
    ctx.fillStyle = "rgba(251,191,36,0.45)";
    ctx.fillRect(x+bw*0.52, pad + (innerH-bh), bw*0.38, bh);

    const total = minV + i;
    if(bins<=15 || total%2===0){
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(String(total), x+bw*0.20, h-8);
    }
  }

  // legend
  ctx.fillStyle = "rgba(125,211,252,0.8)";
  ctx.fillRect(pad, pad-10, 10, 10);
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.fillText("Player", pad+14, pad);
  ctx.fillStyle = "rgba(251,191,36,0.7)";
  ctx.fillRect(pad+70, pad-10, 10, 10);
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.fillText("Dealer", pad+84, pad);

  ctx.restore();
}

/* =========================
   Dashboard rendering
   ========================= */
function getRunRecord(runId){ return DB.runs[runId] || null; }
function getRunAnalysis(runRec){
  if(runRec.rawLog){
    const parsed = safeParseJSON(runRec.rawLog);
    if(parsed.ok) return analyzeLog(parsed.value);
  }
  return { summary: runRec.summary, derived: runRec.derived };
}


function getFeedbackForRun(runRec){
  const id = runRec?.meta?.runId;
  if(id && feedbackCache[id]) return feedbackCache[id];

  const sf = runRec?.summary?.feedback;
  if(sf && typeof sf==="object"){
    if(id) feedbackCache[id] = sf;
    return sf;
  }

  if(runRec?.rawLog){
    const parsed = safeParseJSON(runRec.rawLog);
    if(parsed.ok){
      const fb = extractFeedbackSummary(parsed.value);
      if(id) feedbackCache[id] = fb;
      return fb;
    }
  }

  const empty = {comments:"", bugs:"", updatedAtISO:null, updatesCount:null, lastUpdateISO:null, hasText:false};
  if(id) feedbackCache[id] = empty;
  return empty;
}
function clip(s, n=140){
  s = normText(s);
  if(!s) return "—";
  return s.length > n ? (s.slice(0,n-1) + "…") : s;
}
function renderFeedbackTab(){
  const search = (document.getElementById("fbSearch")?.value || "").toLowerCase().trim();
  const onlyWithText = !!document.getElementById("fbOnlyWithText")?.checked;

  const runs = Object.values(DB.runs);
  const rows = runs.map(r=>{
    const fb = getFeedbackForRun(r);
    const startedAt = r.meta.startedAtISO || r.summary?.startedAtISO || r.meta.importedAtISO || null;
    const cfgName = DB.configs[r.meta.configId]?.name || "(No config)";
    const outcome = r.summary?.runOutcome || {};
    return {
      _runId: r.meta.runId,
      startedAtISO: startedAt,
      importedAtISO: r.meta.importedAtISO || null,
      sourceFilename: r.meta.sourceFilename || "—",
      sessionId: r.meta.sessionId || "—",
      logVersion: r.meta.logVersion || "—",
      configId: r.meta.configId || "—",
      configName: cfgName,
      tags: (r.meta.tags || []).join("; "),
      notes: r.meta.notes || "",
      outcome: outcome.result || "—",
      outcomeReason: outcome.reason || "—",
      endFloor: outcome.floor ?? r.summary?.floorsReached ?? "—",
      endChips: outcome.chips ?? r.summary?.endChips ?? "—",
      endKarma: r.summary?.endKarma ?? "—",
      feedbackUpdatedAtISO: fb.updatedAtISO || fb.lastUpdateISO || "—",
      updatesCount: fb.updatesCount ?? "—",
      comments: fb.comments,
      bugs: fb.bugs,
      hasText: fb.hasText
    };
  });

  const filtered = rows.filter(x=>{
    if(onlyWithText && !x.hasText) return false;
    if(search){
      const hay = [
        x._runId, x.startedAtISO, x.importedAtISO, x.sourceFilename, x.sessionId,
        x.configName, x.tags, x.notes, x.comments, x.bugs
      ].join(" ").toLowerCase();
      if(!hay.includes(search)) return false;
    }
    return true;
  }).sort((a,b)=>{
    const ta = new Date(a.startedAtISO||0).getTime();
    const tb = new Date(b.startedAtISO||0).getTime();
    return tb - ta;
  });

  const total = rows.length;
  const withText = rows.filter(r=>r.hasText).length;
  document.getElementById("fbSummary").textContent =
    `${filtered.length} run(s) shown • ${withText} run(s) contain feedback • ${total} total stored`;

  const missing = rows.filter(r=>!r.hasText).length;
  const warnEl = document.getElementById("fbWarn");
  if(missing && onlyWithText){
    warnEl.style.display = "none";
    warnEl.textContent = "";
  }else if(missing){
    warnEl.style.display = "block";
    warnEl.textContent =
      `Note: ${missing} run(s) have no feedback text stored. If these were imported before feedback scraping existed and stored without raw logs, you may need to re-import those JSON logs to capture feedback.`;
  }else{
    warnEl.style.display = "none";
    warnEl.textContent = "";
  }

  const el = document.getElementById("feedbackTable");
  const cols = [
    ["startedAtISO","Started"],
    ["_runId","Run ID"],
    ["configName","Config"],
    ["tags","Tags"],
    ["outcome","Outcome"],
    ["endFloor","Floor"],
    ["endChips","Chips"],
    ["endKarma","Karma"],
    ["feedbackUpdatedAtISO","Feedback Updated"],
    ["updatesCount","Edits"],
    ["comments","Comments (preview)"],
    ["bugs","Bugs (preview)"]
  ];

  el.innerHTML = `
    <thead><tr>
      ${cols.map(c=>`<th>${escapeHTML(c[1])}</th>`).join("")}
      <th>Action</th>
    </tr></thead>
    <tbody>
      ${filtered.map(r=>`
        <tr>
          <td>${escapeHTML(fmt(r.startedAtISO||""))}</td>
          <td title="${escapeHTML(r._runId)}">${escapeHTML(r._runId)}</td>
          <td>${escapeHTML(r.configName)}</td>
          <td title="${escapeHTML(r.tags)}">${escapeHTML(clip(r.tags, 60))}</td>
          <td>${escapeHTML(r.outcome)}</td>
          <td>${escapeHTML(fmt(r.endFloor))}</td>
          <td>${escapeHTML(fmt(r.endChips))}</td>
          <td>${escapeHTML(fmt(r.endKarma))}</td>
          <td>${escapeHTML(fmt(r.feedbackUpdatedAtISO||""))}</td>
          <td>${escapeHTML(fmt(r.updatesCount))}</td>
          <td title="${escapeHTML(r.comments)}">${escapeHTML(clip(r.comments, 90))}</td>
          <td title="${escapeHTML(r.bugs)}">${escapeHTML(clip(r.bugs, 90))}</td>
          <td style="white-space:nowrap">
            <button class="btn small" data-view="${escapeHTML(r._runId)}">View</button>
            <button class="btn small primary" data-open="${escapeHTML(r._runId)}">Open</button>
          </td>
        </tr>
      `).join("")}
    </tbody>
  `;

  el.querySelectorAll("button[data-open]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-open");
      currentRunId = id;
      setTab("dashboardTab");
      renderDashboard(id);
    });
  });

  el.querySelectorAll("button[data-view]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-view");
      const runRec = getRunRecord(id);
      if(!runRec) return;

      const fb = getFeedbackForRun(runRec);
      const startedAt = runRec.meta.startedAtISO || runRec.summary?.startedAtISO || runRec.meta.importedAtISO || "";
      const cfgName = DB.configs[runRec.meta.configId]?.name || "(No config)";

      document.getElementById("fbDlgTitle").textContent = `Feedback • ${id}`;
      document.getElementById("fbDlgMeta").textContent = `${startedAt} • ${cfgName} • ${(runRec.meta.tags||[]).join(", ")}`;
      document.getElementById("fbDlgComments").textContent = fb.comments || "—";
      document.getElementById("fbDlgBugs").textContent = fb.bugs || "—";

      document.getElementById("dlgFeedbackView").showModal();
    });
  });
}

function renderDashboard(runId){
  const runRec = getRunRecord(runId);
  if(!runRec){
    document.getElementById("dashSub").textContent = "Run not found.";
    return;
  }
  currentRunId = runId;

  const analysis = getRunAnalysis(runRec);
  runRec.summary = analysis.summary;
  if(runRec.derived) runRec.derived = analysis.derived;
  saveDB();

  const s = analysis.summary;
  const derived = analysis.derived;
  if(derived && !s.playstyle){
    s.playstyle = computePlaystyle(s, derived);
  }

  document.getElementById("dashSub").textContent =
    `${runRec.meta.sourceFilename || runId} • ${runRec.meta.sessionId || runId} • ${runRec.meta.startedAtISO || s.startedAtISO || ""}`;

  // Overview strip
  const cfgName = DB.configs[runRec.meta.configId]?.name || "(No config)";
  const outcome = s.runOutcome || {result:"UNKNOWN"};
  const result = outcome.result || "UNKNOWN";
  const reason = outcome.reason ? String(outcome.reason) : "—";
  const endFloor = outcome.floor ?? s.floorsReached ?? "—";
  const endType = outcome.tableType ?? "—";
  const endMatch = outcome.matchIndex ?? "—";
  const endChips = outcome.chips ?? s.endChips ?? "—";

  const outcomePill = result==="WIN" ? "goodBox" : result==="LOSS" ? "badBox" : "warnBox";
  const biggestSink = s.biggestDrop && s.biggestDrop.delta < 0 ? `${s.biggestDrop.type} ${fmt(s.biggestDrop.delta)}` : "—";

  document.getElementById("dashOverview").innerHTML = `
    <div class="${outcomePill}">
      <div style="font-weight:700; margin-bottom:6px">
        Outcome: ${escapeHTML(result)} <span class="muted">(${escapeHTML(reason)})</span>
      </div>
      <div class="tiny">
        End: Floor <b>${escapeHTML(endFloor)}</b> • Table <b>${escapeHTML(endType)}</b> • Match <b>${escapeHTML(endMatch)}</b> • Chips <b>${escapeHTML(endChips)}</b><br/>
        Peak / Low: <b>${escapeHTML(fmt(s.chipsPeak))}</b> / <b>${escapeHTML(fmt(s.chipsLow))}</b> • Biggest sink event: <b>${escapeHTML(biggestSink)}</b> • Config: <b>${escapeHTML(cfgName)}</b>
      </div>
    </div>
  `;

  // Header KPIs
  const tags = (runRec.meta.tags||[]).join(", ");

  document.getElementById("dashHeader").innerHTML = `
    <div class="kpiGrid">
      <div class="kpi"><div class="label">Config</div><div class="value">${escapeHTML(cfgName)}</div></div>
      <div class="kpi"><div class="label">Floors</div><div class="value">${fmt(s.floorsReached)}</div></div>
      <div class="kpi"><div class="label">Matches</div><div class="value">${fmt(s.matches)}</div></div>
      <div class="kpi"><div class="label">W / L / P</div><div class="value">${fmt(s.wins)} / ${fmt(s.losses)} / ${fmt(s.pushes)}</div></div>
      <div class="kpi"><div class="label">Chips (start → end)</div><div class="value">${fmt(s.startChips)} → ${fmt(s.endChips)}</div></div>
      <div class="kpi"><div class="label">Net Chips</div><div class="value">${fmt(s.netChips)}</div></div>

      <div class="kpi"><div class="label">Match profit total</div><div class="value">${fmt(s.matchProfitTotal)}</div></div>
      <div class="kpi"><div class="label">Profit volatility (sd)</div><div class="value">${fmt(s.profitStdDev)}</div></div>
      <div class="kpi"><div class="label">Player bust rate</div><div class="value">${pct(s.playerBustRate)}</div></div>
      <div class="kpi"><div class="label">Player 21 rate</div><div class="value">${pct(s.player21Rate)}</div></div>
      <div class="kpi"><div class="label">Merchant share</div><div class="value">${pct(s.merchantShare)}</div></div>
      <div class="kpi"><div class="label">Tags</div><div class="value" title="${escapeHTML(tags)}">${escapeHTML(tags || "—")}</div></div>
    </div>
    <div class="hint" style="margin-top:10px">
      <b>Notes:</b> <span class="muted">${escapeHTML(runRec.meta.notes || "—")}</span>
    </div>
  `;

  const settingsBody = document.getElementById("settingsSnapshotBody");
  const settings = s.settings || {};
  const rulesCtx = settings.rulesContext ? `<div class="mono tiny">${escapeHTML(JSON.stringify(settings.rulesContext))}</div>` : "<span class=\"muted\">—</span>";
  settingsBody.innerHTML = `
    <div class="grid cols3">
      <div><b>revealTotalsOnClose:</b> ${escapeHTML(fmt(settings.revealTotalsOnClose))}</div>
      <div><b>opponentDifficulty:</b> ${escapeHTML(fmt(settings.opponentDifficulty))}</div>
      <div><b>rakeMode:</b> ${escapeHTML(fmt(settings.rakeMode))}</div>
      <div><b>benchHardCap:</b> ${escapeHTML(fmt(settings.benchHardCap))}</div>
      <div><b>start/end karma:</b> ${escapeHTML(fmt(s.startKarma))} → ${escapeHTML(fmt(s.endKarma))}</div>
      <div><b>calling:</b> ${escapeHTML(fmt(s.startCallingSuit))} ${escapeHTML(fmt(s.startCallingRank))} → ${escapeHTML(fmt(s.endCallingSuit))} ${escapeHTML(fmt(s.endCallingRank))}</div>
    </div>
    <div style="margin-top:8px"><b>rulesContext:</b> ${rulesCtx}</div>
  `;

  // Warnings
  const warnBox = document.getElementById("dashWarnings");
  warnBox.innerHTML = "";
  if(s.warnings && s.warnings.length){
    warnBox.innerHTML = `<div class="warnBox"><b>Telemetry warnings:</b><ul style="margin:8px 0 0 18px">${s.warnings.map(w=>`<li>${escapeHTML(w)}</li>`).join("")}</ul></div>`;
  }

  // Per-floor table
  renderFloorTable(derived.floorSummary || []);

  // Charts
  renderFingerprint(analysis);
  renderProgressionChart(derived, s);
  renderChipsChart(derived, s);
  renderProfitChart(derived);
  renderDeckChart(derived);
  renderDeckIdentity(derived, s);
  renderRatesChart(derived, document.getElementById("segmentMode").value, document.getElementById("outcomeBasis").value);
  renderTotalsChart(derived);
  renderSinksChart(derived);

  // Insights
  renderInsights(analysis, runRec);
  renderKeyMoments(analysis);

  // Tables
  renderMatchTable(derived.matches || []);
  renderLaneTable(derived.lanes || []);
}

document.getElementById("segmentMode").addEventListener("change", ()=>{
  if(!currentRunId) return;
  const rr = getRunRecord(currentRunId);
  if(!rr) return;
  const a = getRunAnalysis(rr);
  renderRatesChart(a.derived, document.getElementById("segmentMode").value, document.getElementById("outcomeBasis").value);
});
document.getElementById("outcomeBasis").addEventListener("change", ()=>{
  if(!currentRunId) return;
  const rr = getRunRecord(currentRunId);
  if(!rr) return;
  const a = getRunAnalysis(rr);
  renderRatesChart(a.derived, document.getElementById("segmentMode").value, document.getElementById("outcomeBasis").value);
});

function renderFloorTable(rows){
  const el = document.getElementById("floorTable");
  if(!rows.length){
    el.innerHTML = `<tr><td class="muted">No floor summary rows.</td></tr>`;
    return;
  }
  const cols = [
    ["floor","Floor"],
    ["matches","Matches"],
    ["matchWinRate","M.Win"],
    ["matchPushRate","M.Push"],
    ["avgBuyIn","Avg BuyIn"],
    ["avgProfit","Avg Profit"],
    ["profitSd","Profit SD"],
    ["tableMix","Mix"],
    ["lanes","Lanes"],
    ["laneWinRate","L.Win"],
    ["lanePushRate","L.Push"],
    ["bustRate","Bust"],
    ["rate21","21"],
    ["avgPlayerTotal","P.Avg"],
    ["avgDealerTotal","D.Avg"],
    ["avgPlayerTotalNoBust","P.Avg (NoBust)"],
    ["avgDealerTotalNoBust","D.Avg (NoBust)"],
    ["bustTotalAvg","Bust Avg"],
    ["avgSwing","Swing"],
    ["deckStart","Deck S"],
    ["deckEnd","Deck E"],
    ["modsStart","Mods S"],
    ["modsEnd","Mods E"],
    ["modDensityEnd","ModDen E"],
    ["topSpend","Top Spend"]
  ];
  el.innerHTML = `
    <thead><tr>${cols.map(c=>`<th>${escapeHTML(c[1])}</th>`).join("")}</tr></thead>
    <tbody>
      ${rows.map(r=>`<tr>${cols.map(c=>{
        const k=c[0];
        const v=r[k];
        if(k.endsWith("Rate") || k==="bustRate" || k==="rate21" || k.startsWith("modDensity")) return `<td>${escapeHTML(pct(v))}</td>`;
        return `<td>${escapeHTML(fmt(v))}</td>`;
      }).join("")}</tr>`).join("")}
    </tbody>
  `;
}

/* =========================
   Charts
   ========================= */
function renderChipsChart(derived, summary){
  const canvas = document.getElementById("chartChips");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const ev = (derived.events||[]);
  if(!ev.length){ clearChart(ctx,w,h); return; }

  const chips = ev.map(r=>r.chips).filter(v=>typeof v==="number");
  const yMin = Math.min(...chips, 0);
  const yMax = Math.max(...chips, 1);

  clearChart(ctx,w,h);
  drawAxes(ctx,w,h,pad,"Event","Chips",yMin,yMax);

  const xs = ev.map((r,i)=> i/(Math.max(1,ev.length-1)));
  const ys = ev.map(r=> (typeof r.chips==="number"?r.chips:yMin));
  drawLineScaled(ctx,w,h,pad,xs,ys,yMin,yMax,"rgba(125,211,252,0.9)");

  const markers = [];
  const labels = [];
  const loanId = summary?.markers?.loanEventId;
  const merchId = summary?.markers?.merchantEnterId;
  const bossStartIds = summary?.markers?.bossMatchStartIds || [];

  function addMarker(eventId, label){
    if(eventId===null || eventId===undefined) return;
    const idx = ev.findIndex(r=>String(r.id)===String(eventId));
    if(idx>=0){
      markers.push(idx/(Math.max(1,ev.length-1)));
      labels.push(label);
    }
  }
  addMarker(loanId, "Loan");
  addMarker(merchId, "Merchant");
  bossStartIds.slice(0,3).forEach(id=> addMarker(id, "Boss"));
  if(markers.length) drawMarkers(ctx,w,h,pad,markers,labels);
}

function renderProfitChart(derived){
  const canvas = document.getElementById("chartProfit");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const matches = derived.matches||[];
  if(!matches.length){ clearChart(ctx,w,h); return; }

  const vals = matches.map(m=>num(m.matchProfit));
  const yMin = Math.min(0, ...vals);
  const yMax = Math.max(1, ...vals);

  clearChart(ctx,w,h);
  drawAxes(ctx,w,h,pad,"Match","Chips",yMin,yMax);

  const labels = matches.map(m=>String(m.matchIndex));
  drawBarChart(ctx,w,h,pad,vals,labels,yMin,yMax);
}

function renderDeckChart(derived){
  const canvas = document.getElementById("chartDeck");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const deck = derived.deck||[];
  if(deck.length<2){ clearChart(ctx,w,h); return; }

  const deckSizes = deck.map(d=>d.deckSize).filter(v=>typeof v==="number");
  const modCounts = deck.map(d=>d.modCount).filter(v=>typeof v==="number");
  if(!deckSizes.length){ clearChart(ctx,w,h); return; }

  const yMinL = Math.min(...deckSizes);
  const yMaxL = Math.max(...deckSizes);
  const yMinR = modCounts.length ? Math.min(...modCounts) : 0;
  const yMaxR = modCounts.length ? Math.max(...modCounts) : 1;

  clearChart(ctx,w,h);
  drawAxesDualY(ctx,w,h,pad,"Event","Deck size",yMinL,yMaxL,"Mod count",yMinR,yMaxR);

  const xs = deck.map((d,i)=> i/(Math.max(1,deck.length-1)));
  const ysL = deck.map(d=> (typeof d.deckSize==="number"?d.deckSize:yMinL));
  drawLineScaled(ctx,w,h,pad,xs,ysL,yMinL,yMaxL,"rgba(125,211,252,0.9)");

  if(modCounts.length){
    const ysR = deck.map(d=> (typeof d.modCount==="number"?d.modCount:yMinR));
    drawLineScaled(ctx,w,h,pad,xs,ysR,yMinR,yMaxR,"rgba(251,191,36,0.85)",[6,4]);
  }
}

function drawRadarChart(ctx, w, h, pad, labels, values){
  const cx = w/2;
  const cy = h/2;
  const radius = Math.min(w, h)/2 - pad;
  const n = labels.length;
  if(!n) return;

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.fillStyle = "rgba(125,211,252,0.18)";
  ctx.lineWidth = 1;

  // grid rings
  for(let r=0;r<=4;r++){
    const rr = radius * (r/4);
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a = (Math.PI*2*i/n) - Math.PI/2;
      const x = cx + rr * Math.cos(a);
      const y = cy + rr * Math.sin(a);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // axes + labels
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  for(let i=0;i<n;i++){
    const a = (Math.PI*2*i/n) - Math.PI/2;
    const x = cx + radius * Math.cos(a);
    const y = cy + radius * Math.sin(a);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.stroke();
    const lx = cx + (radius + 10) * Math.cos(a);
    const ly = cy + (radius + 10) * Math.sin(a);
    ctx.fillText(labels[i], lx - 14, ly + 4);
  }

  // value polygon
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const a = (Math.PI*2*i/n) - Math.PI/2;
    const v = clamp01(values[i] ?? 0);
    const x = cx + (radius * v) * Math.cos(a);
    const y = cy + (radius * v) * Math.sin(a);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(125,211,252,0.85)";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();
}

function renderFingerprint(analysis){
  const canvas = document.getElementById("chartFingerprint");
  if(!canvas) return;
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 32;

  const ps = analysis.summary.playstyle;
  if(!ps){ clearChart(ctx,w,h); return; }
  const labels = ["Risk","Pressure","Control","Surgery","Engine","Karma","Actions","Economy"];
  const values = [
    ps.axes.risk, ps.axes.pressure, ps.axes.control, ps.axes.surgery,
    ps.axes.engine, ps.axes.karma, ps.axes.actions, ps.axes.economy
  ].map(v=>num(v)/100);

  clearChart(ctx,w,h);
  drawRadarChart(ctx,w,h,pad,labels,values);

  const meta = document.getElementById("fingerprintMeta");
  const notes = document.getElementById("fingerprintNotes");
  const confidence = Math.round((ps.confidence||0)*100);
  const secondary = ps.secondary && ps.secondary.name !== "None" ? ` • Secondary: ${ps.secondary.name}` : "";
  meta.innerHTML = `
    <div class="goodBox">
      <div style="font-weight:700">Primary: ${escapeHTML(ps.primary?.name || "Unknown")}${secondary}</div>
      <div class="tiny">Confidence: ${confidence}%</div>
      <ul style="margin:6px 0 0 16px">${ps.drivers.map(d=>`<li>${escapeHTML(d)}</li>`).join("")}</ul>
    </div>
  `;
  notes.innerHTML = ps.notes.map(n=>`• ${escapeHTML(n.text)}`).join("<br/>");
}

function renderProgressionChart(derived, summary){
  const canvas = document.getElementById("chartProgression");
  if(!canvas) return;
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const matches = derived.matches || [];
  if(!matches.length){ clearChart(ctx,w,h); return; }

  const xs = matches.map((m,i)=> i/(Math.max(1, matches.length-1)));
  const karmaSeries = matches.map(m=>numOrNull(m.karmaGained));
  let karmaAccum = 0;
  const karmaTotal = karmaSeries.map(v=>{
    if(typeof v==="number") karmaAccum += v;
    return karmaAccum || summary.startKarma || 0;
  });
  const callingSeries = derived.deckTimeline && derived.deckTimeline.length
    ? derived.deckTimeline.map(d=>numOrNull(d.callingRankValue)).filter(v=>v!==null)
    : [];
  const tokensSeries = matches.map(m=>typeof m.tokensTotal==="number" ? m.tokensTotal : null);

  const yVals = [...karmaTotal, ...callingSeries, ...tokensSeries].filter(v=>typeof v==="number");
  if(!yVals.length){ clearChart(ctx,w,h); return; }
  const yMin = Math.min(0, ...yVals);
  const yMax = Math.max(1, ...yVals);

  clearChart(ctx,w,h);
  drawAxes(ctx,w,h,pad,"Match","Value",yMin,yMax);
  drawLineScaled(ctx,w,h,pad,xs,karmaTotal,yMin,yMax,"rgba(52,211,153,0.9)");
  drawLineScaled(ctx,w,h,pad,xs,tokensSeries.map(v=>typeof v==="number"?v:yMin),yMin,yMax,"rgba(125,211,252,0.85)");

  if(callingSeries.length){
    const callXs = callingSeries.map((_,i)=> i/(Math.max(1, callingSeries.length-1)));
    drawLineScaled(ctx,w,h,pad,callXs,callingSeries,yMin,yMax,"rgba(251,191,36,0.85)",[6,4]);
  }

  document.getElementById("progressionCaption").textContent =
    `matches=${matches.length} • karma points from ${fmt(summary.startKarma)} → ${fmt(summary.endKarma)} • tokens shown at match start`;
}

function renderDeckIdentity(derived, summary){
  const deckTimeline = derived.deckTimeline || [];
  const deckEnd = deckTimeline.length ? deckTimeline[deckTimeline.length-1] : null;
  if(!deckEnd || !deckEnd.bySuit || !deckEnd.byRank){
    const suitCanvas = document.getElementById("chartDeckSuit");
    const rankCanvas = document.getElementById("chartDeckRank");
    if(suitCanvas) clearChart(setupCanvas(suitCanvas), suitCanvas.clientWidth, suitCanvas.clientHeight);
    if(rankCanvas) clearChart(setupCanvas(rankCanvas), rankCanvas.clientWidth, rankCanvas.clientHeight);
    return;
  }
  const suitCanvas = document.getElementById("chartDeckSuit");
  const rankCanvas = document.getElementById("chartDeckRank");
  const suitCtx = setupCanvas(suitCanvas);
  const rankCtx = setupCanvas(rankCanvas);
  const pad = 36;

  const suitLabels = Object.keys(deckEnd.bySuit);
  const suitValues = suitLabels.map(k=>deckEnd.bySuit[k]);
  const suitMax = Math.max(...suitValues, 1);
  clearChart(suitCtx, suitCanvas.clientWidth, suitCanvas.clientHeight);
  drawAxes(suitCtx, suitCanvas.clientWidth, suitCanvas.clientHeight, pad, "", "Count", 0, suitMax);
  drawBarChart(suitCtx, suitCanvas.clientWidth, suitCanvas.clientHeight, pad, suitValues, suitLabels, 0, suitMax);

  const rankLabels = Object.keys(deckEnd.byRank);
  const rankValues = rankLabels.map(k=>deckEnd.byRank[k]);
  const rankMax = Math.max(...rankValues, 1);
  clearChart(rankCtx, rankCanvas.clientWidth, rankCanvas.clientHeight);
  drawAxes(rankCtx, rankCanvas.clientWidth, rankCanvas.clientHeight, pad, "", "Count", 0, rankMax);
  drawBarChart(rankCtx, rankCanvas.clientWidth, rankCanvas.clientHeight, pad, rankValues, rankLabels, 0, rankMax);

  const suitHhi = herfindahl(deckEnd.bySuit);
  const domSuit = suitValues.length ? Math.max(...suitValues) / Math.max(1, suitValues.reduce((a,b)=>a+b,0)) : null;
  const modDensity = summary.modDensityEnd ?? null;
  const fused = deckEnd.fusedCount ?? deckEnd.summary?.fusedCount ?? null;
  const sleeved = deckEnd.sleevedCount ?? deckEnd.summary?.sleevedCount ?? null;
  const stamps = deckEnd.summary?.stampsByRank ? Object.keys(deckEnd.summary.stampsByRank).length : null;
  document.getElementById("deckIdentityMeta").textContent =
    `Suit HHI ${fmt(suitHhi)} • Dominant suit ${pct(domSuit)} • Mod density ${pct(modDensity)} • Stamps ${fmt(stamps)} • Sleeves ${fmt(sleeved)} • Fuses ${fmt(fused)}`;
}

function renderKeyMoments(analysis){
  const events = analysis.derived.events || [];
  const matches = analysis.derived.matches || [];
  const deckTimeline = analysis.derived.deckTimeline || [];
  const items = [];

  const biggest = analysis.summary.biggestDrop;
  if(biggest && biggest.delta < 0){
    items.push(`Biggest drop: ${fmt(biggest.delta)} on floor ${fmt(biggest.floor)} (event ${escapeHTML(biggest.eventId)})`);
  }

  const firstOf = (type)=> events.find(e=>e.type===type);
  const firstLoan = firstOf("LOAN_TAKEN");
  const firstMerchant = firstOf("MERCHANT_ENTER");
  const firstCollector = firstOf("COLLECTOR_BUY");
  const firstModify = firstOf("MODIFY_APPLY") || firstOf("MODIFY_SERVICE_SELECT");
  const firstBoss = events.find(e=>e.type==="MATCH_START" && String(e.tableType||"").toUpperCase()==="BOSS");

  if(firstLoan) items.push(`First loan: floor ${fmt(firstLoan.floor)} (event ${escapeHTML(firstLoan.id)})`);
  if(firstMerchant) items.push(`First merchant: floor ${fmt(firstMerchant.floor)} (event ${escapeHTML(firstMerchant.id)})`);
  if(firstCollector) items.push(`First collector: floor ${fmt(firstCollector.floor)} (event ${escapeHTML(firstCollector.id)})`);
  if(firstModify) items.push(`First modify: floor ${fmt(firstModify.floor)} (event ${escapeHTML(firstModify.id)})`);
  if(firstBoss) items.push(`First boss table: floor ${fmt(firstBoss.floor)} (match ${fmt(firstBoss.matchIndex)})`);

  deckTimeline.slice(1).forEach(d=>{
    if(d.reason){
      items.push(`Deck change: ${escapeHTML(d.reason)} on floor ${fmt(d.floor)}`);
    }
  });

  matches.filter(m=>String(m.tableType||"").toUpperCase()==="BOSS").forEach(m=>{
    items.push(`Boss outcome: floor ${fmt(m.floor)} match ${fmt(m.matchIndex)} → ${escapeHTML(m.outcome||"—")}`);
  });

  const box = document.getElementById("keyMomentsList");
  box.innerHTML = items.length ? `<ul style="margin:0 0 0 18px">${items.slice(0,12).map(i=>`<li>${i}</li>`).join("")}</ul>` : `<div class="muted">No key moments detected.</div>`;
}

function renderRatesChart(derived, mode, basis){
  const canvas = document.getElementById("chartRates");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const lanes = derived.lanes||[];
  const matches = derived.matches||[];
  if(!lanes.length && !matches.length){ clearChart(ctx,w,h); return; }

  const keyFn = (mode==="floor") ? (x=>String(x.floor ?? "—")) : (x=>String(x.tableType ?? "—"));

  // Build groups
  const groupsSet = new Set();
  if(mode==="floor"){
    lanes.forEach(l=>groupsSet.add(String(l.floor ?? "—")));
    matches.forEach(m=>groupsSet.add(String(m.floor ?? "—")));
  } else {
    lanes.forEach(l=>groupsSet.add(String(l.tableType ?? "—")));
    matches.forEach(m=>groupsSet.add(String(m.tableType ?? "—")));
  }

  const groups = [...groupsSet].sort((a,b)=>{
    const na = Number(a), nb = Number(b);
    if(!Number.isNaN(na) && !Number.isNaN(nb)) return na-nb;
    return a.localeCompare(b);
  });

  const bust = [];
  const rate21 = [];
  const win = [];
  const push = [];
  const loss = [];
  const captionParts = [];

  groups.forEach(g=>{
    const lG = lanes.filter(l=>keyFn(l)===g);
    const mG = matches.filter(m=>keyFn(m)===g);

    const ln = lG.length || 0;
    const mn = mG.length || 0;

    // bust/21 always lane based (but labeled in subtitle/caption)
    bust.push(ln ? (lG.filter(x=>x.playerBust===true).length / ln) : 0);
    rate21.push(ln ? (lG.filter(x=>x.playerTotal===21).length / ln) : 0);

    if(basis==="lane"){
      win.push(ln ? (lG.filter(x=>x.outcome==="WIN").length / ln) : 0);
      push.push(ln ? (lG.filter(x=>x.outcome==="PUSH").length / ln) : 0);
      loss.push(ln ? (lG.filter(x=>x.outcome==="LOSS").length / ln) : 0);
      captionParts.push(`${g}: n=${ln} lanes`);
    } else {
      win.push(mn ? (mG.filter(x=>x.outcome==="WIN").length / mn) : 0);
      push.push(mn ? (mG.filter(x=>x.outcome==="PUSH").length / mn) : 0);
      loss.push(mn ? (mG.filter(x=>x.outcome==="LOSS").length / mn) : 0);
      captionParts.push(`${g}: n=${mn} matches (lanes=${ln})`);
    }
  });

  document.getElementById("ratesSub").textContent =
    basis==="lane"
      ? "Lane outcomes + lane bust/21 (good for hand-level tuning)."
      : "Match outcomes (win/loss/push) + lane bust/21 (useful for progression gates).";

  document.getElementById("ratesCaption").textContent = captionParts.join(" • ");

  clearChart(ctx,w,h);
  drawGroupedRates(ctx,w,h,pad,groups,[
    {name:"Bust", values:bust},
    {name:"21", values:rate21},
    {name:(basis==="lane"?"Win":"Win"), values:win},
    {name:(basis==="lane"?"Push":"Push"), values:push},
    {name:(basis==="lane"?"Loss":"Loss"), values:loss},
  ]);
}

function renderTotalsChart(derived){
  const canvas = document.getElementById("chartTotals");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const lanes = derived.lanes||[];
  if(!lanes.length){ clearChart(ctx,w,h); return; }

  const p = lanes.map(l=>numOrNull(l.playerTotal)).filter(v=>typeof v==="number");
  const d = lanes.map(l=>numOrNull(l.dealerTotal)).filter(v=>typeof v==="number");
  if(!p.length || !d.length){ clearChart(ctx,w,h); return; }

  const minV = Math.min(Math.min(...p), Math.min(...d));
  const maxV = Math.max(Math.max(...p), Math.max(...d));

  clearChart(ctx,w,h);
  drawHistogramOverlay(ctx,w,h,pad,p,d, Math.floor(minV), Math.ceil(maxV));
}

function renderSinksChart(derived){
  const canvas = document.getElementById("chartSinks");
  const ctx = setupCanvas(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 42;

  const sinks = derived.sinks||[];
  if(!sinks.length){ clearChart(ctx,w,h); return; }

  const agg = {};
  sinks.forEach(s=>{
    const cat = s.category || "Other";
    agg[cat] = (agg[cat]||0) + s.delta; // negative
  });
  const entries = Object.entries(agg)
    .sort((a,b)=> Math.abs(b[1]) - Math.abs(a[1]))
    .slice(0,8);

  const labels = entries.map(e=>e[0]);
  const vals = entries.map(e=>e[1]); // negative
  const yMin = Math.min(...vals, 0);
  const yMax = 0;

  clearChart(ctx,w,h);
  drawAxes(ctx,w,h,pad,"","Chips (negative)",yMin,yMax);
  drawBarChart(ctx,w,h,pad,vals,labels,yMin,yMax);

  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText("Largest negative deltas by category", pad, pad-10);
  ctx.restore();
}

/* =========================
   Insights
   ========================= */
function renderInsights(analysis, runRec){
  const s = analysis.summary;
  const settings = DB.settings || defaultSettings;

  const insights = [];

  if(typeof s.bonusShare === "number" && s.bonusShare > settings.bonusDominance){
    insights.push({
      kind:"warn",
      title:`Bonus chips dominate EV (${pct(s.bonusShare)} of match profit)`,
      body:`If wins should matter more than bonuses, tighten the trigger (natural-only), add per-match caps, or add diminishing returns.`
    });
  } else if(typeof s.bonusShare === "number"){
    insights.push({
      kind:"good",
      title:`Bonus share is ${pct(s.bonusShare)} of match profit`,
      body:`Within default non-dominant band (≤ ${pct(settings.bonusDominance)}).`
    });
  }

  if(typeof s.merchantShare === "number" && s.merchantShare > settings.merchantDominance){
    insights.push({
      kind:"warn",
      title:`Merchant sinks dominate spending (${pct(s.merchantShare)} of all spend)`,
      body:`Deck surgery is likely the main power lever. Consider removal caps, escalating removal cost, or gating removals by risk.`
    });
  }

  if(typeof s.player21Rate==="number" && typeof s.playerBustRate==="number"){
    if(s.player21Rate > settings.solved21Rate && s.playerBustRate < settings.solvedBustRate){
      insights.push({
        kind:"warn",
        title:`Control looks high (21 rate ${pct(s.player21Rate)} + bust rate ${pct(s.playerBustRate)})`,
        body:`This resembles a “solved” distribution. Tune: reduce modifier density, limit thinning, or increase dealer pressure/boss constraints.`
      });
    }
  }

  if(typeof s.startChips==="number" && typeof s.chipsLow==="number"){
    const frac = s.chipsLow / (s.startChips||1);
    if(frac < settings.earlyCliffFrac){
      insights.push({
        kind:"bad",
        title:`Early bankroll cliff: chipsLow ${fmt(s.chipsLow)} (${pct(frac)} of start)`,
        body:`If common, early buy-ins are too punishing. Consider smoothing high-stakes density or adding early safety valves.`
      });
    }
  }

  // Boss strictness hint
  const matches = analysis.derived.matches||[];
  const lanes = analysis.derived.lanes||[];
  const bossMatches = matches.filter(m=>String(m.tableType||"").toUpperCase()==="BOSS");
  bossMatches.forEach(m=>{
    if(m.outcome==="LOSS"){
      const lm = lanes.filter(l=>l.matchIndex===m.matchIndex);
      const n = lm.length || 1;
      const pushes = lm.filter(l=>l.outcome==="PUSH").length / n;
      const wins = lm.filter(l=>l.outcome==="WIN").length;
      const losses = lm.filter(l=>l.outcome==="LOSS").length;

      if(pushes >= 0.5 && wins >= losses){
        insights.push({
          kind:"warn",
          title:`Boss loss with many pushes (push share ${pct(pushes)})`,
          body:`Boss rule may require strict lane wins (pushes don’t help). If unintended, add push tiebreaks or alternate boss pressure.`
        });
      }
    }
  });

  if(typeof s.deckSizeEnd==="number" && typeof s.modCountEnd==="number"){
    insights.push({
      kind:"good",
      title:`Deck end: size ${fmt(s.deckSizeEnd)}, mods ${fmt(s.modCountEnd)} (density ${pct(s.modDensityEnd)})`,
      body:`Track this across configs to see how quickly players reach high control states.`
    });
  }

  if(s.runOutcome && s.runOutcome.source==="INFER"){
    insights.push({
      kind:"warn",
      title:`Run outcome is inferred (no RUN_END event detected)`,
      body:`Add a final RUN_END telemetry event (result + reason + matchIndex) for fully reliable analytics.`
    });
  }

  if(s.playstyle && s.playstyle.notes && s.playstyle.notes.length){
    s.playstyle.notes.slice(0,3).forEach(n=>{
      insights.push({
        kind: n.kind==="warn" ? "warn" : "good",
        title:`Playstyle note`,
        body:n.text
      });
    });
  }

  if(!insights.length){
    insights.push({kind:"good", title:"No strong heuristic flags triggered.", body:"Use per-floor table + match/lane drilldowns to spot-check anomalies."});
  }

  const box = document.getElementById("insightsBox");
  box.innerHTML = insights.map(i=>{
    const cls = i.kind==="good" ? "goodBox" : i.kind==="bad" ? "badBox" : "warnBox";
    return `<div class="${cls}" style="margin-bottom:10px">
      <div style="font-weight:700; margin-bottom:4px">${escapeHTML(i.title)}</div>
      <div class="tiny">${escapeHTML(i.body)}</div>
    </div>`;
  }).join("");
}

/* =========================
   Tables
   ========================= */
function renderMatchTable(rows){
  const el = document.getElementById("matchTable");
  if(!rows.length){
    el.innerHTML = `<tr><td class="muted">No match rows.</td></tr>`;
    return;
  }
  const cols = [
    ["matchIndex","#"],
    ["floor","Floor"],
    ["tableType","Type"],
    ["outcome","Outcome"],
    ["buyIn","BuyIn"],
    ["payout","Payout"],
    ["bonusChips","Bonus"],
    ["transferNet","Transfer"],
    ["transferMultiplier","Xfer Mult"],
    ["rake","Rake"],
    ["karmaGained","Karma +"],
    ["matchProfit","Profit"],
    ["tokensTotal","Tokens"],
    ["turns","Turns"],
    ["deckSizeStart","DeckS"],
    ["deckSizeEnd","DeckE"]
  ];
  el.innerHTML = `
    <thead><tr>${cols.map(c=>`<th>${escapeHTML(c[1])}</th>`).join("")}</tr></thead>
    <tbody>
      ${rows.map(r=>`<tr>${cols.map(c=>`<td>${escapeHTML(fmt(r[c[0]]))}</td>`).join("")}</tr>`).join("")}
    </tbody>
  `;
}
function renderLaneTable(rows){
  const el = document.getElementById("laneTable");
  if(!rows.length){
    el.innerHTML = `<tr><td class="muted">No lane rows.</td></tr>`;
    return;
  }
  const cols = [
    ["matchIndex","Match"],
    ["floor","Floor"],
    ["tableType","Type"],
    ["lane","Lane"],
    ["playerTotal","P.Total"],
    ["playerBust","P.Bust"],
    ["dealerTotal","D.Total"],
    ["dealerBust","D.Bust"],
    ["outcome","Outcome"]
  ];
  el.innerHTML = `
    <thead><tr>${cols.map(c=>`<th>${escapeHTML(c[1])}</th>`).join("")}</tr></thead>
    <tbody>
      ${rows.slice(0,350).map(r=>`<tr>${cols.map(c=>`<td>${escapeHTML(fmt(r[c[0]]))}</td>`).join("")}</tr>`).join("")}
    </tbody>
  `;
}

/* =========================
   CSV export
   ========================= */
function toCSV(rows, cols){
  const esc = (v)=>{
    const s = (v===null || v===undefined) ? "" : String(v);
    if(/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const header = cols.map(c=>esc(c[1])).join(",");
  const lines = rows.map(r=>{
    return cols.map(c=>{
      const key = c[0];
      const v = (typeof c[2]==="function") ? c[2](r) : r[key];
      return esc(v);
    }).join(",");
  });
  return [header, ...lines].join("\n");
}
function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* Dashboard export buttons */
document.getElementById("btnExportMatchesCSV").addEventListener("click", ()=>{
  if(!currentRunId) return;
  const rr = getRunRecord(currentRunId);
  if(!rr) return;
  const a = getRunAnalysis(rr);
  const rows = a.derived.matches||[];
  const cols = [
    ["matchIndex","matchIndex"],
    ["floor","floor"],
    ["tableType","tableType"],
    ["outcome","outcome"],
    ["buyIn","buyIn"],
    ["payout","payout"],
    ["bonusChips","bonusChips"],
    ["transferNet","transferNet"],
    ["transferMultiplier","transferMultiplier"],
    ["rake","rake"],
    ["rakeRate","rakeRate"],
    ["karmaGained","karmaGained"],
    ["exhaustion","exhaustion"],
    ["matchProfit","matchProfit"],
    ["tokensTotal","tokensTotal"],
    ["baseTokens","baseTokens"],
    ["bankedTokensUsed","bankedTokensUsed"],
    ["bankedTokensRemaining","bankedTokensRemaining"],
    ["turns","turns"],
    ["playerBustsFinal","playerBustsFinal"],
    ["dealerBustsFinal","dealerBustsFinal"],
    ["deckSizeStart","deckSizeStart"],
    ["deckSizeEnd","deckSizeEnd"]
  ];
  downloadText(`p63_matches_${currentRunId}.csv`, toCSV(rows, cols));
});
document.getElementById("btnExportLanesCSV").addEventListener("click", ()=>{
  if(!currentRunId) return;
  const rr = getRunRecord(currentRunId);
  if(!rr) return;
  const a = getRunAnalysis(rr);
  const rows = a.derived.lanes||[];
  const cols = [
    ["matchIndex","matchIndex"],
    ["floor","floor"],
    ["tableType","tableType"],
    ["lane","lane"],
    ["playerTotal","playerTotal"],
    ["playerBust","playerBust"],
    ["dealerTotal","dealerTotal"],
    ["dealerBust","dealerBust"],
    ["outcome","outcome"]
  ];
  downloadText(`p63_lanes_${currentRunId}.csv`, toCSV(rows, cols));
});

document.getElementById("btnExportFeedbackCSV").addEventListener("click", ()=>{
  const runs = Object.values(DB.runs);

  const rows = runs.map(r=>{
    const fb = getFeedbackForRun(r);
    const startedAt = r.meta.startedAtISO || r.summary?.startedAtISO || r.meta.importedAtISO || null;
    const cfgName = DB.configs[r.meta.configId]?.name || "(No config)";
    const outcome = r.summary?.runOutcome || {};

    return {
      runId: r.meta.runId,
      startedAtISO: startedAt,
      importedAtISO: r.meta.importedAtISO || null,
      sourceFilename: r.meta.sourceFilename || null,
      sessionId: r.meta.sessionId || null,
      logVersion: r.meta.logVersion || null,
      configId: r.meta.configId || null,
      configName: cfgName,
      tags: (r.meta.tags || []).join("; "),
      notes: r.meta.notes || "",
      outcomeResult: outcome.result || "",
      outcomeReason: outcome.reason || "",
      endFloor: outcome.floor ?? r.summary?.floorsReached ?? "",
      endChips: outcome.chips ?? r.summary?.endChips ?? "",
      endKarma: r.summary?.endKarma ?? "",
      feedbackUpdatedAtISO: fb.updatedAtISO || fb.lastUpdateISO || "",
      feedbackEdits: fb.updatesCount ?? "",
      comments: fb.comments || "",
      bugs: fb.bugs || ""
    };
  }).sort((a,b)=>{
    const ta = new Date(a.startedAtISO||0).getTime();
    const tb = new Date(b.startedAtISO||0).getTime();
    return tb - ta;
  });

  const cols = [
    ["runId","runId"],
    ["startedAtISO","startedAtISO"],
    ["importedAtISO","importedAtISO"],
    ["sourceFilename","sourceFilename"],
    ["sessionId","sessionId"],
    ["logVersion","logVersion"],
    ["configId","configId"],
    ["configName","configName"],
    ["tags","tags"],
    ["notes","notes"],
    ["outcomeResult","outcomeResult"],
    ["outcomeReason","outcomeReason"],
    ["endFloor","endFloor"],
    ["endChips","endChips"],
    ["endKarma","endKarma"],
    ["feedbackUpdatedAtISO","feedbackUpdatedAtISO"],
    ["feedbackEdits","feedbackEdits"],
    ["comments","comments"],
    ["bugs","bugs"]
  ];

  const day = new Date().toISOString().slice(0,10);
  downloadText(`p63_feedback_all_${day}.csv`, toCSV(rows, cols));
});

document.getElementById("btnExportFloorCSV").addEventListener("click", ()=>{
  if(!currentRunId) return;
  const rr = getRunRecord(currentRunId);
  if(!rr) return;
  const a = getRunAnalysis(rr);
  const rows = a.derived.floorSummary||[];
  const cols = [
    ["floor","floor"],
    ["matches","matches"],
    ["matchWinRate","matchWinRate"],
    ["matchPushRate","matchPushRate"],
    ["avgBuyIn","avgBuyIn"],
    ["avgPayout","avgPayout"],
    ["avgProfit","avgProfit"],
    ["profitSd","profitSd"],
    ["tableMix","tableMix"],
    ["lanes","lanes"],
    ["laneWinRate","laneWinRate"],
    ["lanePushRate","lanePushRate"],
    ["laneLossRate","laneLossRate"],
    ["bustRate","bustRate"],
    ["rate21","rate21"],
    ["avgPlayerTotal","avgPlayerTotal"],
    ["avgDealerTotal","avgDealerTotal"],
    ["avgPlayerTotalNoBust","avgPlayerTotalNoBust"],
    ["avgDealerTotalNoBust","avgDealerTotalNoBust"],
    ["bustTotalAvg","bustTotalAvg"],
    ["avgSwing","avgSwing"],
    ["deckStart","deckStart"],
    ["deckEnd","deckEnd"],
    ["modsStart","modsStart"],
    ["modsEnd","modsEnd"],
    ["modDensityStart","modDensityStart"],
    ["modDensityEnd","modDensityEnd"],
    ["topSpend","topSpend"]
  ];
  downloadText(`p63_floor_summary_${currentRunId}.csv`, toCSV(rows, cols));
});

/* =========================
   Runs table + filtering + compare
   ========================= */
document.getElementById("filterConfig").addEventListener("change", renderRunsTable);
document.getElementById("filterTag").addEventListener("input", renderRunsTable);
document.getElementById("filterSearch").addEventListener("input", renderRunsTable);
document.getElementById("filterArchetype").addEventListener("change", renderRunsTable);
document.getElementById("btnRecomputeAll").addEventListener("click", ()=>{
  Object.keys(DB.runs).forEach(runId=>{
    const rr = DB.runs[runId];
    if(rr.rawLog){
      const parsed = safeParseJSON(rr.rawLog);
      if(parsed.ok){
        const a = analyzeLog(parsed.value);
        rr.summary = a.summary;
        if(rr.derived) rr.derived = a.derived;
      }
    }
  });
  saveDB();
  renderRunsTable();
});

function getDeep(obj, path){
  return path.split(".").reduce((o,k)=> (o && o[k]!==undefined)?o[k]:null, obj);
}

function refreshCompareSelects(runList){
  const aSel = document.getElementById("cmpA");
  const bSel = document.getElementById("cmpB");
  const opts = runList.map(r=>{
    const label = `${r.meta.sourceFilename || r.meta.runId} • ${r.summary?.runOutcome?.result||"?"} • F${r.summary?.floorsReached??"—"} • Net ${fmt(r.summary?.netChips)}`;
    return `<option value="${escapeHTML(r.meta.runId)}">${escapeHTML(label)}</option>`;
  }).join("");
  aSel.innerHTML = opts;
  bSel.innerHTML = opts;
  if(runList.length>=2){
    aSel.value = runList[0].meta.runId;
    bSel.value = runList[1].meta.runId;
  } else if(runList.length===1){
    aSel.value = runList[0].meta.runId;
    bSel.value = runList[0].meta.runId;
  }
}

document.getElementById("btnCompare").addEventListener("click", ()=>{
  const aId = document.getElementById("cmpA").value;
  const bId = document.getElementById("cmpB").value;
  const a = DB.runs[aId], b = DB.runs[bId];
  if(!a || !b) return;
  const out = compareRuns(a.summary, b.summary);
  document.getElementById("compareOut").innerHTML = out;
});
document.getElementById("btnSwapCompare").addEventListener("click", ()=>{
  const aSel = document.getElementById("cmpA");
  const bSel = document.getElementById("cmpB");
  const t = aSel.value;
  aSel.value = bSel.value;
  bSel.value = t;
});

function compareRuns(A, B){
  const rows = [
    ["Archetype", A?.playstyle?.primary?.name || "—", B?.playstyle?.primary?.name || "—"],
    ["Outcome", A?.runOutcome?.result, B?.runOutcome?.result],
    ["Floors", A?.floorsReached, B?.floorsReached],
    ["Matches", A?.matches, B?.matches],
    ["Net chips", A?.netChips, B?.netChips],
    ["Player bust rate", pct(A?.playerBustRate), pct(B?.playerBustRate)],
    ["Player 21 rate", pct(A?.player21Rate), pct(B?.player21Rate)],
    ["Bonus share", pct(A?.bonusShare), pct(B?.bonusShare)],
    ["Merchant share", pct(A?.merchantShare), pct(B?.merchantShare)],
    ["Deck end size", A?.deckSizeEnd, B?.deckSizeEnd],
    ["Mod density end", pct(A?.modDensityEnd), pct(B?.modDensityEnd)],
    ["Profit total", A?.matchProfitTotal, B?.matchProfitTotal],
    ["Profit sd", A?.profitStdDev, B?.profitStdDev]
  ];
  const axesA = A?.playstyle?.axes || {};
  const axesB = B?.playstyle?.axes || {};
  const axisKeys = ["risk","pressure","control","surgery","engine","karma","actions","economy"];
  const axisRows = axisKeys.map(k=>{
    const aV = axesA[k];
    const bV = axesB[k];
    const delta = (typeof aV==="number" && typeof bV==="number") ? (aV - bV) : null;
    return [k, aV, bV, delta];
  });
  return `
    <div class="tableWrap">
      <table>
        <thead><tr><th>Metric</th><th>A</th><th>B</th></tr></thead>
        <tbody>
          ${rows.map(r=>`<tr><td>${escapeHTML(r[0])}</td><td>${escapeHTML(fmt(r[1]))}</td><td>${escapeHTML(fmt(r[2]))}</td></tr>`).join("")}
        </tbody>
      </table>
    </div>
    <div class="tableWrap" style="margin-top:10px">
      <table>
        <thead><tr><th>Axis</th><th>A</th><th>B</th><th>Δ (A−B)</th></tr></thead>
        <tbody>
          ${axisRows.map(r=>`<tr><td>${escapeHTML(r[0])}</td><td>${escapeHTML(fmt(r[1]))}</td><td>${escapeHTML(fmt(r[2]))}</td><td>${escapeHTML(fmt(r[3]))}</td></tr>`).join("")}
        </tbody>
      </table>
    </div>
  `;
}

function refreshArchetypeFilter(runs){
  const sel = document.getElementById("filterArchetype");
  if(!sel) return;
  const current = sel.value || "all";
  const names = [...new Set(runs.map(r=>r.summary?.playstyle?.primary?.name).filter(Boolean))].sort();
  sel.innerHTML = `<option value="all">All archetypes</option>` +
    names.map(n=>`<option value="${escapeHTML(n)}">${escapeHTML(n)}</option>`).join("");
  if(names.includes(current)) sel.value = current;
}

function renderRunsTable(){
  refreshConfigSelects();

  const cfgFilter = document.getElementById("filterConfig").value || "all";
  const tagFilter = (document.getElementById("filterTag").value || "").toLowerCase().trim();
  const search = (document.getElementById("filterSearch").value || "").toLowerCase().trim();
  const archetypeFilter = (document.getElementById("filterArchetype").value || "all");

  const runs = Object.values(DB.runs);
  refreshArchetypeFilter(runs);

  const filtered = runs.filter(r=>{
    if(cfgFilter!=="all" && String(r.meta.configId)!==String(cfgFilter)) return false;
    if(tagFilter){
      const tags = (r.meta.tags||[]).join(",").toLowerCase();
      if(!tags.includes(tagFilter)) return false;
    }
    if(archetypeFilter!=="all"){
      const aName = r.summary?.playstyle?.primary?.name || "";
      if(aName !== archetypeFilter) return false;
    }
    if(search){
      const hay = [
        r.meta.sourceFilename||"",
        r.meta.sessionId||"",
        r.meta.notes||"",
        r.meta.runId||""
      ].join(" ").toLowerCase();
      if(!hay.includes(search)) return false;
    }
    return true;
  }).sort((a,b)=>{
    const ta = new Date(a.meta.importedAtISO||0).getTime();
    const tb = new Date(b.meta.importedAtISO||0).getTime();
    return tb-ta;
  });

  document.getElementById("runsCount").textContent =
    `${filtered.length} run(s) shown • ${runs.length} total stored`;

  // Update compare selects with current filtered list (or all if filtered empty)
  refreshCompareSelects(filtered.length ? filtered : runs.sort((a,b)=>{
    const ta = new Date(a.meta.importedAtISO||0).getTime();
    const tb = new Date(b.meta.importedAtISO||0).getTime();
    return tb-ta;
  }));

  const el = document.getElementById("runsTable");
  const cols = [
    ["meta.startedAtISO","Started"],
    ["meta.sourceFilename","File"],
    ["meta.configId","Config"],
    ["summary.playstyle.primary.name","Archetype"],
    ["summary.runOutcome.result","Outcome"],
    ["summary.floorsReached","Floors"],
    ["summary.matches","Matches"],
    ["summary.netChips","Net"],
    ["summary.playerBustRate","P.Bust"],
    ["summary.player21Rate","P.21"],
    ["summary.modDensityEnd","ModDen"],
    ["meta.tags","Tags"]
  ];

  el.innerHTML = `
    <thead><tr>
      ${cols.map(c=>`<th>${escapeHTML(c[1])}</th>`).join("")}
      <th>Action</th>
    </tr></thead>
    <tbody>
      ${filtered.map(r=>{
        const cfgName = DB.configs[r.meta.configId]?.name || "(No config)";
        return `<tr>
          <td>${escapeHTML(fmt(r.meta.startedAtISO || r.summary?.startedAtISO || ""))}</td>
          <td title="${escapeHTML(r.meta.runId)}">${escapeHTML(r.meta.sourceFilename || "—")}</td>
          <td>${escapeHTML(cfgName)}</td>
          <td>${escapeHTML(r.summary?.playstyle?.primary?.name || "—")}</td>
          <td>${escapeHTML(r.summary?.runOutcome?.result || "—")}</td>
          <td>${escapeHTML(fmt(r.summary?.floorsReached))}</td>
          <td>${escapeHTML(fmt(r.summary?.matches))}</td>
          <td>${escapeHTML(fmt(r.summary?.netChips))}</td>
          <td>${escapeHTML(pct(r.summary?.playerBustRate))}</td>
          <td>${escapeHTML(pct(r.summary?.player21Rate))}</td>
          <td>${escapeHTML(pct(r.summary?.modDensityEnd))}</td>
          <td title="${escapeHTML((r.meta.tags||[]).join(", "))}">${escapeHTML((r.meta.tags||[]).slice(0,3).join(", ") || "—")}</td>
          <td><button class="btn small primary" data-open="${escapeHTML(r.meta.runId)}">Open</button></td>
        </tr>`;
      }).join("")}
    </tbody>
  `;

  el.querySelectorAll("button[data-open]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-open");
      currentRunId = id;
      setTab("dashboardTab");
      renderDashboard(id);
    });
  });
}

/* =========================
   Configs
   ========================= */
function refreshConfigSelects(){
  const cfgs = Object.values(DB.configs).sort((a,b)=>a.name.localeCompare(b.name));
  const importSel = document.getElementById("importConfigSelect");
  const filterSel = document.getElementById("filterConfig");
  const editSel = document.getElementById("editRunConfig");

  importSel.innerHTML = cfgs.map(c=>`<option value="${escapeHTML(c.configId)}">${escapeHTML(c.name)}</option>`).join("");
  filterSel.innerHTML = `<option value="all">All configs</option>` +
    cfgs.map(c=>`<option value="${escapeHTML(c.configId)}">${escapeHTML(c.name)}</option>`).join("");
  editSel.innerHTML = cfgs.map(c=>`<option value="${escapeHTML(c.configId)}">${escapeHTML(c.name)}</option>`).join("");
}

function renderConfigs(){
  refreshConfigSelects();
  const el = document.getElementById("configsTable");
  const cfgs = Object.values(DB.configs).sort((a,b)=>a.name.localeCompare(b.name));
  el.innerHTML = `
    <thead><tr>
      <th>Name</th><th>Config ID</th><th>Fields</th><th>Action</th>
    </tr></thead>
    <tbody>
      ${cfgs.map(c=>{
        return `<tr>
          <td>${escapeHTML(c.name)}</td>
          <td class="mono">${escapeHTML(c.configId)}</td>
          <td class="mono tiny">${escapeHTML(JSON.stringify(c.fields||{}))}</td>
          <td><button class="btn small primary" data-edit="${escapeHTML(c.configId)}">Edit</button></td>
        </tr>`;
      }).join("")}
    </tbody>
  `;
  el.querySelectorAll("button[data-edit]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-edit");
      openConfigEditor(id);
    });
  });
}

document.getElementById("btnNewConfig").addEventListener("click", ()=>{
  const id = uid("cfg");
  DB.configs[id] = {
    configId: id,
    name: "New config",
    createdAtISO: new Date().toISOString(),
    fields: {}
  };
  saveDB();
  renderConfigs();
  openConfigEditor(id);
});
document.getElementById("btnSaveConfig").addEventListener("click", ()=>{
  if(!currentConfigId) return;
  const name = document.getElementById("cfgName").value.trim() || "Unnamed config";
  const fieldsText = document.getElementById("cfgFields").value.trim() || "{}";
  const parsed = safeParseJSON(fieldsText);
  if(!parsed.ok || typeof parsed.value!=="object" || Array.isArray(parsed.value)){
    document.getElementById("cfgEditorHint").textContent = "Fields must be a JSON object.";
    return;
  }
  DB.configs[currentConfigId].name = name;
  DB.configs[currentConfigId].fields = parsed.value;
  saveDB();
  document.getElementById("cfgEditorHint").textContent = "Saved.";
  renderConfigs();
  refreshConfigSelects();
});
document.getElementById("btnDeleteConfig").addEventListener("click", ()=>{
  if(!currentConfigId) return;
  if(currentConfigId==="cfg_default"){
    document.getElementById("cfgEditorHint").textContent = "Default config cannot be deleted.";
    return;
  }
  if(!confirm("Delete this config? Runs referencing it will keep the configId but name will be missing.")) return;
  delete DB.configs[currentConfigId];
  currentConfigId = null;
  saveDB();
  renderConfigs();
  refreshConfigSelects();
  document.getElementById("cfgName").value = "";
  document.getElementById("cfgFields").value = "";
});
function openConfigEditor(id){
  currentConfigId = id;
  const c = DB.configs[id];
  document.getElementById("cfgName").value = c?.name || "";
  document.getElementById("cfgFields").value = JSON.stringify(c?.fields||{}, null, 2);
  document.getElementById("cfgEditorHint").textContent = `Editing ${id}`;
}

/* =========================
   Settings
   ========================= */
function renderSettings(){
  const s = DB.settings || {...defaultSettings};
  document.getElementById("setBonusDom").value = s.bonusDominance;
  document.getElementById("setMerchantDom").value = s.merchantDominance;
  document.getElementById("setSolved21").value = s.solved21Rate;
  document.getElementById("setSolvedBust").value = s.solvedBustRate;
  document.getElementById("setCliffFrac").value = s.earlyCliffFrac;
  document.getElementById("settingsHint").textContent = "";
}
document.getElementById("btnSaveSettings").addEventListener("click", ()=>{
  DB.settings = {
    bonusDominance: Number(document.getElementById("setBonusDom").value),
    merchantDominance: Number(document.getElementById("setMerchantDom").value),
    solved21Rate: Number(document.getElementById("setSolved21").value),
    solvedBustRate: Number(document.getElementById("setSolvedBust").value),
    earlyCliffFrac: Number(document.getElementById("setCliffFrac").value),
  };
  saveDB();
  document.getElementById("settingsHint").textContent = "Saved.";
});


document.getElementById("fbSearch").addEventListener("input", ()=>{
  if(document.getElementById("feedbackTab").style.display!=="none") renderFeedbackTab();
});
document.getElementById("fbOnlyWithText").addEventListener("change", ()=>{
  if(document.getElementById("feedbackTab").style.display!=="none") renderFeedbackTab();
});

/* =========================
   Edit/Delete run
   ========================= */
const editDlg = document.getElementById("editRunDlg");
document.getElementById("btnEditRun").addEventListener("click", ()=>{
  if(!currentRunId) return;
  const r = DB.runs[currentRunId];
  if(!r) return;
  refreshConfigSelects();
  document.getElementById("editRunConfig").value = r.meta.configId || "cfg_default";
  document.getElementById("editRunTags").value = (r.meta.tags||[]).join(", ");
  document.getElementById("editRunNotes").value = r.meta.notes || "";
  document.getElementById("editRunInfo").textContent = `Run ID: ${currentRunId} • Imported: ${r.meta.importedAtISO || "—"}`;
  editDlg.showModal();
});
document.getElementById("btnCloseFeedbackDlg").addEventListener("click", ()=>{
  document.getElementById("dlgFeedbackView").close();
});
document.getElementById("btnCancelEditRun").addEventListener("click", ()=> editDlg.close());
document.getElementById("btnSaveEditRun").addEventListener("click", ()=>{
  const r = DB.runs[currentRunId];
  if(!r) return;
  r.meta.configId = document.getElementById("editRunConfig").value;
  r.meta.tags = document.getElementById("editRunTags").value.split(",").map(s=>s.trim()).filter(Boolean);
  r.meta.notes = document.getElementById("editRunNotes").value;
  saveDB();
  editDlg.close();
  renderDashboard(currentRunId);
  renderRunsTable();
});
document.getElementById("btnDeleteRun").addEventListener("click", ()=>{
  if(!currentRunId) return;
  if(!confirm("Delete this run from local storage?")) return;
  delete DB.runs[currentRunId];
  saveDB();
  currentRunId = null;
  setTab("runsTab");
});

/* =========================
   Export / Import DB
   ========================= */
document.getElementById("btnExportDB").addEventListener("click", ()=>{
  downloadText("project63_run_analyzer_db.json", JSON.stringify(DB,null,2));
});
document.getElementById("btnImportDB").addEventListener("click", async ()=>{
  const input = document.getElementById("dbImportInput");
  const file = input.files?.[0];
  if(!file){ alert("Choose a DB JSON file first."); return; }
  const text = await file.text();
  const parsed = safeParseJSON(text);
  if(!parsed.ok){ alert("Invalid DB JSON."); return; }
  const incoming = parsed.value;
  if(!incoming || typeof incoming!=="object" || !incoming.runs || !incoming.configs){
    alert("DB file doesn’t look like a P63 analyzer DB.");
    return;
  }
  DB = {
    version: 1,
    runs: {...DB.runs, ...incoming.runs},
    configs: {...DB.configs, ...incoming.configs},
    settings: incoming.settings || DB.settings || {...defaultSettings}
  };
  saveDB();
  refreshConfigSelects();
  renderRunsTable();
  alert("DB imported/merged.");
});
document.getElementById("btnClearDB").addEventListener("click", ()=>{
  if(!confirm("Clear all local analyzer data? This cannot be undone.")) return;
  localStorage.removeItem(DB_KEY);
  DB = loadDB();
  saveDB();
  currentRunId = null;
  refreshConfigSelects();
  importResults.textContent = "";
  renderRunsTable();
  alert("Cleared.");
});

/* =========================
   Init
   ========================= */
function init(){
  refreshConfigSelects();
  renderRunsTable();
  renderSettings();

  const runs = Object.values(DB.runs).sort((a,b)=>{
    const ta = new Date(a.meta.importedAtISO||0).getTime();
    const tb = new Date(b.meta.importedAtISO||0).getTime();
    return tb-ta;
  });
  if(runs.length){
    currentRunId = runs[0].meta.runId;
  }
}
init();
</script>
</body>
</html>
