<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Project 63 — Story Lab (Deterministic Storylets)</title>
  <style>
    :root{
      --bg0:#070a12;
      --bg1:#0b1020;
      --bg2:#111a2e;
      --card:#0f172a;
      --card2:#111c34;
      --text:#e7eefc;
      --muted:#9fb1d1;
      --dim:#6d7fa3;
      --gold:#f0c040;
      --cyan:#52e0ff;
      --red:#ff5470;
      --green:#5dff9a;
      --border:rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 0%, rgba(82,224,255,.12), transparent 60%),
                  radial-gradient(900px 700px at 100% 20%, rgba(240,192,64,.10), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1) 35%, var(--bg0));
      min-height:100vh;
    }
    .topbar{
      position:sticky; top:0; z-index:20;
      background: linear-gradient(180deg, rgba(7,10,18,.92), rgba(7,10,18,.65));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
    }
    .wrap{max-width:1280px;margin:0 auto;padding:18px 18px 28px}
    .titleRow{display:flex;gap:14px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .brand{
      display:flex;gap:12px;align-items:center
    }
    .badge{
      width:38px;height:38px;border-radius:12px;
      background: linear-gradient(135deg, rgba(240,192,64,.25), rgba(82,224,255,.20));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      display:grid;place-items:center;
      color:var(--gold);font-weight:800;
      letter-spacing:.5px;
    }
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:12px;margin-top:2px}
    .pill{
      font-family:var(--mono);
      font-size:11px;
      color:rgba(231,238,252,.92);
      border:1px solid var(--border);
      background:rgba(17,26,46,.55);
      padding:6px 10px;border-radius:999px;
    }
    .grid{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 1020px){
      .grid{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(11,16,32,.82));
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;justify-content:space-between;align-items:flex-start;gap:10px;
    }
    .cardTitle{font-weight:800;font-size:13px;letter-spacing:.2px}
    .cardSub{color:var(--muted);font-size:11px;margin-top:2px}
    .cardBody{padding:14px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}
    label{font-size:11px;color:var(--muted)}
    input, select, textarea{
      width:100%;
      background: rgba(17,26,46,.7);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      outline:none;
      font-size:12px;
    }
    textarea{min-height:120px; font-family: var(--mono); font-size: 11px; line-height:1.35}
    input::placeholder{color:rgba(159,177,209,.55)}
    .btn{
      border:1px solid var(--border);
      background: rgba(17,26,46,.65);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:700;
      font-size:12px;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{background: rgba(17,26,46,.85); border-color: rgba(240,192,64,.35)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      background: linear-gradient(135deg, rgba(240,192,64,.22), rgba(82,224,255,.16));
      border-color: rgba(240,192,64,.35);
    }
    .btn.danger{border-color: rgba(255,84,112,.40); background: rgba(255,84,112,.10)}
    .btn.small{padding:7px 10px; font-size:11px}
    .hint{color:var(--dim); font-size:11px; line-height:1.35}
    .mono{font-family:var(--mono)}
    .drop{
      border:1px dashed rgba(240,192,64,.35);
      background: rgba(240,192,64,.06);
      border-radius:14px;
      padding:12px;
    }
    .drop strong{color:var(--gold)}
    .tabs{
      display:flex;gap:8px;flex-wrap:wrap;
      padding:10px 14px;
      border-bottom:1px solid var(--border);
      background: rgba(11,16,32,.55);
    }
    .tab{
      font-size:11px;font-weight:800;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--border);
      background: rgba(17,26,46,.45);
      cursor:pointer;
    }
    .tab.active{
      border-color: rgba(82,224,255,.40);
      background: rgba(82,224,255,.10);
      color: var(--text);
    }
    pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      color: rgba(231,238,252,.93);
    }
    table{
      width:100%;
      border-collapse: collapse;
      font-size:11px;
    }
    th, td{
      border-bottom:1px solid rgba(255,255,255,.07);
      padding:8px 8px;
      vertical-align: top;
    }
    th{color:rgba(159,177,209,.95);text-align:left;font-weight:800}
    td{color:rgba(231,238,252,.92)}
    .chip{
      display:inline-block;
      padding:3px 8px;border-radius:999px;
      background: rgba(17,26,46,.55);
      border:1px solid rgba(255,255,255,.08);
      font-family: var(--mono);
      font-size: 10px;
      color: rgba(231,238,252,.92);
    }
    .chip.gold{border-color: rgba(240,192,64,.35); background: rgba(240,192,64,.10)}
    .chip.cyan{border-color: rgba(82,224,255,.35); background: rgba(82,224,255,.10)}
    .chip.red{border-color: rgba(255,84,112,.35); background: rgba(255,84,112,.10)}
    .chip.green{border-color: rgba(93,255,154,.35); background: rgba(93,255,154,.10)}
    .split{
      display:grid; grid-template-columns:1fr 1fr; gap:10px;
    }
    @media (max-width: 520px){ .split{grid-template-columns:1fr} }
    .rightHeaderRow{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="wrap">
      <div class="titleRow">
        <div class="brand">
          <div class="badge">63</div>
          <div>
            <h1>Project 63 — Story Lab</h1>
            <div class="sub">Deterministic storylets • Grand Casino pack • Archivist record tone</div>
          </div>
        </div>
        <div class="row">
          <div class="pill" id="runMetaPill">No run loaded</div>
          <div class="pill mono" id="seedPill">Seed: —</div>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT: Controls -->
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="cardTitle">Inputs</div>
            <div class="cardSub">Load run logs and generate a record-style story.</div>
          </div>
          <div class="row">
            <button class="btn small danger" id="btnClear">Clear</button>
          </div>
        </div>

        <div class="cardBody">
          <div class="drop" id="dropZone">
            <div class="hint"><strong>Drop</strong> one or more run log JSON files here, or use the picker.</div>
            <div class="row" style="margin-top:10px">
              <input type="file" id="filePicker" accept=".json,application/json" multiple />
            </div>
          </div>

          <div style="height:12px"></div>

          <div class="col">
            <div class="row" style="justify-content:space-between">
              <label>Run</label>
              <span class="hint" id="loadedCount">0 loaded</span>
            </div>
            <select id="runSelect"></select>
          </div>

          <div style="height:12px"></div>

          <div class="col">
            <label>Story</label>
            <div class="hint">Single record per run (Brief).</div>
          </div>

          <div style="height:12px"></div>

          <div class="col">
            <label>Seed override (optional)</label>
            <input id="seedOverride" placeholder="Leave blank to use runId + player + archetype"/>
            <div class="hint">Use this to “re-roll” deterministically across the same log.</div>
          </div>

          <div style="height:12px"></div>
          <div class="hint">Player classification is sourced from the run log header and summary metadata.</div>

          <div style="height:12px"></div>

          <div class="col">
            <label>Marginalia rate (per floor)</label>
            <input id="margRate" type="range" min="0" max="100" value="25"/>
            <div class="row" style="justify-content:space-between">
              <span class="hint">0–100%</span>
              <span class="chip" id="margRateVal">25</span>
            </div>
          </div>

          <div style="height:12px"></div>

          <div class="col">
            <label>Include categories</label>
            <div class="row">
              <label class="chip"><input type="checkbox" id="fMatch" checked/> Match</label>
              <label class="chip"><input type="checkbox" id="fBoss" checked/> Boss</label>
              <label class="chip"><input type="checkbox" id="fShops" checked/> Shops</label>
              <label class="chip"><input type="checkbox" id="fDeck" checked/> Deck</label>
              <label class="chip"><input type="checkbox" id="fBench" checked/> Bench</label>
              <label class="chip"><input type="checkbox" id="fMeta" checked/> Meta</label>
            </div>
          </div>

          <div style="height:12px"></div>

          <div class="col">
            <label>Diagnostics</label>
            <div class="row">
              <label class="chip"><input type="checkbox" id="includeDebug"/> Include Debug Events</label>
            </div>
          </div>

          <div style="height:14px"></div>

          <div class="row">
            <button class="btn primary" id="btnStory">Generate Record</button>
            <button class="btn" id="btnCopy">Copy</button>
            <button class="btn" id="btnDownloadStory">Download .txt</button>
            <button class="btn" id="btnDownloadCSV">Inserts .csv</button>
          </div>

          <div style="height:10px"></div>
          <div class="hint">Output is deterministic by run and seed. Same run + same seed = same archive record.</div>
        </div>
      </div>

      <!-- RIGHT: Output -->
      <div class="card">
        <div class="tabs">
          <div class="tab active" data-tab="story">Story</div>
          <div class="tab" data-tab="inserts">Inserts</div>
          <div class="tab" data-tab="pack">Story Pack</div>
        </div>

        <div class="cardBody" id="tab_story">
          <div class="rightHeaderRow">
            <div class="row" style="gap:8px;flex-wrap:wrap">
              <span class="chip cyan" id="pillPlayer">Player: —</span>
              <span class="chip gold" id="pillCasino">Casino: Grand</span>
              <span class="chip" id="pillLines">Lines: —</span>
            </div>
            <div class="hint">Single Brief record</div>
          </div>
          <div style="height:12px"></div>
          <div class="card" style="border-radius:14px">
            <div class="cardBody">
              <pre id="storyOut">Load a run log to begin.</pre>
            </div>
          </div>
        </div>

        <div class="cardBody" id="tab_inserts" style="display:none">
          <div class="row" style="justify-content:space-between;align-items:flex-end">
            <div class="col" style="flex:1">
              <label>Filter by type (contains)</label>
              <input id="typeFilter" placeholder="e.g., BOSS, MODIFY, MATCH_OUTCOME"/>
            </div>
            <div class="col" style="width:160px">
              <label>Max rows</label>
              <input id="maxRows" type="number" min="50" max="5000" value="500"/>
            </div>
          </div>
          <div style="height:12px"></div>
          <div class="hint">This table shows extracted inserts (after extraction, before storylet selection). Use it to confirm coverage and prune spam.</div>
          <div style="height:12px"></div>
          <div style="overflow:auto; max-height: 62vh; border:1px solid var(--border); border-radius:14px">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>ts</th>
                  <th>floor</th>
                  <th>match</th>
                  <th>insertType</th>
                  <th>imp</th>
                  <th>cooldownKey</th>
                  <th>payload</th>
                </tr>
              </thead>
              <tbody id="insertRows"></tbody>
            </table>
          </div>
        </div>

        <div class="cardBody" id="tab_pack" style="display:none">
          <div class="row" style="justify-content:space-between;align-items:flex-end">
            <div class="col" style="flex:1">
              <div class="cardTitle">Grand Casino Pack (editable)</div>
              <div class="cardSub">Export/edit the storylet library. This is still deterministic.</div>
            </div>
            <div class="row">
              <button class="btn small" id="btnPackReset">Reset</button>
              <button class="btn small" id="btnPackApply">Apply</button>
              <button class="btn small" id="btnPackDownload">Download .json</button>
            </div>
          </div>
          <div style="height:12px"></div>
          <textarea id="packEditor"></textarea>
          <div class="hint">Edits apply immediately to generation. Keep templates short and “ledger-like.” Use placeholders like <span class="mono">{payload.card}</span>, <span class="mono">{ctx.floor}</span>.</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Story Engine V2 (expanded to include loans + collector buys)
   ========================================================= */

/* ---------- Seeded RNG ---------- */
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= (h >>> 16);
    return h >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function makeRng(seedStr){
  const seed = xmur3(seedStr)();
  return mulberry32(seed);
}
function pickOne(arr, rng){
  if(!arr || !arr.length) return "";
  return arr[Math.floor(rng() * arr.length)];
}

/* ---------- Helpers ---------- */
function getPath(obj, path){
  const parts = String(path||"").split(".");
  let cur = obj;
  for(const p of parts){
    if(cur == null) return "";
    cur = cur[p];
  }
  return (cur == null) ? "" : cur;
}
function tpl(str, data){
  return String(str).replace(/\{([a-zA-Z0-9_.]+)\}/g, (_,path)=>String(getPath(data, path)));
}
function fmtNum(n){
  if(n==null || n==="") return "—";
  const x = Number(n);
  if(Number.isNaN(x)) return String(n);
  return x.toLocaleString("en-US");
}
function cardLabelFromRef(ref){
  if(!ref) return "—";
  if(typeof ref === "string") return ref;
  if(ref.kind==="MOD") return (ref.delta>=0?`+${ref.delta}`:`${ref.delta}`);
  const r = ref.rank ?? "?";
  const s = ref.suit ?? "?";
  return `${r}${s}`;
}
function listCards(arr, limit=3){
  if(!arr || !arr.length) return "—";
  const shown = arr.slice(0, limit).map(cardLabelFromRef);
  return arr.length > limit ? `${shown.join(", ")}, …` : shown.join(", ");
}
function normalizeOutcome(x){
  const s = String(x||"").toUpperCase();
  if(s==="WIN") return "WIN";
  if(s==="LOSS") return "LOSS";
  if(s==="TIE") return "TIE";
  return s || "UNKNOWN";
}
function computeNetChipsFromMatchEnd(d){
  const payout = Number(d?.payout || 0);
  const buyIn = Number(d?.buyIn || 0);
  const rake  = Number(d?.rake || 0);
  const bonus = Number(d?.bonusChips || 0);
  const tnet  = Number(d?.transferNet || 0);
  return payout - buyIn - rake + bonus + tnet;
}
function fmtCard(card){
  if(!card) return "—";
  if(typeof card === "string") return card;
  return `${card.rank ?? "?"}${card.suit ?? "?"}`;
}

/* ---------- Grand Casino pack (editable) ---------- */
const BASE_PACK = {
  narrator: "The Archivist",
  archetypeAliases: {
    "The Engine Builder": "Engineer",
    "The Karma Chaser": "Politico"
  },
  headers: [
    "ARCHIVE RECORD — GRAND CASINO",
    "LEDGER ENTRY — GRAND CASINO (VERIFIED)",
    "PERMANENT RECORD — GRAND CASINO"
  ],
  brief: {
    archetypeAliases: {
      "Engine Builder":"Engineer",
      "The Engine Builder":"Engineer",
      "Engineer":"Engineer",
      "Karma Chaser":"Politico",
      "The Karma Chaser":"Politico",
      "Politico":"Politico"
    },
    summaryTemplates: [
      "Summary: Subject advanced to Floor {payload.floorsReached}. Bosses cleared: {payload.bossesCleared}. Termination by {payload.termination}.",
      "Summary: Floor {payload.floorsReached} reached. Bosses cleared: {payload.bossesCleared}. Record ended by {payload.termination}.",
      "Summary: Subject reached Floor {payload.floorsReached}. Cleared {payload.bossesCleared} boss table(s). Termination by {payload.termination}.",
      "Summary: Progress logged through Floor {payload.floorsReached}. Bosses cleared: {payload.bossesCleared}. Closure by {payload.termination}.",
      "Summary: Subject reached Floor {payload.floorsReached}. Bosses cleared: {payload.bossesCleared}. The run concluded by {payload.termination}."
    ],
    beatLabels: {
      HIGH_STAKES_PRESS: ["High Stakes Press","High Stakes Lean","High Stakes Emphasis","High Stakes Bias","High Stakes Habit","High Stakes Dependence","High Stakes Tilt","High Stakes Appetite"],
      TRANSFER_RELIANCE: ["Transfer Reliance","Transfer First","Transfer Habit","Multiplier Hunting","Transfer-Centered","Transfer Driven","Leveraged Transfers","Transfer Gamble"],
      SHOP_HEAVY: ["Inventory Obsession","Service Loop","Counter Shopping","Tool Accumulation","Catalog Hunger","Inventory Forward","Services Over Tables","Merchant Gravity"],
      NEAR_ZERO: ["Near Zero","On the Edge","Thin Stack","Breathless Ledger","Low Stack","Knife-Edge","Empty Pockets","Coin-Flip Bankroll"],
      VOLATILE: ["Volatility","Variance Storm","Swing Heavy","Unsteady Floor","Wild Ledger","Sharp Swings","Turbulence","Noisy Outcome"],
      STABLE: ["Advantage Held","Controlled Play","Steady Ledger","Disciplined Line","Even Keel","Quiet Wins","Measured Pace","Clean Accounting"],
      OVERLEVERAGED: ["Overleveraged","Risk Forward","Leveraged Risk","Pressed Too Far","Debt-Adjacent","Thin Margin","Pushed Limits","Risk-Weighted"],
      DEBT_EVENT: ["Debt Touched","Debt Opened","Debt Collected","Debt Shadow","Interest Paid","Debt Pressure","Loan Echo","Debt Event"],
      KARMA_SPIKE: ["Karma Spike","Karma Surge","Karma Windfall","Karma Bloom","Karma Shock","Karma Break","Karma Flood","Karma Event"],
      CALLING_GROWTH: ["Calling Growth","Calling Advancement","Calling Pressure","Calling Heat","Calling Climb","Calling Momentum","Calling Upgrade","Calling Signal"],
      BANKROLL_SECURED: ["Bankroll Secured","Stability Established","Bankroll Stabilized"],
      SLIDE: ["Slide","Bankroll Erosion","House Pressure"],
      TIMER_PRESSURE: ["Timer Pressure","Clock Pressure","Time Limit"]
    },
    chipsVerbs: {
      up: ["rose","climbed","lifted","advanced","surged","recovered","rebuilt","steadied upward","expanded","grew","stacked up","ran hot","found altitude","swelled","gained ground"],
      down: ["fell","eroded","slipped","declined","collapsed","bled","drained","sank","thinned","gave back","lost ground","ran cold","shed chips","shrunk","fractured"],
      flat: ["held","stayed level","barely moved","ended near start","stabilized","balanced out","closed flat","settled","found equilibrium"]
    },
    pressurePhrases: {
      chipsLow: [" Discipline tested at {payload.chipsLow}."," A dip tested discipline ({payload.chipsLow})."," The stack went thin ({payload.chipsLow})."," A choke point emerged ({payload.chipsLow})."," A near-zero moment recorded ({payload.chipsLow})."," The ledger tightened to {payload.chipsLow}."," The floor demanded proof at {payload.chipsLow}."," The bankroll held its breath ({payload.chipsLow})."],
      none: [""]
    },
    riskPhrases: {
      hs: [" High Stakes leaned on ({payload.highStakesCount})."," High Stakes pressed ({payload.highStakesCount})."," High Stakes repeated ({payload.highStakesCount})."," High Stakes returned ({payload.highStakesCount})."," High Stakes chosen ({payload.highStakesCount})."],
      transfer: [" Transfers peaked at x{payload.transferPeak}."," Multipliers peaked at x{payload.transferPeak}."," Transfer ceiling reached x{payload.transferPeak}."," Transfer appetite reached x{payload.transferPeak}."," Multiplier hunting peaked at x{payload.transferPeak}."],
      combined: [" High Stakes leaned on ({payload.highStakesCount}); transfers peaked at x{payload.transferPeak}."," High Stakes pressed ({payload.highStakesCount}); multipliers reached x{payload.transferPeak}."," High Stakes repeated ({payload.highStakesCount}); transfer ceiling x{payload.transferPeak}."," High Stakes emphasized ({payload.highStakesCount}); leverage peaked at x{payload.transferPeak}."],
      none: [""]
    },
    floorLineTemplates: [
      "Floor {payload.floor} — {payload.tags}: Chips {payload.chipsVerb} {payload.chipsStart} → {payload.chipsEnd}.{payload.pressure}{payload.risk}{payload.notable} {payload.signature}",
      "Floor {payload.floor} — {payload.tags}: Chips {payload.chipsVerb} {payload.chipsStart} → {payload.chipsEnd}.{payload.risk}{payload.pressure}{payload.notable} {payload.signature}",
      "Floor {payload.floor} — {payload.tags}: Chips {payload.chipsStart} → {payload.chipsEnd} ({payload.chipsDelta}).{payload.pressure}{payload.risk}{payload.notable} {payload.signature}"
    ],
    terminationLabels: {
      BOSS_TIMER_EXPIRED: ["time limit at the boss table","the clock at the boss door","timer at the boss table"],
      CHIP_ZERO: ["insolvency","bankroll collapse","chip exhaustion"],
      PLAYER_QUIT: ["withdrawal","self-termination","exit by choice"],
      UNKNOWN: ["unknown cause","unclassified cause","unspecified cause"]
    },
    notableTemplates: {
      SHOP: ["Services consumed ({payload.shopCount}); spend {payload.shopSpend}.","Inventory activity ({payload.shopCount}); chips routed to services ({payload.shopSpend}).","Services favored over tables; spend {payload.shopSpend}.","Tools acquired in bulk ({payload.shopCount}); spend {payload.shopSpend}.","The subject shopped the floor ({payload.shopCount}); spend {payload.shopSpend}."],
      BIG_SWING: ["{payload.npcName} drove the largest swing ({payload.swing}).","Largest variance recorded against {payload.npcName} ({payload.swing}).","{payload.npcName} delivered the biggest result delta ({payload.swing}).","The sharpest swing came from {payload.npcName} ({payload.swing})."],
      BENCH: ["Bench intervention logged: lane {payload.lane} ({payload.delta}).","Bench altered lane {payload.lane} ({payload.delta}).","Bench deployed: lane {payload.lane} adjusted ({payload.delta}).","Bench correction applied at lane {payload.lane} ({payload.delta})."],
      ACTION: ["Action acquired: {payload.actionName} (cost {payload.cost}).","{payload.actionName} added to toolkit (cost {payload.cost}).","Action purchased: {payload.actionName} ({payload.cost}).","{payload.actionName} entered inventory; spend {payload.cost}."],
      DECK_MILESTONE: ["Deck altered: {payload.deckNote}.","Deck mutation logged: {payload.deckNote}.","Deck state shifted: {payload.deckNote}.","Deck change recorded: {payload.deckNote}."]
    },
    signatures: {
      Engineer: {
        low: ["Tools were applied without doctrine.","Blueprints don't predict thunder.","Efficiency rose; certainty did not.","Subject measured the table; the table measured back.","Method was visible. Motive stayed unfiled.","The House recorded outputs, not intent.","The subject optimized the wrong variable.","Clean logic; unclear purpose."],
        mid: ["The subject tuned risk like an instrument.","Blueprints were adjusted in real time.","Variance was treated as a parameter, not a threat.","Systems thinking held under strain.","The record shows measured aggression.","The floor behaved until it didn't."],
        high: ["The blueprint held; the House conceded ground.","Variance was absorbed into design.","The subject made the floor behave.","Risk became a controlled input.","Pressure produced clarity.","The subject built a ladder out of losses."]
      },
      Politico: {
        low: ["Leverage was attempted without coalition.","The subject played optics against arithmetic.","Influence was spent faster than it was earned.","The table does not vote.","The House ignores speeches.","The subject negotiated with a mirror."],
        mid: ["Leverage was applied where it mattered.","The subject traded risk for position.","Influence was converted into outcome.","The floor responded to timing.","Pressure was negotiated, not begged.","The subject found votes in silence."],
        high: ["The subject made the floor follow the story.","Influence shaped the ledger.","Even variance was made to pay tribute.","The House negotiated in silence.","The subject turned conflict into margin."]
      },
      Generic: {
        low: ["The record notes intention without alignment.","The subject acted; the House answered.","A pattern was sought; only traces were found.","The floor refused interpretation."],
        mid: ["The subject adapted as the floor shifted.","Variance was managed, not feared.","The record shows adjustment under pressure."],
        high: ["The subject moved with the House and still gained ground.","The floor bent before it broke.","The House conceded in increments."]
      }
    },
    marginalia: {
      generic: ["“The house does not explain itself.”","“Some floors teach by subtraction.”","“Luck is loud. Accounting is louder.”","“Noise can be studied. It cannot be trusted.”","“A record is not mercy.”","“The bright carpet hides the math.”","Margin note: The subject kept walking after the ledger flinched.","Margin note: A win can still be a warning."],
      Engineer: ["“Blueprints are prayers written in numbers.”","“Method arrived early. Motive arrived late.”","“Precision was visible. Mercy was not.”","“The House records the blueprint, not the dream.”","“Every lever works. Not every lever matters.”","Margin note: The subject treated fear like a rounding error."],
      Politico: ["“The floor votes with chips.”","“Influence is counted, not declared.”","“The table negotiates in outcomes.”","“Leverage works until it doesn't.”","“Even allies have a house edge.”","Margin note: The subject tried to bargain with probability."]
    },
    bossLines: {
      clean: ["Boss {payload.bossNum} — Clean Clearance: Cleared in {payload.rounds} round.","Boss {payload.bossNum} — Clean Clearance: Neutralized in {payload.rounds} round.","Boss {payload.bossNum} — Clean Clearance: No drag, no doubt ({payload.rounds} round)."],
      grind2: ["Boss {payload.bossNum} — Grind: Cleared in {payload.rounds} rounds.","Boss {payload.bossNum} — Grind: Required {payload.rounds} rounds to clear.","Boss {payload.bossNum} — Grind: Cleared, but not cheaply ({payload.rounds} rounds)."],
      lastGasp3: ["Boss {payload.bossNum} — Last Gasp: Cleared at the final round ({payload.rounds}).","Boss {payload.bossNum} — Last Gasp: Cleared on the last breath ({payload.rounds}).","Boss {payload.bossNum} — Last Gasp: Clearance came late ({payload.rounds} rounds)."],
      countermeasures: [" Countermeasures {payload.countermeasures}."," Countermeasures recorded: {payload.countermeasures}."," Countermeasures triggered: {payload.countermeasures}."],
      benchCap: [" Bench capacity {payload.benchCapacity}."," Bench capacity now {payload.benchCapacity}."," Bench expanded: capacity {payload.benchCapacity}."],
      timerFail: ["Boss {payload.bossNum} — Timer Pressure: Engagement ended by timer.","Boss {payload.bossNum} — Timer Pressure: The clock closed the door.","Boss {payload.bossNum} — Timer Pressure: Time expired; engagement ended."],
      timerHP: [" HP {payload.hp}/{payload.maxHp}."," Remaining HP {payload.hp}/{payload.maxHp}."," HP at seal: {payload.hp}/{payload.maxHp}."]
    },
    dispositionTemplates: [
      "Disposition: Chips {payload.chipsStart} → {payload.chipsEnd}. Karma {payload.karmaEnd}. Calling {payload.callingCard}.{payload.deckState}",
      "Disposition: Ledger closed at {payload.chipsEnd} chips. Karma {payload.karmaEnd}. Calling {payload.callingCard}.{payload.deckState}",
      "Disposition: Chips sealed at {payload.chipsEnd}. Karma {payload.karmaEnd}. Calling {payload.callingCard}.{payload.deckState}"
    ]
  },
  legacyStorylets: {
    RUN_OPEN: [
      "Filed by {narrator}. The Grand Casino received the subject without ceremony.",
      "Filed by {narrator}. House lights held steady; the subject entered."
    ],
    CALLING_CARD_SET: [
      "Calling registered: {payload.card}. The table network acknowledged it.",
      "Calling declared: {payload.card}. The record notes the selection without interpretation."
    ],
    FLOOR_START: [
      "Floor {ctx.floor} opened. Chips: {ctx.chips}.",
      "Floor {ctx.floor}. Chips ledger: {ctx.chips}. Footsteps carried cleanly."
    ],

    TILE_ENTER: [
      "Encounter logged: {ctx.tileType}.",
      "Tile entered: {ctx.tileType}."
    ],

    /* Shops / services */
    COLLECTOR_SHOP_GENERATED: [
      "Collector inventory recorded ({payload.count} items): {payload.items}.",
      "The Stamp Collector presented {payload.count} offerings: {payload.items}."
    ],
    COLLECTOR_BUY: [
      "Acquisition from Collector: {payload.itemId} for {payload.cost}.",
      "Collector sale recorded: {payload.itemId} (cost {payload.cost})."
    ],
    STAMP_CANDIDATES_SHOWN: [
      "Stamp {payload.stampId} offered against: {payload.candidates}.",
      "Stamp candidates posted ({payload.stampId}): {payload.candidates}."
    ],
    SLEEVE_CANDIDATES_SHOWN: [
      "Sleeve {payload.sleeveId} offered against: {payload.candidates}.",
      "Sleeve candidates posted ({payload.sleeveId}): {payload.candidates}."
    ],
    MERCHANT_ENTER: [
      "Merchant stock logged (x{payload.priceMult}): {payload.offers}.",
      "Merchant opened inventory at price mult x{payload.priceMult}: {payload.offers}."
    ],
    MERCHANT_REROLL: [
      "Merchant rotated stock ({payload.which}): {payload.offers}.",
      "Merchant reroll executed ({payload.which}). New offers: {payload.offers}."
    ],
    MERCHANT_BUY: [
      "Merchant sale: {payload.card} for {payload.cost}.",
      "Purchase recorded: {payload.card} (cost {payload.cost})."
    ],
    MODIFY_ENTER: [
      "Modify counter active. Services offered: {payload.services}.",
      "Modify service opened. Eligible: {payload.eligibleCount}. Services: {payload.services}."
    ],
    MODIFY_SERVICE_SELECT: [
      "Modify selection logged: {payload.serviceId} — {payload.cost} chips.",
      "Service selected: {payload.serviceId} (tier {payload.tier}) cost {payload.cost}."
    ],
    MODIFY_APPLY: [
      "Service executed: {payload.serviceId} on {payload.count} card(s).",
      "Modify applied: {payload.serviceId} affecting {payload.count} card(s)."
    ],
    LOAN_TAKEN: [
      "Debt opened: +{payload.amount}. Repayment due: {payload.repay}.",
      "Loan recorded. Principal {payload.amount}; repayment {payload.repay}."
    ],
    LOAN_REPAID: [
      "Debt closed. Paid {payload.amount}.",
      "Loan repaid in full: {payload.amount}."
    ],
    BARTENDER_TAKE: [
      "Bartender transaction: {payload.chips} chips.",
      "Bartender took {payload.chips} chips. Tokens were set aside."
    ],
    COCKTAIL_BOUGHT: [
      "Action acquired: {payload.actionName}. Cost {payload.cost}.",
      "Cocktail purchased: {payload.actionName} ({payload.cost})."
    ],
    ACTION_USED: [
      "Action used: {payload.actionName} (tokens remaining {payload.tokensRemaining}).",
      "Action invoked: {payload.actionName}. Tokens remaining: {payload.tokensRemaining}."
    ],

    /* Deck edits / artifacts */
    STAMP_APPLY: [
      "Stamped: {payload.card} marked {payload.stampId}.",
      "Stamp applied: {payload.stampId} → {payload.card}."
    ],
    SLEEVE_APPLY: [
      "Sleeved: {payload.card} under {payload.sleeveId}.",
      "Sleeve fitted: {payload.sleeveId} → {payload.card}."
    ],
    REST_CHOICE: [
      "Rest stop logged: {payload.choice}.",
      "Rest stop decision recorded: {payload.choice}."
    ],
    FREE_REMOVAL: [
      "Free removal executed: {payload.card}.",
      "Removed from deck: {payload.card}."
    ],
    MINIGAME: [
      "Minigame result posted: chips +{payload.chips}, tokens +{payload.tokens}.",
      "Side-table settled: +{payload.chips} chips; +{payload.tokens} token(s)."
    ],
    BURN_AFTER_READING: [
      "BURN AFTER READING executed: {payload.cards}.",
      "Burned after reading: {payload.cards}."
    ],
    KEYCARD_OBTAINED: [
      "Keycard logged: {payload.card}. The record flags a door, not a prize.",
      "Keycard obtained: {payload.card}. Access classified."
    ],
    WINNER_REWARD_MODE: [
      "Winner reward mode set: {payload.mode}.",
      "Reward mode logged: {payload.mode}."
    ],
    WINNER_REWARD_APPLY: [
      "Reward executed: {payload.mode} → {payload.card}.",
      "Winner reward applied ({payload.mode}): {payload.card}."
    ],
    WINNER_REWARD_FUSE: [
      "Cards fused: {payload.fused}.",
      "Fusion executed: {payload.fused}."
    ],

    /* Bench drama */
    BENCH_OVERFLOW: [
      "Bench forced a decision: {payload.removed} displaced by {payload.added} (cap {payload.cap}).",
      "Bench overflow (cap {payload.cap}): removed {payload.removed}, added {payload.added}."
    ],
    BENCH_PLACE: [
      "Card benched: {payload.card} placed to lane {payload.lane}.",
      "Bench placement recorded: {payload.card} → lane {payload.lane}."
    ],
    BENCH_APPLY: [
      "Bench effect: {payload.card} ({payload.delta}) applied to lane {payload.lane}.",
      "Bench modifier applied: {payload.card} {payload.delta} → lane {payload.lane}."
    ],
    DEALER_BENCH_GAIN: [
      "Dealer gained a bench modifier: {payload.card}.",
      "Dealer benched {payload.card} (source {payload.source})."
    ],
    DEALER_BENCH_APPLY: [
      "Dealer bench used: lane {payload.lane} adjusted by {payload.delta}.",
      "Dealer applied {payload.delta} to lane {payload.lane} ({payload.reason})."
    ],

    /* Calling / karma */
    CALLING_CARD_LEVEL_UP: [
      "Calling level-up logged: {payload.from} → {payload.to}.",
      "Calling rank advanced: {payload.from} → {payload.to} (karma {payload.karmaAt})."
    ],
    KARMA_GAIN: [
      "Karma accrual recorded: +{payload.amount} (Total {payload.total}).",
      "Karma posted: +{payload.amount}. Total now {payload.total}."
    ],

    /* Match blocks */
    MATCH_OPEN: [
      "{payload.tableLabel} engaged: opponent {payload.npcName}. Buy-in {payload.buyIn}.",
      "{payload.tableLabel} opened vs {payload.npcName} ({payload.npcCalling}). Buy-in {payload.buyIn}."
    ],
    TRANSFER_BET: [
      "Transfer set: x{payload.mult}.",
      "Transfer wager recorded at x{payload.mult}."
    ],
    MATCH_OUTCOME: [
      "{payload.tableLabel} closed: {payload.result}. Ledger change {payload.netChips}; rake {payload.rake}.",
      "{payload.tableLabel} resolved: {payload.result}. Net {payload.netChips} (rake {payload.rake})."
    ],
    MATCH_HIGHLIGHTS: [
      "Highlights recorded: {payload.notes}.",
      "Match notes: {payload.notes}."
    ],

    /* Boss turning points */
    BOSS_TARGET_SET: [
      "Boss attention shifted to lane {payload.laneIdx}.",
      "Boss target fixed: lane {payload.laneIdx} ({payload.reason})."
    ],
    BOSS_PHASE2_START: [
      "Boss entered Phase II. HP {payload.hp}/{payload.maxHp}.",
      "Boss phase shift recorded (Round {payload.round}): HP {payload.hp}/{payload.maxHp}."
    ],
    BOSS_COUNTERMEASURE: [
      "Boss countermeasure logged on lane {payload.lane}: {payload.appliedDelta}.",
      "Countermeasure: lane {payload.lane} adjusted by {payload.appliedDelta} (state {payload.targetState})."
    ],
    BOSS_DAMAGE: [
      "Damage registered: {payload.totalDamage} (lanes won {payload.lanesWon}).",
      "Boss damage posted: {payload.totalDamage}. HP {payload.hpBefore}→{payload.hpAfter}."
    ],

    /* Meta */
    FEEDBACK_UPDATED: [
      "Post-run annotation appended (comments {payload.commentsLen}, bugs {payload.bugsLen}).",
      "Operator note attached to record."
    ],
    RUN_CLOSE: [
      "Ledger closed. Result: {payload.result}. Final chips: {payload.endChips}.",
      "Record sealed. Outcome: {payload.result}. Floors reached: {payload.floors}. Final chips: {payload.endChips}."
    ],

    FLOOR_END: [
      "Floor {payload.floor} sealed. Chips {payload.chipsStart} → {payload.chipsEnd}. Karma +{payload.karmaGain}.",
      "End of Floor {payload.floor}: W{payload.wins}-L{payload.losses}-T{payload.ties} across {payload.matches} matches."
    ],

    RUN_SUMMARY: [
      "Summary filed: Floors {payload.floorsReached}; bosses cleared {payload.bossesCleared}. Outcome {payload.result}.",
      "Run summary: chips {payload.chipsStart} → {payload.chipsEnd}; karma {payload.karmaStart} → {payload.karmaEnd}."
    ],

    BOSS_CLEARED: [
      "Boss cleared on Floor {payload.floor} in {payload.bossWins} rounds. Bench capacity now {payload.benchCapacity}.",
      "Floor {payload.floor} boss neutralized. Rounds required: {payload.bossWins}."
    ],

    BOSS_FIGHT_FAILED: [
      "Boss engagement failed on Floor {payload.floor} ({payload.reason}).",
      "Final boss record: Floor {payload.floor} ended by {payload.reason}."
    ]
  },
};

let currentPack = JSON.parse(JSON.stringify(BASE_PACK));

/* ---------- Match highlights (derived) ---------- */
function deriveMatchHighlights(events){
  const bySeq = new Map();
  function getSeq(ev){ return ev?.ctx?.matchSeq ?? ev?.data?.matchSeq ?? null; }
  function getOrInit(seq){
    if(!bySeq.has(seq)){
      bySeq.set(seq, {
        matchSeq: seq,
        bonus21: 0,
        callingProcs: 0,
        laneCloseAttacks: 0,
        goldBonusTotal: 0,
        goldBonusCount: 0,
        actionsUsed: new Map(),
        benchOverflows: 0,
        burns: [],
        bossDamageTotal: 0,
        bossPhase2: 0,
        dealerBenchUses: 0
      });
    }
    return bySeq.get(seq);
  }

  for(const ev of (events||[])){
    const seq = getSeq(ev);
    if(!seq) continue;
    const m = getOrInit(seq);

    switch(ev.type){
      case "BONUS_21": m.bonus21 += 1; break;
      case "CALLING_PROC_SPADES":
      case "CALLING_PROC_DIAMOND": m.callingProcs += 1; break;
      case "LANE_CLOSE_ATTACK": m.laneCloseAttacks += 1; break;
      case "GOLD_SLEEVE_BONUS":
        m.goldBonusTotal += Number(ev.data?.amount || 0);
        m.goldBonusCount += Number(ev.data?.count || 0);
        break;
      case "ACTION_USED":{
        const name = ev.data?.actionName || ev.data?.actionId || "Action";
        m.actionsUsed.set(name, (m.actionsUsed.get(name)||0) + 1);
        break;
      }
      case "BENCH_OVERFLOW": m.benchOverflows += 1; break;
      case "BURN_AFTER_READING":{
        const cards = ev.data?.cards || [];
        cards.forEach(c=>m.burns.push(c));
        break;
      }
      case "BOSS_DAMAGE": m.bossDamageTotal += Number(ev.data?.totalDamage || 0); break;
      case "BOSS_PHASE2_START": m.bossPhase2 += 1; break;
      case "DEALER_BENCH_APPLY": m.dealerBenchUses += 1; break;
    }
  }

  const out = [];
  for(const m of bySeq.values()){
    const notes = [];
    if(m.bonus21) notes.push(`21-bonus x${m.bonus21}`);
    if(m.callingProcs) notes.push(`Calling proc x${m.callingProcs}`);
    if(m.laneCloseAttacks) notes.push(`lane-close attacks x${m.laneCloseAttacks}`);
    if(m.goldBonusTotal) notes.push(`Gold +${fmtNum(m.goldBonusTotal)} (x${fmtNum(m.goldBonusCount)})`);
    if(m.actionsUsed.size){
      const top = [...m.actionsUsed.entries()].slice(0,2).map(([k,v])=>`${k} x${v}`).join(", ");
      notes.push(`actions: ${top}${m.actionsUsed.size>2 ? ", …" : ""}`);
    }
    if(m.benchOverflows) notes.push(`bench overflow x${m.benchOverflows}`);
    if(m.burns.length) notes.push(`burned: ${listCards(m.burns, 3)}`);
    if(m.bossPhase2) notes.push(`boss phase shift`);
    if(m.bossDamageTotal) notes.push(`boss dmg ${fmtNum(m.bossDamageTotal)}`);
    if(m.dealerBenchUses) notes.push(`dealer bench x${m.dealerBenchUses}`);

    out.push({ matchSeq: m.matchSeq, notes: notes.join("; "), hasNotes: notes.length>0 });
  }
  return out;
}

/* ---------- Insert extraction (V2) ---------- */
function extractEventInsertsV2(runLog, opts={}){
  const eventsAll = runLog?.events || [];
  const includeDebug = !!opts.includeDebug;

  // Prefer run-log meta.scope to avoid flooding the story with debug traces.
  const events = eventsAll.filter(ev=>{
    const scope = (ev?.meta?.scope || "both").toLowerCase();
    if(includeDebug) return true;
    return scope === "story" || scope === "both";
  });

  const inserts = [];
  const matchNotesBySeq = new Map(deriveMatchHighlights(events).map(x=>[x.matchSeq, x]));

  function add(ev, insertType, fallbackImportance, payload={}, cooldownKey=null){
    const ctx = ev.ctx || {};
    const imp = (ev?.meta?.importance != null) ? Number(ev.meta.importance) : Number(fallbackImportance || 50);
    inserts.push({
      insertType,
      ts: ev.ts,
      order: ev.id ?? 0,
      floor: ctx.floor ?? ev.floor ?? ev.data?.floor ?? null,
      matchSeq: ctx.matchSeq ?? ev.data?.matchSeq ?? null,
      tileType: ctx.tileType ?? null,
      importance: imp,
      cooldownKey: cooldownKey || `${insertType}@${ctx.floor ?? ev.floor ?? "?"}:${ctx.matchSeq ?? ev.data?.matchSeq ?? "-"}`,
      payload,
      ctx
    });
  }

  for(const ev of events){
    const ctx = ev.ctx || {};

    switch(ev.type){
      case "GAME_START":
        add(ev, "RUN_OPEN", 95, {
          narrator: runLog?.app?.narrator || "The Archivist",
          casinoName: runLog?.app?.casinoName || "Grand Casino"
        }, "RUN_OPEN");
        break;

      case "CALLING_CARD_SET":
        add(ev, "CALLING_CARD_SET", 90, {
          card: cardLabelFromRef(ev.data?.card || ctx.callingCard || runLog?.finalState?.callingCard || null)
        }, "CALLING_CARD_SET");
        break;

      case "FLOOR_START":
        add(ev, "FLOOR_START", 70, {
          floor: ctx.floor ?? ev.data?.floor,
          chips: ctx.chips ?? ev.chips
        }, `FLOOR_START@${ctx.floor ?? ev.data?.floor}`);
        break;

      case "FLOOR_END":
        // Not currently used by default pack, but useful for diagnostics.
        add(ev, "FLOOR_END", 85, ev.data || {}, `FLOOR_END@${ev.data?.floor}`);
        break;

      case "RUN_SUMMARY":
        add(ev, "RUN_SUMMARY", 98, ev.data || {}, "RUN_SUMMARY");
        // Mirror as closer so older packs can end cleanly.
        add(ev, "RUN_CLOSE", 98, ev.data || {}, "RUN_CLOSE");
        break;

      case "TILE_ENTER":
        add(ev, "TILE_ENTER", 55, {
          tileType: ctx.tileType || ev.data?.tileType || null,
          tileId: ctx.tileId || ev.data?.tileId || null
        });
        break;

      case "ACTION_PURCHASED":
        add(ev, "ACTION_PURCHASED", 75, {
          actionName: ev.data?.actionName,
          cost: ev.data?.cost
        });
        break;

      case "TRANSFER_SET":
        add(ev, "TRANSFER_SET", 70, { mult: ev.data?.mult });
        break;

      case "CALLING_CARD_LEVEL_UP":
        add(ev, "CALLING_CARD_LEVEL_UP", 85, {
          from: ev.data?.fromRank,
          to: ev.data?.toRank,
          karmaAt: ev.data?.karmaAtLevelUp
        }, `CALLING_CARD_LEVEL_UP@${ctx.floor ?? ev.floor}:${ev.data?.toRank ?? ""}`);
        break;

      case "MATCH_START": {
        const d = ev.data || {};
        const label = (String(d.type||"").toUpperCase()==="HIGH_STAKES") ? "High-stakes table" : "Standard table";
        add(ev, "MATCH_OPEN", 70, {
          tableLabel: label,
          npcName: d.npcName,
          npcCalling: cardLabelFromRef(d.npcCallingCard),
          buyIn: d.buyIn
        }, `MATCH_OPEN@${d.matchSeq}`);
        break;
      }

      case "TRANSFER_BET":
        add(ev, "TRANSFER_BET", 72, { mult: ev.data?.mult || ev.data?.transferMultiplier || ev.data?.multiplier });
        break;

      case "MATCH_END": {
        const d = ev.data || {};
        const out = normalizeOutcome(d.outcome);
        const net = computeNetChipsFromMatchEnd(d);
        const label = (String(d.type||"").toUpperCase()==="HIGH_STAKES") ? "High-stakes table" : "Standard table";

        add(ev, "MATCH_OUTCOME", 78, {
          tableLabel: label,
          result: out,
          netChips: net,
          rake: d.rake
        }, `MATCH_OUTCOME@${d.matchSeq}`);

        const note = matchNotesBySeq.get(d.matchSeq)?.notes || "";
        if(note){
          add(ev, "MATCH_HIGHLIGHTS", 77, { notes: note }, `MATCH_HIGHLIGHTS@${d.matchSeq}`);
        }
        break;
      }

      case "KARMA_GAIN":
        add(ev, "KARMA_GAIN", 80, { amount: ev.data?.amount, total: ev.data?.total });
        break;

      case "WINNER_REWARD_MODE":
        add(ev, "WINNER_REWARD_MODE", 75, { mode: ev.data?.mode });
        break;

      case "WINNER_REWARD_APPLY":
        add(ev, "WINNER_REWARD_APPLY", 78, { mode: ev.data?.mode, card: cardLabelFromRef(ev.data?.card) });
        break;

      case "DEALER_BENCH_GAIN":
        add(ev, "DEALER_BENCH_GAIN", 72, { card: cardLabelFromRef(ev.data?.card) });
        break;

      case "DEALER_BENCH_APPLY":
        add(ev, "DEALER_BENCH_APPLY", 74, { lane: ev.data?.lane, delta: ev.data?.delta });
        break;

      case "PLAYER_DRAW_BENCH":
        add(ev, "PLAYER_DRAW_BENCH", 60, { card: cardLabelFromRef(ev.data?.card), source: ev.data?.source });
        break;

      case "BENCH_PLACE":
        add(ev, "BENCH_PLACE", 62, { lane: ev.data?.lane, card: cardLabelFromRef(ev.data?.card) });
        break;

      case "BENCH_APPLY":
        add(ev, "BENCH_APPLY", 68, { lane: ev.data?.lane, delta: ev.data?.delta });
        break;

      case "COLLECTOR_BUY":
        add(ev, "COLLECTOR_BUY", 66, { itemId: ev.data?.itemId, cost: ev.data?.cost });
        break;

      case "MERCHANT_BUY":
        add(ev, "MERCHANT_BUY", 66, { card: cardLabelFromRef(ev.data?.card), cost: ev.data?.cost, kind: ev.data?.kind });
        break;

      case "MERCHANT_REROLL":
        add(ev, "MERCHANT_REROLL", 58, { which: ev.data?.which, cost: ev.data?.cost, offers: (ev.data?.offers||[]).map(cardLabelFromRef) });
        break;

      case "MERCHANT_REMOVE":
        // No dedicated storylet in the default pack; keep as meta insert so it can still appear in the table.
        add(ev, "MERCHANT_REMOVE", 70, { card: cardLabelFromRef(ev.data?.card), cost: ev.data?.cost });
        break;

      case "MODIFY_SERVICE_SELECT":
        add(ev, "MODIFY_SERVICE_SELECT", 66, { serviceId: ev.data?.serviceId, tier: ev.data?.tier, cost: ev.data?.cost });
        break;

      case "LOAN_TAKEN":
        add(ev, "LOAN_TAKEN", 86, { amount: ev.data?.amount, repay: ev.data?.repay });
        break;

      case "BOSS_COUNTERMEASURE":
        add(ev, "BOSS_COUNTERMEASURE", 84, { card: cardLabelFromRef(ev.data?.card), delta: ev.data?.delta });
        break;

      case "BOSS_CLEARED":
        add(ev, "BOSS_CLEARED", 92, { floor: ev.data?.floor, bossWins: ev.data?.bossWins, benchCapacity: ev.data?.benchCapacity }, `BOSS_CLEARED@${ev.data?.floor}`);
        break;

      case "BOSS_FIGHT_FAILED":
        add(ev, "BOSS_FIGHT_FAILED", 95, { floor: ev.data?.floor, reason: ev.data?.reason, hp: ev.data?.boss?.hp, maxHp: ev.data?.boss?.maxHp, round: ev.data?.boss?.round, roundsRemaining: ev.data?.boss?.roundsRemaining }, `BOSS_FIGHT_FAILED@${ev.data?.floor}`);
        break;

      case "FEEDBACK_UPDATED":
        add(ev, "FEEDBACK_UPDATED", 55, { text: ev.data?.text || ev.data?.feedback });
        break;
    }
  }

  // Stable sort by (order, ts)
  inserts.sort((a,b)=>{
    const ao = Number(a.order||0), bo = Number(b.order||0);
    if(ao!==bo) return ao-bo;
    return String(a.ts||"").localeCompare(String(b.ts||""));
  });

  return inserts;
}

/* ---------- Category mapping (filters) ---------- */
function categoryOf(insertType){
  const t = String(insertType||"");
  const SHOPS = new Set([
    "TILE_ENTER","COLLECTOR_SHOP_GENERATED","COLLECTOR_BUY","STAMP_CANDIDATES_SHOWN","SLEEVE_CANDIDATES_SHOWN",
    "MERCHANT_ENTER","MERCHANT_REROLL","MERCHANT_BUY","MODIFY_ENTER","MODIFY_SERVICE_SELECT","MODIFY_APPLY",
    "LOAN_TAKEN","LOAN_REPAID","BARTENDER_TAKE","COCKTAIL_BOUGHT","ACTION_USED"
  ]);
  const DECK = new Set(["STAMP_APPLY","SLEEVE_APPLY","REST_CHOICE","FREE_REMOVAL","MINIGAME","BURN_AFTER_READING","KEYCARD_OBTAINED","WINNER_REWARD_MODE","WINNER_REWARD_APPLY","WINNER_REWARD_FUSE"]);
  const BENCH = new Set(["BENCH_OVERFLOW","BENCH_PLACE","BENCH_APPLY","DEALER_BENCH_GAIN","DEALER_BENCH_APPLY"]);
  const BOSS  = new Set(["BOSS_TARGET_SET","BOSS_PHASE2_START","BOSS_COUNTERMEASURE","BOSS_DAMAGE"]);
  const MATCH = new Set(["MATCH_OPEN","TRANSFER_BET","MATCH_OUTCOME","MATCH_HIGHLIGHTS","KARMA_GAIN","CALLING_CARD_LEVEL_UP"]);
  const META  = new Set(["RUN_OPEN","CALLING_CARD_SET","FLOOR_START","FEEDBACK_UPDATED","RUN_CLOSE","FLOOR_END","RUN_SUMMARY"]);

  if(SHOPS.has(t)) return "shops";
  if(DECK.has(t)) return "deck";
  if(BENCH.has(t)) return "bench";
  if(BOSS.has(t)) return "boss";
  if(MATCH.has(t)) return "match";
  if(META.has(t)) return "meta";
  return "other";
}

/* ---------- Render story ---------- */
function renderRecordV3(runLog, opts={}){
  const includeDebug = !!opts.includeDebug;
  const include = opts.include || { match:true,boss:true,shops:true,deck:true,bench:true,meta:true };

  const events = (runLog?.events || []).filter(ev=>{
    const scope = (ev?.meta?.scope || "both").toLowerCase();
    if(includeDebug) return true;
    return scope === "story" || scope === "both";
  });

  const runId = runLog?.runId || runLog?.sessionId || "—";
  const runSummary = [...events].reverse().find(ev=>ev.type === "RUN_SUMMARY")?.data || runLog?.runOutcome || {};
  const playerName = runLog?.player?.name || runSummary?.playerName || runSummary?.player || "Unknown";
  const aliasMap = { ...(currentPack?.archetypeAliases || {}), ...(currentPack?.brief?.archetypeAliases || {}) };
  const archetypeRaw = runLog?.player?.archetype || runSummary?.archetype || "Unknown";
  const archetypeName = aliasMap[archetypeRaw] || String(archetypeRaw).replace(/^The\s+/,"") || "Unknown";
  const resonancePct = runLog?.player?.resonancePct ?? runSummary?.resonancePct ?? null;
  const casinoName = runLog?.app?.casinoName || "Grand Casino";
  const casinoId = runLog?.app?.casinoId || "grand_casino";
  const packBrief = currentPack?.brief || {};

  const seedStr = (opts.seedOverride && String(opts.seedOverride).trim().length)
    ? String(opts.seedOverride).trim()
    : `${runId}|${playerName}`;

  const matchMetaBySeq = Object.create(null);
  function formatCallingCard(cc){
    if(!cc) return "";
    if(typeof cc === "string") return cc;
    if(cc.rank && cc.suit) return `${cc.rank}${cc.suit}`;
    return "";
  }
  function formatNpcName(npcName, matchType){
    if(!npcName) return "Unknown";
    if(npcName.startsWith("High Roller") || npcName.startsWith("Floor Boss")) return npcName;
    if(String(matchType||"").toUpperCase() === "HIGH_STAKES") return `High Roller ${npcName}`;
    return npcName;
  }
  for(const ev of events){
    if(ev.type === "MATCH_START"){
      const d = ev.data || {};
      if(d.matchSeq == null) continue;
      matchMetaBySeq[d.matchSeq] = {
        matchType: d.type,
        npcName: d.npcName,
        npcCalling: formatCallingCard(d.npcCallingCard),
        affinity: d.affinity,
        edgeDelta: d.edgeDelta
      };
    }
  }

  function rngPick(arr, rng){
    if(!arr || !arr.length) return "";
    return arr[Math.floor(rng() * arr.length)];
  }
  function pickTpl(arr, payload, seed){
    const t = rngPick(arr, makeRng(seed));
    return tpl(t || "", { payload });
  }

  function termLabel(code){
    const upper = String(code || "UNKNOWN").toUpperCase();
    const key = upper.includes("TIMER") || upper==="TIME" ? "BOSS_TIMER_EXPIRED"
      : (upper.includes("CHIP") || upper.includes("INSOLV") ? "CHIP_ZERO"
      : (upper.includes("QUIT") ? "PLAYER_QUIT" : "UNKNOWN"));
    const bank = packBrief?.terminationLabels?.[key] || packBrief?.terminationLabels?.UNKNOWN || ["unspecified cause"];
    return rngPick(bank, makeRng(`${seedStr}|term`));
  }

  function byFloor(){
    const m = new Map();
    for(const ev of events){
      const floor = Number(ev?.ctx?.floor ?? ev?.floor ?? ev?.data?.floor);
      if(!Number.isFinite(floor)) continue;
      if(!m.has(floor)) m.set(floor, []);
      m.get(floor).push(ev);
    }
    for(const [,arr] of m) arr.sort((a,b)=>Number(a.id||0)-Number(b.id||0));
    return m;
  }
  const floorEvents = byFloor();

  function findLastDeckSnapshot(){
    for(let i=events.length-1;i>=0;i--){
      const ds = events[i]?.data?.deckSnapshot;
      if(ds) return ds;
    }
    return null;
  }
  function formatDeckState(ds){
    if(!ds) return "";
    const deckSize = ds.deckSize ?? "?";
    const stamped = ds.stampedCount ?? 0;
    const sleeved = ds.sleevedCount ?? 0;
    const fused = ds.fusedCount ?? 0;
    return ` Deck state at seal: ${deckSize} cards, ${stamped} stamped, ${sleeved} sleeved, ${fused} fused.`;
  }

  function buildFloorDigest(floor){
    const evs = floorEvents.get(floor) || [];
    const fend = evs.find(e=>e.type==="FLOOR_END")?.data || null;
    const chipsSeries = evs.map(e=>Number(e?.ctx?.chips)).filter(Number.isFinite);
    const digest = {
      floor,
      chipsStart: fend?.chipsStart ?? (chipsSeries[0] ?? null),
      chipsEnd: fend?.chipsEnd ?? (chipsSeries[chipsSeries.length-1] ?? null),
      chipsLow: fend?.chipsLow ?? (chipsSeries.length ? Math.min(...chipsSeries) : null),
      chipsHigh: fend?.chipsHigh ?? (chipsSeries.length ? Math.max(...chipsSeries) : null),
      matches: Number(fend?.matches ?? 0), wins: Number(fend?.wins ?? 0), losses: Number(fend?.losses ?? 0), ties: Number(fend?.ties ?? 0),
      karmaGain: Number(fend?.karmaGain ?? 0),
      highStakesCount: 0,
      transferPeak: 1,
      shopCount: 0,
      shopSpend: 0,
      rerolls: 0,
      debtTaken: false,
      suitSweepCount: 0,
      callingLevelUps: 0,
      peakKarmaGainEvent: 0,
      benchUses: 0,
      benchLastLane: "?",
      benchLastDelta: 0,
      boss: { timerFail:false, rounds:null, countermeasures:0, benchCapacity:null, hp:null, maxHp:null },
      bigSwing: { abs:0, net:0, npcName:"Unknown", npcCalling:"", matchType:"" },
      notableDeck: "",
      actionBuy: null
    };

    for(const ev of evs){
      const t = String(ev.type||"").toUpperCase();
      if(ev.type==="MATCH_START"){
        const label = String(ev?.data?.tableLabel || ev?.data?.type || "").toUpperCase();
        if(label.includes("HIGH") || ev?.data?.isHighStakes===true || label.includes("STAKES")) digest.highStakesCount++;
      }
      if(ev.type==="MATCH_END"){
        if(!fend) digest.matches++;
        const outcome = normalizeOutcome(ev?.data?.outcome);
        if(!fend && outcome==="WIN") digest.wins++;
        if(!fend && outcome==="LOSS") digest.losses++;
        if(!fend && outcome==="TIE") digest.ties++;

        const d = ev.data || {};
        const meta = matchMetaBySeq[d.matchSeq] || {};
        const matchType = String(d.type || meta.matchType || "").toUpperCase();
        if(matchType !== "BOSS"){
          const net = computeNetChipsFromMatchEnd(d);
          const absNet = Math.abs(net);
          if(absNet > digest.bigSwing.abs){
            digest.bigSwing = {
              abs: absNet,
              net,
              matchType,
              npcName: formatNpcName(meta.npcName || d.npcName, matchType),
              npcCalling: meta.npcCalling || ""
            };
          }
        }
      }
      if(ev.type==="TRANSFER_BET" || ev.type==="TRANSFER_SET") digest.transferPeak = Math.max(digest.transferPeak, Number(ev?.data?.mult||1));
      if(["COLLECTOR_BUY","MERCHANT_BUY","MODIFY_SERVICE_SELECT","BARTENDER_TAKE"].includes(ev.type)){
        digest.shopCount++;
        digest.shopSpend += Number(ev?.data?.cost ?? ev?.data?.chips ?? 0);
      }
      if(ev.type==="MERCHANT_REROLL") digest.rerolls++;
      if(ev.type==="LOAN_TAKEN") digest.debtTaken = true;
      if(t.includes("SUIT_SWEEP") || t.includes("SWEEP")) digest.suitSweepCount++;
      if(ev.type==="CALLING_CARD_LEVEL_UP") digest.callingLevelUps++;
      if(ev.type==="KARMA_GAIN") digest.peakKarmaGainEvent = Math.max(digest.peakKarmaGainEvent, Number(ev?.data?.amount||0));
      if(ev.type==="BOSS_COUNTERMEASURE") digest.boss.countermeasures++;
      if(ev.type==="BOSS_FIGHT_DEFEATED") digest.boss.rounds = Number(ev?.data?.round||0) || digest.boss.rounds;
      if(ev.type==="BOSS_ROUND_START") digest.boss.rounds = Math.max(Number(digest.boss.rounds||0), Number(ev?.data?.round||0)) || digest.boss.rounds;
      if(ev.type==="BOSS_CLEARED") digest.boss.benchCapacity = ev?.data?.benchCapacity ?? digest.boss.benchCapacity;
      if(ev.type==="BOSS_FIGHT_FAILED"){
        if(String(ev?.data?.reason||"").toUpperCase()==="TIME") digest.boss.timerFail = true;
        digest.boss.hp = ev?.data?.boss?.hp ?? ev?.data?.hp ?? null;
        digest.boss.maxHp = ev?.data?.boss?.maxHp ?? ev?.data?.maxHp ?? null;
      }
      if(["BURN_AFTER_READING","WINNER_REWARD_FUSE","KEYCARD_OBTAINED","FREE_REMOVAL"].includes(ev.type)) digest.notableDeck = ev.type.replaceAll("_"," ").toLowerCase();
      if(ev.type==="ACTION_PURCHASED" || ev.type==="COCKTAIL_BOUGHT") digest.actionBuy = { actionName: ev?.data?.actionName || ev?.data?.actionId || "Action", cost: Number(ev?.data?.cost||0)};
      if(ev.type==="DEALER_BENCH_APPLY" || ev.type==="BENCH_APPLY"){
        digest.benchUses++;
        digest.benchLastLane = ev?.data?.lane ?? ev?.data?.laneIdx ?? "?";
        digest.benchLastDelta = Number(ev?.data?.delta || ev?.data?.appliedDelta || 0);
      }
    }
    return digest;
  }

  const tagRules = [
    ["NEAR_ZERO", d=>d.chipsLow!=null && d.chipsLow<=25],
    ["OVERLEVERAGED", d=>d.highStakesCount>=2 && d.chipsEnd<d.chipsStart],
    ["HIGH_STAKES_PRESS", d=>d.highStakesCount>=2],
    ["TRANSFER_RELIANCE", d=>d.transferPeak>=4],
    ["SHOP_HEAVY", d=>d.shopCount>=4 || (d.chipsStart>0 && d.shopSpend>=d.chipsStart*0.25)],
    ["DEBT_EVENT", d=>d.debtTaken],
    ["CALLING_GROWTH", d=>d.callingLevelUps>=2],
    ["KARMA_SPIKE", d=>d.karmaGain>=1500 || d.peakKarmaGainEvent>=300],
    ["STABLE", d=>d.chipsEnd>d.chipsStart && d.losses<=d.wins],
    ["VOLATILE", d=>d.losses>=d.wins && d.matches>=3],
    ["SLIDE", d=>d.chipsEnd<d.chipsStart],
    ["BANKROLL_SECURED", d=>d.chipsEnd>=d.chipsStart]
  ];
  function getBeatTags(d, prev){
    const cand = tagRules.filter(([_,fn])=>fn(d)).map(([k])=>k);
    if(!cand.length) cand.push("VOLATILE");
    let out = cand.slice(0,2);
    if(prev?.[0] && out[0]===prev[0] && cand[1]) out = [cand[1], cand[0]].slice(0,2);
    return out;
  }
  function pressurePhrase(d, floor){
    if(d.chipsLow==null || d.chipsStart==null) return "";
    if(d.chipsLow <= d.chipsStart * 0.40){
      return pickTpl(packBrief?.pressurePhrases?.chipsLow || [""], { chipsLow: fmtNum(d.chipsLow) }, `${seedStr}|floor${floor}|pressure`);
    }
    return "";
  }
  function riskPhrase(d, floor){
    const payload = { highStakesCount: fmtNum(d.highStakesCount), transferPeak: fmtNum(d.transferPeak) };
    if(d.highStakesCount>=2 && d.transferPeak>=4) return pickTpl(packBrief?.riskPhrases?.combined || [""], payload, `${seedStr}|floor${floor}|risk`);
    if(d.highStakesCount>=2) return pickTpl(packBrief?.riskPhrases?.hs || [""], payload, `${seedStr}|floor${floor}|risk`);
    if(d.transferPeak>=4) return pickTpl(packBrief?.riskPhrases?.transfer || [""], payload, `${seedStr}|floor${floor}|risk`);
    return "";
  }
  function resonanceBand(v){
    if(v==null || !Number.isFinite(Number(v))) return "mid";
    if(Number(v)<35) return "low";
    if(Number(v)>70) return "high";
    return "mid";
  }
  function signatureLine(floor){
    const band = resonanceBand(resonancePct);
    const bank = packBrief?.signatures?.[archetypeName]?.[band] || packBrief?.signatures?.Generic?.[band] || ["The House records outcomes, not wishes."];
    return rngPick(bank, makeRng(`${seedStr}|floor${floor}|sig`));
  }
  function beatLabel(tag, floor, slot){
    const labels = packBrief?.beatLabels?.[tag] || [tag];
    return rngPick(labels, makeRng(`${seedStr}|floor${floor}|tag${slot}`));
  }
  function pickNotables(d, floor){
    const n = packBrief?.notableTemplates || {};
    const cands = [];
    const add = (key, weight, payload)=>{ if(n[key]?.length) cands.push({key,weight,payload}); };

    if(include.shops && d.shopCount >= 6) add("SHOP", Math.min(10, d.shopCount), { shopCount: fmtNum(d.shopCount), shopSpend: fmtNum(d.shopSpend) });
    if(include.match && d.bigSwing.abs >= 200) add("BIG_SWING", Math.min(10, Math.floor(d.bigSwing.abs/100)), { npcName:d.bigSwing.npcName, swing:fmtNum(d.bigSwing.net), npcCalling:d.bigSwing.npcCalling });
    if(include.bench && d.benchUses >= 2) add("BENCH", Math.min(10, d.benchUses), { lane:d.benchLastLane, delta:fmtNum(d.benchLastDelta) });
    if(include.shops && d.actionBuy) add("ACTION", 6, { actionName:d.actionBuy.actionName, cost:fmtNum(d.actionBuy.cost) });
    if(include.deck && d.notableDeck) add("DECK_MILESTONE", 6, { deckNote:d.notableDeck });
    if(!cands.length) return "";

    cands.sort((a,b)=>b.weight-a.weight);
    const chosen=[cands[0]];
    if(cands[1] && cands[1].weight>=6) chosen.push(cands[1]);
    const parts=chosen.map((c,idx)=>pickTpl(n[c.key], c.payload, `${seedStr}|floor${floor}|notable|${c.key}|${idx}`));
    return ` Notable: ${parts.join(" ")}`;
  }
  function bossLine(d, floor){
    if(!include.boss) return "";
    const b = packBrief?.bossLines || {};
    if(d.boss.timerFail){
      const base = pickTpl(b.timerFail || ["Boss {payload.bossNum} — Timer Pressure: Engagement ended by timer."], { bossNum:floor }, `${seedStr}|floor${floor}|boss`);
      const hp = (d.boss.hp!=null && d.boss.maxHp!=null) ? pickTpl(b.timerHP || [" HP {payload.hp}/{payload.maxHp}."], { hp:fmtNum(d.boss.hp), maxHp:fmtNum(d.boss.maxHp) }, `${seedStr}|floor${floor}|bosshp`) : "";
      return `${base}${hp}`;
    }
    if(!d.boss.rounds) return "";
    const payload = { bossNum: floor, rounds: d.boss.rounds, countermeasures: fmtNum(d.boss.countermeasures), benchCapacity: fmtNum(d.boss.benchCapacity) };
    const key = d.boss.rounds===1 ? "clean" : (d.boss.rounds===2 ? "grind2" : "lastGasp3");
    let line = pickTpl(b[key] || ["Boss {payload.bossNum} — Grind: Cleared in {payload.rounds} rounds."], payload, `${seedStr}|floor${floor}|boss`);
    if(d.boss.countermeasures>0) line += pickTpl(b.countermeasures || [" Countermeasures {payload.countermeasures}."], payload, `${seedStr}|floor${floor}|bosscm`);
    if(d.boss.benchCapacity!=null) line += pickTpl(b.benchCap || [" Bench capacity {payload.benchCapacity}."], payload, `${seedStr}|floor${floor}|bosscap`);
    return line;
  }

  const floorsReached = Number(runSummary?.floorsReached || runLog?.finalState?.floor || Math.max(1, ...floorEvents.keys()));
  const bossClears = events.filter(e=>e.type==="BOSS_CLEARED").length;
  const inserts = [];
  const lines = [
    `ARCHIVE RECORD — ${String(casinoName).toUpperCase()}`,
    `File: ${String(casinoId).slice(0,3).toUpperCase() || "P63"} / RUN ${runId}`,
    `Player: ${playerName}`,
    `Classification: ${archetypeName}${resonancePct!=null ? ` — Resonance of ${fmtNum(resonancePct)}%` : ""}`,
    ""
  ];

  const summaryPayload = { floorsReached: fmtNum(floorsReached), bossesCleared: fmtNum(bossClears), termination: termLabel(runSummary?.reasonCode || runLog?.runOutcome?.reasonCode) };
  const summaryLine = pickTpl(packBrief?.summaryTemplates || ["Summary: Subject advanced to Floor {payload.floorsReached}. Bosses cleared: {payload.bossesCleared}. Termination by {payload.termination}."], summaryPayload, `${seedStr}|summary`);
  lines.push(summaryLine, "");
  inserts.push({ order:1, insertType:"BRIEF_SUMMARY", floor:null, ts:"", importance:100, cooldownKey:"BRIEF_SUMMARY", payload:summaryPayload });

  let prevTags = null;
  for(let floor=1; floor<=floorsReached; floor++){
    const d = buildFloorDigest(floor);
    const tags = getBeatTags(d, prevTags);
    const tagText = tags.map((t,i)=>beatLabel(t,floor,i)).join(" • ");
    const chipDelta = (d.chipsStart!=null && d.chipsEnd!=null) ? (d.chipsEnd-d.chipsStart) : 0;
    const chipsVerbBank = chipDelta>0 ? packBrief?.chipsVerbs?.up : (chipDelta<0 ? packBrief?.chipsVerbs?.down : packBrief?.chipsVerbs?.flat);
    const chipsVerb = rngPick(chipsVerbBank || ["held"], makeRng(`${seedStr}|floor${floor}|verb`));
    const linePayload = {
      floor,
      tags: tagText,
      chipsVerb,
      chipsStart: fmtNum(d.chipsStart),
      chipsEnd: fmtNum(d.chipsEnd),
      chipsDelta: `${chipDelta>=0?'+':''}${fmtNum(chipDelta)}`,
      pressure: pressurePhrase(d,floor),
      risk: riskPhrase(d,floor),
      notable: pickNotables(d,floor),
      signature: signatureLine(floor)
    };
    const floorLine = pickTpl(packBrief?.floorLineTemplates || ["Floor {payload.floor} — {payload.tags}: Chips {payload.chipsVerb} {payload.chipsStart} → {payload.chipsEnd}.{payload.pressure}{payload.risk}{payload.notable} {payload.signature}"], linePayload, `${seedStr}|floor${floor}|line`);
    lines.push(floorLine);
    inserts.push({ order:10+floor, insertType:"BRIEF_FLOOR_LINE", floor, ts:"", importance:90, cooldownKey:`BRIEF_FLOOR_LINE@${floor}`, payload:linePayload });

    const bLine = bossLine(d, floor);
    if(bLine){
      lines.push(bLine);
      inserts.push({ order:20+floor, insertType:"BRIEF_BOSS_LINE", floor, ts:"", importance:88, cooldownKey:`BRIEF_BOSS_LINE@${floor}`, payload:{ text:bLine, rounds:d.boss.rounds, timerFail:d.boss.timerFail, countermeasures:d.boss.countermeasures } });
    }

    const margRate = Number(opts.marginaliaRate ?? 25);
    const margRng = makeRng(`${seedStr}|floor${floor}|marg`);
    if(margRng() < (margRate/100)){
      const margBank = packBrief?.marginalia?.[archetypeName] || packBrief?.marginalia?.generic || [];
      const marg = rngPick(margBank, makeRng(`${seedStr}|floor${floor}|margline`));
      if(marg){
        lines.push(`Archivist marginalia: ${marg}`);
        inserts.push({ order:30+floor, insertType:"BRIEF_MARGINALIA", floor, ts:"", importance:70, cooldownKey:`BRIEF_MARGINALIA@${floor}`, payload:{ line:marg } });
      }
    }

    lines.push("");
    prevTags = tags;
  }

  const calling = runLog?.finalState?.callingCard || runLog?.initialState?.callingCard;
  const dispPayload = {
    chipsStart: fmtNum(runSummary?.chipsStart ?? runLog?.initialState?.chips),
    chipsEnd: fmtNum(runSummary?.chipsEnd ?? runLog?.finalState?.chips),
    karmaEnd: fmtNum(runSummary?.karmaEnd ?? runLog?.finalState?.karma),
    callingCard: fmtCard(calling),
    deckState: include.deck ? formatDeckState(findLastDeckSnapshot()) : ""
  };
  const disp = pickTpl(packBrief?.dispositionTemplates || ["Disposition: Chips {payload.chipsStart} → {payload.chipsEnd}. Karma {payload.karmaEnd}. Calling {payload.callingCard}.{payload.deckState}"], dispPayload, `${seedStr}|disp`);
  lines.push(disp);
  inserts.push({ order:999, insertType:"BRIEF_DISPOSITION", floor:null, ts:"", importance:100, cooldownKey:"BRIEF_DISPOSITION", payload:dispPayload });

  return { story: lines.join("\n").replace(/\n{3,}/g,"\n\n").trim(), seedStr, inserts };
}


/* =========================================================
   UI Logic
   ========================================================= */
const $ = (id)=>document.getElementById(id);
const STATE = { runs: [], selected: 0, lastInserts: [], lastStory: "" };

function setTab(tab){
  document.querySelectorAll(".tab").forEach(el=>{
    el.classList.toggle("active", el.dataset.tab === tab);
  });
  $("tab_story").style.display = tab==="story" ? "" : "none";
  $("tab_inserts").style.display = tab==="inserts" ? "" : "none";
  $("tab_pack").style.display = tab==="pack" ? "" : "none";
}

document.querySelectorAll(".tab").forEach(el=>{
  el.addEventListener("click", ()=>setTab(el.dataset.tab));
});

function updateRunSelect(){
  $("runSelect").innerHTML = "";
  STATE.runs.forEach((r, idx)=>{
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = r.label;
    $("runSelect").appendChild(opt);
  });
  $("loadedCount").textContent = `${STATE.runs.length} loaded`;
  if(STATE.runs.length){
    $("runSelect").value = String(STATE.selected);
  }
}

function getSelectedRun(){
  if(!STATE.runs.length) return null;
  return STATE.runs[STATE.selected]?.log || null;
}

function includeFlags(){
  return {
    match: $("fMatch").checked,
    boss: $("fBoss").checked,
    shops: $("fShops").checked,
    deck: $("fDeck").checked,
    bench: $("fBench").checked,
    meta: $("fMeta").checked
  };
}

function refreshPackEditor(){
  $("packEditor").value = JSON.stringify(currentPack, null, 2);
}

function applyPackFromEditor(){
  try{
    const parsed = JSON.parse($("packEditor").value);
    // minimal validation
    if(!parsed || typeof parsed !== "object") throw new Error("Pack is not an object.");
    if(!parsed.brief || typeof parsed.brief !== "object") throw new Error("Missing brief object.");
    if(!parsed.headers || !Array.isArray(parsed.headers)) throw new Error("Missing headers array.");
    currentPack = parsed;
    toast("Pack applied.");
  }catch(err){
    alert("Pack JSON error:\\n" + err.message);
  }
}

function toast(msg){
  const pill = $("runMetaPill");
  const old = pill.textContent;
  pill.textContent = msg;
  pill.style.borderColor = "rgba(93,255,154,.35)";
  pill.style.background = "rgba(93,255,154,.10)";
  setTimeout(()=>{
    pill.textContent = old;
    pill.style.borderColor = "";
    pill.style.background = "";
  }, 1400);
}

function render(){
  const run = getSelectedRun();
  if(!run){
    $("storyOut").textContent = "Load a run log to begin.";
    $("runMetaPill").textContent = "No run loaded";
    $("seedPill").textContent = "Seed: —";
    $("pillPlayer").textContent = "Player: —";
    $("pillLines").textContent = "Lines: —";
    $("insertRows").innerHTML = "";
    STATE.lastInserts = [];
    STATE.lastStory = "";
    return;
  }

  const seedOverride = $("seedOverride").value;
  const marginaliaRate = Number($("margRate").value || 25);

  const playerName = run?.player?.name || run?.events?.[0]?.ctx?.playerName || "Unknown";
  $("pillPlayer").textContent = `Player: ${playerName}`;

  const res = renderRecordV3(run, {
    seedOverride,
    marginaliaRate,
    include: includeFlags(),
    includeDebug: $("includeDebug").checked
  });

  $("storyOut").textContent = res.story;
  $("pillLines").textContent = `Lines: ${res.story.split("\\n").filter(Boolean).length}`;
  $("seedPill").textContent = `Seed: ${res.seedStr}`;

  const runId = run?.runId || run?.sessionId || "—";
  $("runMetaPill").textContent = `${runId} • events: ${fmtNum(run?.events?.length || 0)}`;

  STATE.lastInserts = res.inserts;
  STATE.lastStory = res.story;

  // inserts table
  renderInsertTable();
}

function renderInsertTable(){
  const tf = String($("typeFilter").value || "").trim().toUpperCase();
  const maxRows = Number($("maxRows").value || 500);
  const rows = [];

  for(const ins of (STATE.lastInserts || [])){
    if(tf && !String(ins.insertType).toUpperCase().includes(tf)) continue;
    rows.push(ins);
    if(rows.length >= maxRows) break;
  }

  $("insertRows").innerHTML = rows.map(ins=>{
    const p = JSON.stringify(ins.payload || {});
    return `<tr>
      <td class="mono">${ins.order ?? ""}</td>
      <td class="mono">${String(ins.ts||"").slice(11,19)}</td>
      <td class="mono">${ins.floor ?? ""}</td>
      <td class="mono">${ins.matchSeq ?? ""}</td>
      <td><span class="chip cyan">${ins.insertType}</span></td>
      <td class="mono">${ins.importance ?? ""}</td>
      <td class="mono">${ins.cooldownKey || ""}</td>
      <td class="mono" style="max-width:480px">${p}</td>
    </tr>`;
  }).join("");
}

/* ---------- File loading ---------- */
async function loadFiles(fileList){
  const files = Array.from(fileList || []);
  if(!files.length) return;

  for(const f of files){
    try{
      const txt = await f.text();
      const log = JSON.parse(txt);
      const label = (log?.runId || log?.sessionId || f.name || "run").toString();
      STATE.runs.push({ label, fileName: f.name, log });
    }catch(err){
      console.warn("Failed to load", f?.name, err);
      alert(`Failed to parse ${f?.name}: ${err.message}`);
    }
  }

  // sort by label for convenience
  STATE.runs.sort((a,b)=>String(a.label).localeCompare(String(b.label)));
  STATE.selected = Math.min(STATE.selected, Math.max(0, STATE.runs.length-1));
  updateRunSelect();
  if(STATE.runs.length) $("runSelect").value = String(STATE.selected);

  // auto-fill player name into archetype inputs? (no)
  render();
}

/* ---------- Downloads ---------- */
function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function downloadJSON(filename, obj){
  downloadText(filename, JSON.stringify(obj, null, 2));
}
function toCSV(inserts){
  const cols = ["order","ts","floor","matchSeq","insertType","importance","cooldownKey","payload"];
  const esc = (v)=>{
    const s = (v==null) ? "" : String(v);
    if(/[",\\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const lines = [cols.join(",")];
  for(const ins of (inserts||[])){
    const row = [
      ins.order ?? "",
      ins.ts ?? "",
      ins.floor ?? "",
      ins.matchSeq ?? "",
      ins.insertType ?? "",
      ins.importance ?? "",
      ins.cooldownKey ?? "",
      JSON.stringify(ins.payload || {})
    ].map(esc);
    lines.push(row.join(","));
  }
  return lines.join("\\n");
}

/* ---------- Event wiring ---------- */
$("filePicker").addEventListener("change", (e)=>loadFiles(e.target.files));

$("dropZone").addEventListener("dragover", (e)=>{
  e.preventDefault();
  $("dropZone").style.borderColor = "rgba(82,224,255,.55)";
});
$("dropZone").addEventListener("dragleave", (e)=>{
  e.preventDefault();
  $("dropZone").style.borderColor = "";
});
$("dropZone").addEventListener("drop", (e)=>{
  e.preventDefault();
  $("dropZone").style.borderColor = "";
  loadFiles(e.dataTransfer.files);
});

$("runSelect").addEventListener("change", ()=>{
  STATE.selected = Number($("runSelect").value || 0);
  render();
});

["seedOverride","margRate","fMatch","fBoss","fShops","fDeck","fBench","fMeta","includeDebug"].forEach(id=>{
  $(id).addEventListener("input", ()=>{
    if(id==="margRate") $("margRateVal").textContent = String($("margRate").value);
    render();
  });
});

$("btnStory").addEventListener("click", render);

$("btnCopy").addEventListener("click", async ()=>{
  try{
    await navigator.clipboard.writeText(STATE.lastStory || "");
    toast("Copied story.");
  }catch{
    alert("Clipboard copy failed (browser permissions).");
  }
});

$("btnDownloadStory").addEventListener("click", ()=>{
  const run = getSelectedRun();
  if(!run) return;
  const runId = run?.runId || run?.sessionId || "run";
  downloadText(`archive_record_${runId}.txt`, STATE.lastStory || "");
});

$("btnDownloadCSV").addEventListener("click", ()=>{
  const run = getSelectedRun();
  if(!run) return;
  const runId = run?.runId || run?.sessionId || "run";
  downloadText(`p63_inserts_${runId}.csv`, toCSV(STATE.lastInserts || []));
});

$("btnClear").addEventListener("click", ()=>{
  STATE.runs = [];
  STATE.selected = 0;
  updateRunSelect();
  render();
});

$("typeFilter").addEventListener("input", renderInsertTable);
$("maxRows").addEventListener("input", renderInsertTable);

/* Pack editor */
$("btnPackReset").addEventListener("click", ()=>{
  currentPack = JSON.parse(JSON.stringify(BASE_PACK));
  refreshPackEditor();
  toast("Pack reset.");
});
$("btnPackApply").addEventListener("click", ()=>{
  applyPackFromEditor();
  render();
});
$("btnPackDownload").addEventListener("click", ()=>{
  downloadJSON("p63_story_pack_grand.json", currentPack);
});

/* init */
updateRunSelect();
$("margRateVal").textContent = String($("margRate").value);
refreshPackEditor();
render();
</script>
</body>
</html>
